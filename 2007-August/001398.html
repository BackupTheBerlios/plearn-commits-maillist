<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Plearn-commits] r7950 - in tags: . finlearn3-august2007	finlearn3-august2007/python_modules/plearn/plide	finlearn3-august2007/python_modules/plearn/pyplearn
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/plearn-commits/2007-August/index.html" >
   <LINK REL="made" HREF="mailto:plearn-commits%40lists.berlios.de?Subject=Re%3A%20%5BPlearn-commits%5D%20r7950%20-%20in%20tags%3A%20.%20finlearn3-august2007%0A%09finlearn3-august2007/python_modules/plearn/plide%0A%09finlearn3-august2007/python_modules/plearn/pyplearn&In-Reply-To=%3C200708072033.l77KX4jt019199%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001397.html">
   <LINK REL="Next"  HREF="001399.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Plearn-commits] r7950 - in tags: . finlearn3-august2007	finlearn3-august2007/python_modules/plearn/plide	finlearn3-august2007/python_modules/plearn/pyplearn</H1>
    <B>chrish at BerliOS</B> 
    <A HREF="mailto:plearn-commits%40lists.berlios.de?Subject=Re%3A%20%5BPlearn-commits%5D%20r7950%20-%20in%20tags%3A%20.%20finlearn3-august2007%0A%09finlearn3-august2007/python_modules/plearn/plide%0A%09finlearn3-august2007/python_modules/plearn/pyplearn&In-Reply-To=%3C200708072033.l77KX4jt019199%40sheep.berlios.de%3E"
       TITLE="[Plearn-commits] r7950 - in tags: . finlearn3-august2007	finlearn3-august2007/python_modules/plearn/plide	finlearn3-august2007/python_modules/plearn/pyplearn">chrish at mail.berlios.de
       </A><BR>
    <I>Tue Aug  7 22:33:04 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="001397.html">[Plearn-commits] r7949 - trunk/python_modules/plearn/parallel
</A></li>
        <LI>Next message: <A HREF="001399.html">[Plearn-commits] r7951 - trunk/plearn_learners/online
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1398">[ date ]</a>
              <a href="thread.html#1398">[ thread ]</a>
              <a href="subject.html#1398">[ subject ]</a>
              <a href="author.html#1398">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: chrish
Date: 2007-08-07 22:33:03 +0200 (Tue, 07 Aug 2007)
New Revision: 7950

Added:
   tags/finlearn3-august2007/
   tags/finlearn3-august2007/python_modules/
   tags/finlearn3-august2007/python_modules/plearn/plide/plide.py
   tags/finlearn3-august2007/python_modules/plearn/pyplearn/plargs.py
Removed:
   tags/finlearn3-august2007/python_modules/
   tags/finlearn3-august2007/python_modules/plearn/plide/plide.py
   tags/finlearn3-august2007/python_modules/plearn/pyplearn/plargs.py
Log:
Tag pour release finlearn3 august2007

Copied: tags/finlearn3-august2007 (from rev 7906, trunk)

Copied: tags/finlearn3-august2007/python_modules (from rev 7938, trunk/python_modules)

Deleted: tags/finlearn3-august2007/python_modules/plearn/plide/plide.py
===================================================================
--- trunk/python_modules/plearn/plide/plide.py	2007-08-07 00:50:45 UTC (rev 7938)
+++ tags/finlearn3-august2007/python_modules/plearn/plide/plide.py	2007-08-07 20:33:03 UTC (rev 7950)
@@ -1,968 +0,0 @@
-#  plide.py
-#  Copyright (C) 2006 by Nicolas Chapados
-#
-#  Redistribution and use in source and binary forms, with or without
-#  modification, are permitted provided that the following conditions are met:
-#
-#   1. Redistributions of source code must retain the above copyright
-#      notice, this list of conditions and the following disclaimer.
-#
-#   2. Redistributions in binary form must reproduce the above copyright
-#      notice, this list of conditions and the following disclaimer in the
-#      documentation and/or other materials provided with the distribution.
-#
-#   3. The name of the authors may not be used to endorse or promote
-#      products derived from this software without specific prior written
-#      permission.
-#
-#  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
-#  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-#  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
-#  NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-#  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-#  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-#  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-#  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-#  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-#  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-#
-#  This file is part of the PLearn library. For more information on the PLearn
-#  library, go to the PLearn Web site at www.plearn.org
-
-
-#####  Python Imports  ######################################################
-
-import fcntl
-import os, os.path
-import Queue
-import re
-import select, sys
-import threading, time, traceback
-
-
-#####  GTK Imports  #########################################################
-
-import gobject
-import pygtk
-pygtk.require('2.0')
-import gtk, gtk.gdk
-import pango
-from plearn.pl_pygtk import GladeAppWindow, GladeDialog, MessageBox
-
-
-#####  PLearn Imports  ######################################################
-
-from plearn.utilities.metaprog import public_members
-from plearn.pyplearn           import *
-from plearn.utilities.toolkit  import doc as toolkit_doc
-
-
-#####  Plide  ###############################################################
-
-from plide_help    import PlideHelp
-from plide_options import *
-from plide_tabs    import *
-from plide_utils   import *
-
-
-#####  Exports  #############################################################
-
-__all__ = [
-    'StartPlide',
-    'QuitPlide',
-    'GetWork',
-    'PostWorkResults',
-    'LogAppend',
-    'AllocateProgressBar',
-    'ReleaseProgressBar',
-    'ProgressUpdate'
-    ]
-
-
-#####  Global Configuration  ################################################
-
-def gladeFile():
-    import plearn.plide.plide
-    return os.path.join(os.path.dirname(plearn.plide.plide.__file__),
-                        &quot;resources&quot;, &quot;plide.glade&quot;)
-
-def helpResourcesPath():
-    import plearn.plide.plide
-    return os.path.join(os.path.dirname(plearn.plide.plide.__file__),
-                        &quot;resources&quot;)
-
-
-#####  Main Window  #########################################################
-
-class PlideMain( GladeAppWindow ):
-
-    PlideVersion = &quot;0.01&quot;
-
-    def __init__( self, streams_to_watch= {}, *args, **kwargs ):
-        GladeAppWindow.__init__(self, gladeFile())
-
-        ## Forward injected to imported Plide modules
-        PlideHelp.define_injected(injected)
-        PlideTab. define_injected(injected)
-        PyPLearnOptionsDialog.define_injected(injected, gladeFile)
-
-        ## Initialize Members
-        self.untitled_counter  = 1
-        self.work_requests = {}         # Request ids to expdir mapping
-        self.all_plearn_classes = injected.getAllClassnames()
-
-        ## Initialize Display
-        self.setup_statusbar()
-        self.log_filters = [ re.compile(&quot;WARNING.*Scintilla.*PosChanged.*deprecated&quot;) ]
-        self.log_clear()
-        self.log_hide()
-        welcome_text = kwargs.get(&quot;welcome_text&quot;,
-                                  &quot;&lt;b&gt;Welcome to Plide %s!&lt;/b&gt;&quot; % self.PlideVersion)
-        self.status_display(welcome_text, has_markup=True)
-        self.setup_stdouterr_redirect(streams_to_watch)
-        
-        ## Set up help system
-        injected.helpResourcesPath(helpResourcesPath())
-        self.help_viewer = PlideHelp(self)
-        self.help_viewer.display_page(&quot;index.html&quot;)
-        self.help_close()
-
-        ## Prepare the work queue
-        self.work_queue = PLearnWorkQueue()
-
-    def quit( self ):
-        ## Minor hack: the main-thread loop is terminated by receiving a
-        ## 'script' whose contents is Quit().  First close all tabs and
-        ## ensure that we stop the process if some tabs won't be closed.
-        n = self.w_plide_notebook.get_n_pages()
-        for i in range(n-1,-1,-1):
-            tab = self.get_nth_tab(i)
-            if not tab.close_tab():
-                return True        # Stop close process if cannot close tab
-        
-        print &gt;&gt;raw_stderr, &quot;Quit message received&quot;
-        raw_stderr.flush()
-        self.work_queue.post_work_request(&quot;Quit()&quot;,&quot;&quot;,&quot;&quot;)
-        GladeAppWindow.quit(self)
-
-    def help_close( self ):
-        &quot;&quot;&quot;Close the help pane.
-        &quot;&quot;&quot;
-        self.w_help_frame.hide()
-        self.w_help_frame.set_no_show_all(True)
-
-    def help_show( self ):
-        &quot;&quot;&quot;Open the help pane.  Bring up context-sensitive help if there is
-        a valid context in the current tab.
-        &quot;&quot;&quot;
-        self.w_help_frame.set_no_show_all(False)
-        self.w_help_frame.show()
-
-        curtab = self.get_current_tab()
-        if curtab:
-            help_context = curtab.get_help_candidate()
-            if help_context:
-                self.help_viewer.display_page(help_context)
-            
-    def setup_stdouterr_redirect( self, streams_to_watch= {} ):
-        &quot;&quot;&quot;Redirect standard output and error to be sent to the log pane
-        instead of the console.
-        &quot;&quot;&quot;
-        ## Redirect standard output and standard error to display to the
-        ## log pane area.  Keep around old stdout/stderr in order to
-        ## display debugging messages.  They are called, respectively,
-        ## raw_stdout and raw_stderr (Python file objects)
-        global raw_stdout, raw_stderr
-        old_stdout_fd = os.dup(sys.stdout.fileno())
-        old_stderr_fd = os.dup(sys.stderr.fileno())
-        raw_stdout    = os.fdopen(old_stdout_fd, 'w')
-        raw_stderr    = os.fdopen(old_stderr_fd, 'w')
-
-        print &gt;&gt;sys.stderr, &quot;Original stderr&quot;
-        print &gt;&gt;raw_stderr, &quot;Redirected stderr&quot;
-        sys.stderr.flush()
-        raw_stderr.flush()
-        
-        (self.stdout_read, self.stdout_write) = os.pipe()
-        (self.stderr_read, self.stderr_write) = os.pipe()
-        os.dup2(self.stdout_write, sys.stdout.fileno())
-        os.dup2(self.stderr_write, sys.stderr.fileno())
-        
-        out_flags = fcntl.fcntl(self.stdout_read, fcntl.F_GETFL)
-        err_flags = fcntl.fcntl(self.stderr_read, fcntl.F_GETFL)
-        fcntl.fcntl(self.stdout_read, fcntl.F_SETFL, out_flags | os.O_NONBLOCK)
-        fcntl.fcntl(self.stderr_read, fcntl.F_SETFL, err_flags | os.O_NONBLOCK)
-
-        streams_to_watch.update({ self.stdout_read:'stdout',
-                                  self.stderr_read:'stderr' })
-
-        def callback( fd, cb_condition ):
-            # print &gt;&gt;raw_stderr, &quot;log_updater: got stuff on fd&quot;, fd, \
-            #       &quot;with condition&quot;, cb_condition
-            raw_stderr.flush()
-            data = os.read(fd,65536)
-
-            kind = streams_to_watch.get(fd,'')
-            self.log_display(data, kind)
-            return True                 # Ensure it's called again!
-        
-        for s in streams_to_watch:
-            gobject.io_add_watch(s, gobject.IO_IN, callback)
-
-    def setup_statusbar( self ):
-        &quot;&quot;&quot;Arrange the status bar area to contain both a status line and a progress bar.
-        &quot;&quot;&quot;
-        ## The GTK StatusBar widget is a pain to use.  Our statusbar is an
-        ## hbox packed at the bottom of main_vbox, and containing:
-        ##
-        ## - A frame with a status label
-        ## - A progress bar
-        self.w_statusframe = gtk.Frame()
-        self.w_statusframe.set_shadow_type(gtk.SHADOW_IN)
-        self.status_display(' ')        # Establish proper height
-        self.w_statusframe.show()
-
-        self.w_progressbar = gtk.ProgressBar()
-        self.w_progressbar.set_ellipsize(pango.ELLIPSIZE_END)
-        self.w_progressbar.show()
-
-        ## This gives a list of the &quot;order&quot; in which progress bars should
-        ## be allocated as well as whether each one has been allocated
-        self.all_progressbars   = [ (self.w_progressbar,False) ]
-
-        self.w_statusbar = gtk.Table(rows=1, columns=4)
-        self.w_statusbar.attach(self.w_statusframe, left_attach=0, right_attach=3,
-                                top_attach=0, bottom_attach=1,
-                                xoptions=gtk.EXPAND | gtk.FILL,
-                                yoptions=gtk.EXPAND | gtk.FILL,
-                                xpadding=0, ypadding=0)
-        self.w_statusbar.attach(self.w_progressbar, left_attach=3, right_attach=4,
-                                top_attach=0, bottom_attach=1,
-                                xoptions=gtk.EXPAND | gtk.FILL,
-                                yoptions=gtk.EXPAND | gtk.FILL,
-                                xpadding=2, ypadding=2)
-        self.w_statusbar.show()
-        self.w_main_vbox.pack_start(self.w_statusbar, expand=False, fill=False)
-
-    def log_clear( self ):
-        &quot;&quot;&quot;The log is a TreeView widget that contains 3 columns: (1)
-        number, (2) kind, (3) log entry itself.  This sets up a new log or
-        clears an existing log.
-        &quot;&quot;&quot;
-        self.log_liststore = gtk.ListStore(int, str, str, int)
-
-        ## Create individual columns
-        self.log_columns = [ gtk.TreeViewColumn(x) for x in [ 'No.', 'Kind', 'Message' ] ]
-
-        ## Create cell renderers for displaying the contents
-        self.log_cells = [ gtk.CellRendererText() for i in xrange(len(self.log_columns)) ]
-        for i, (column, cell) in enumerate(zip(self.log_columns, self.log_cells)):
-            column.pack_start(cell, True)
-            column.add_attribute(cell, 'text', i)
-            column.set_sort_column_id(i)
-
-        ## Last column (message) is a bit tricky: we either set the
-        ## attribute 'text' or 'markup' depending on the setting of the
-        ## fourth model column
-        def message_format_func(treeviewcolumn, cell, model, iter):
-            message = model.get(iter,2)[0]
-            markup  = model.get(iter,3)[0]
-            cell.set_property('family-set', True)
-            if markup:
-                cell.set_property('markup', message)
-                cell.set_property('family', 'Helvetica')
-            else:
-                cell.set_property('text', message)
-                cell.set_property('family', 'Monospace')
-        self.log_columns[2].set_cell_data_func(self.log_cells[2], message_format_func)
-            
-        ## Create the TreeView using underlying liststore model and append columns
-        ## and make it searchable on the message
-        self.log_treeview = gtk.TreeView(self.log_liststore)
-        for column in self.log_columns:
-            self.log_treeview.append_column(column)
-        self.log_treeview.set_search_column(2)
-        self.log_treeview.set_rules_hint(True)
-
-        container_remove_children(self.w_plearn_log_scroller)
-        self.w_plearn_log_scroller.add(self.log_treeview)
-        self.log_treeview.show_all()
-
-        ## Reset the next log entry
-        self.log_next_number = 1
-
-    def log_hide( self ):
-        self.w_log_messages_menuitem.set_active(False)
-        self.w_plearn_log_scroller.hide()
-        self.w_plearn_log_scroller.set_no_show_all(True)
-
-    def log_show( self ):
-        self.w_log_messages_menuitem.set_active(True)
-        self.w_plearn_log_scroller.set_no_show_all(False)
-        self.w_plearn_log_scroller.show()
-        
-    def log_display( self, message, kind = &quot;&quot;, has_markup = False, log_clear = False ):
-        &quot;&quot;&quot;Append the given message to the log area of the main window.
-        Thread-safe.
-        &quot;&quot;&quot;
-        if log_clear:
-            self.log_clear()
-
-        ## If 'data' matches any regular expression in log_filter, skip
-        ## this message.  This is mostly a hack to get around displaying
-        ## known warnings from the Scintilla editor
-        for regex in self.log_filters:
-            if regex.search(message):
-                return
-
-        row = [ self.log_next_number, kind.rstrip(), message.rstrip(), has_markup ]
-        self.log_show()
-        self.log_liststore.append(row)
-        self.log_next_number += 1
-
-    def status_display( self, message, has_markup = False ):
-        &quot;&quot;&quot;Display the given message in the status bar area of the main window.
-        Thread-safe.
-        &quot;&quot;&quot;
-        label = gtk.Label(message)
-        if has_markup:
-            label.set_markup(message)
-        label.set_line_wrap(False)
-        label.set_alignment(0,0)
-        label.set_padding(2,2)
-        label.set_single_line_mode(True)
-        label.set_ellipsize(pango.ELLIPSIZE_MIDDLE)
-        label.show()
-        container_remove_children(self.w_statusframe)
-        self.w_statusframe.add(label)
-
-    def cursor_hourglass( self, unsensitize = True ):
-        &quot;&quot;&quot;Make the cursor an hourglass for the main window.
-
-        In addition, if the argument unsensitize is True, most entry
-        will be disabled for the window.
-        &quot;&quot;&quot;
-        self.w_root.window.set_cursor(gtk.gdk.Cursor(gtk.gdk.WATCH))
-        if unsensitize:
-            self.w_root.set_sensitive(False)
-
-    def cursor_normal( self, sensitize = True ):
-        &quot;&quot;&quot;Take back the cursor to normal form for the main window.
-        &quot;&quot;&quot;
-        self.w_root.window.set_cursor(None)  # Set back to parent window cursor
-        if sensitize:
-            self.w_root.set_sensitive(True)
-
-    def get_nth_tab( self, n ):
-        &quot;&quot;&quot;Return the PlideTab object corresponding to the n-th tab.
-        Return None if there is no such PlideTab.
-        &quot;&quot;&quot;
-        notebook_page = self.w_plide_notebook.get_nth_page(n)
-        if notebook_page:
-            return notebook_page.plide_tab_object
-        else:
-            return None
-
-    def get_current_tab( self ):
-        &quot;&quot;&quot;Return the PlideTab object that's currently selected in the
-        notebook.  Return None if none...
-        &quot;&quot;&quot;
-        cur_page = self.w_plide_notebook.get_current_page()
-        if cur_page &gt;= 0:
-            return self.w_plide_notebook.get_nth_page(cur_page).plide_tab_object
-        else:
-            return None
-
-    def get_current_tab_directory( self ):
-        &quot;&quot;&quot;Return the directory associated with the current PlideTab, or
-        '.' if there is no current tab.
-        &quot;&quot;&quot;
-        cur_tab = self.get_current_tab()
-        dir = None
-        if cur_tab is not None:
-            dir = cur_tab.get_directory()
-        return dir or '.'
-
-
-    #####  Progress Bar Handling  ###########################################
-
-    def reset_progress( self ):
-        &quot;&quot;&quot;Bring back the all progress bars to an 'available' state,
-        erase their containing text, and bring the fraction to zero.
-        &quot;&quot;&quot;
-        for i,(pb,alloc) in enumerate(self.all_progressbars):
-            pb.set_text('')
-            pb.set_fraction(0.0)
-            self.all_progressbars[i] = (pb,False)
-
-    def allocate_progress( self ):
-        &quot;&quot;&quot;Return the ID of an available progress bar, or -1 if none is
-        available.
-        &quot;&quot;&quot;
-        for i,(pb,alloc) in enumerate(self.all_progressbars):
-            if not alloc:
-                self.all_progressbars[i] = (pb,True)
-                return i
-
-        return -1
-
-    def release_progress( self, progress_id ):
-        &quot;&quot;&quot;Release an available progress bar and make it available for
-        other uses.
-        &quot;&quot;&quot;
-        (pb,alloc) = self.all_progressbars[progress_id]
-        self.all_progressbars[progress_id] = (pb,False)
-
-    def get_progress_from_id( self, progress_id ):
-        &quot;&quot;&quot;Return the gtk.ProgressBar widget corresponding to its id.
-        &quot;&quot;&quot;
-        return self.all_progressbars[progress_id][0]
-
-
-    #####  Callbacks  #######################################################
-
-    ## General
-    def on_plide_top_delete_event(self, widget, event):
-        return self.quit()
-
-    def on_quit_activate(self, widget):
-        self.quit()
-
-    ## File Menu
-    def on_new_activate(self, widget):
-        self.add_untitled_tab(&quot;.pyplearn&quot;)
-        
-    def on_new_pyplearn_script_activate(self, widget):
-        self.add_untitled_tab(&quot;.pyplearn&quot;)
-
-    def on_new_py_script_activate(self, widget):
-        self.add_untitled_tab(&quot;.py&quot;)
-
-    def on_new_plearn_script_activate(self, widget):
-        self.add_untitled_tab(&quot;.plearn&quot;)
-
-    def on_new_text_file_activate(self, widget):
-        self.add_untitled_tab(&quot;&quot;)
-
-    def on_open_activate(self, widget):
-        self.open_file()
-
-    def on_save_activate(self, widget):
-        if self.get_current_tab():
-            self.get_current_tab().on_save_activate()
-
-    def on_save_as_activate(self, widget):
-        if self.get_current_tab():
-            self.get_current_tab().save_as_file()
-
-    def on_close_activate(self, widget):
-        if self.get_current_tab():
-            self.get_current_tab().close_tab(widget)
-
-    def on_browse_expdir_activate(self, widget):
-        self.open_file(action=gtk.FILE_CHOOSER_ACTION_SELECT_FOLDER)
-
-    ## Edit menu
-    def on_undo_activate(self, widget):
-        self.get_current_tab().on_undo_activate()
-
-    def on_redo_activate(self, widget):
-        self.get_current_tab().on_redo_activate()
-
-    def on_cut_activate(self, widget):
-        self.get_current_tab().on_cut_activate()
-
-    def on_copy_activate(self, widget):
-        self.get_current_tab().on_copy_activate()
-
-    def on_paste_activate(self, widget):
-        self.get_current_tab().on_paste_activate()
-
-    ## View menu
-    def on_log_messages_toggled(self, menuitem):
-        if menuitem.get_active():
-            self.log_show()
-        else:
-            self.log_hide()
-
-    ## Help menu
-    def on_about_activate(self, widget):
-        version = injected.versionString().replace(&quot;(&quot;,&quot;\n(&quot;)
-        MessageBox(&quot;PLearn Integrated Development Environment Version &quot; + self.PlideVersion,
-                   &quot;Running on &quot; + version + &quot;\n&quot; +\
-                   &quot;Copyright (c) 2006 by Nicolas Chapados&quot;,
-                   title = &quot;About Plide&quot;)
-
-    ## Toolbar
-    def on_toolbutton_new_pyplearn_clicked(self, widget):
-        self.add_untitled_tab(&quot;.pyplearn&quot;)
-
-    def on_toolbutton_open_clicked(self, widget):
-        self.open_file()
-
-    def on_toolbutton_options_clicked(self, widget):
-        &quot;&quot;&quot;Display dialog box for establishing script options.
-        &quot;&quot;&quot;
-        tab = self.get_current_tab()
-        if tab is not None:
-            script      = tab.get_text()
-            name        = tab.get_basename()
-            script_dir  = tab.get_directory()
-
-            while True:                 # Loop to handle script reload
-                options_holder = tab.get_options_holder()
-                if not options_holder:
-                    ## When executing for the first time, run the script
-                    if self.pyplearn_parse( name, script ) is None:
-                        return              # Syntax errors in script
-                    options_holder = PyPLearnOptionsHolder(name, script, script_dir)
-                    tab.set_options_holder(options_holder)
-
-                options_dialog = PyPLearnOptionsDialog(options_holder)
-                result = options_dialog.run()
-                if result == gtk.RESPONSE_OK:
-                    options_dialog.update_options_holder()
-                options_dialog.destroy()
-
-                if result == gtk.RESPONSE_REJECT:
-                    tab.set_options_holder(None)
-                else:
-                    break
-
-    def on_toolbutton_execute_clicked(self, widget):
-        &quot;&quot;&quot;Launch the execution of the pyplearn script, only if it's indeed
-        such a script.
-        &quot;&quot;&quot;
-        tab = self.get_current_tab()
-        if tab is not None:
-            if type(tab) == PlideTabPyPLearn:
-                script_name    = tab.get_basename()
-                script_code    = tab.get_text()
-                launch_dir     = tab.get_directory()
-                options_holder = tab.get_options_holder()
-                if options_holder is not None:
-                    launch_dir = options_holder.launch_directory
-                self.pyplearn_executor(script_name, script_code, launch_dir,
-                                       options_holder)
-
-
-    ### Help-related
-    def on_help_activate(self, widget):
-        self.help_show()
-        
-    def on_help_close_clicked(self, widget):
-        self.help_close()
-        
-
-    #####  Tab Handling  ####################################################
-
-    def add_untitled_tab(self, extension):
-        self.add_intelligent_tab(&quot;untitled%d%s&quot; % (self.untitled_counter,
-                                                   extension), is_new=True)
-        self.untitled_counter += 1
-
-    def add_intelligent_tab(self, filename, is_new = False):
-        &quot;&quot;&quot;Create a new tab 'intelligently' depending on the filename type
-        or its extension. (If the file is new, rely on its extension only).
-        &quot;&quot;&quot;
-        filename = filename.rstrip(os.path.sep)
-        extension = os.path.splitext(filename)[1]
-        new_tab   = None
-        if extension == &quot;.pyplearn&quot; or extension == &quot;.py&quot;:
-            new_tab = PlideTabPyPLearn(self.w_plide_notebook, filename, is_new,
-                                       self.all_plearn_classes)
-
-        elif extension == &quot;.pmat&quot;:
-            new_tab = PlideTabPMat(self.w_plide_notebook, filename)
-
-        elif os.path.isdir(filename):
-            new_tab = PlideTabExpdir(self.w_plide_notebook, filename)
-
-        elif os.path.exists(filename):
-            new_tab = PlideTabFile(self.w_plide_notebook, filename, is_new)
-
-        elif is_new:
-            new_tab = PlideTabFile(self.w_plide_notebook, filename, is_new)
-            
-        else:
-            MessageBox(&quot;File '%s' is of unrecognized type&quot; % filename,
-                       type=gtk.MESSAGE_ERROR)
-
-        self.status_display('')         # Clear the status
-
-    def open_file(self, action=gtk.FILE_CHOOSER_ACTION_OPEN):
-        &quot;&quot;&quot;Display a file chooser dialog and add a new tab based on selected file.
-        &quot;&quot;&quot;
-        chooser = gtk.FileChooserDialog(
-            title=&quot;Open&quot;,
-            action=action,
-            buttons= (gtk.STOCK_CANCEL,gtk.RESPONSE_CANCEL,
-                      gtk.STOCK_OPEN,  gtk.RESPONSE_OK))
-
-        # Add file filters
-        filter = gtk.FileFilter()
-        filter.set_name(&quot;All files&quot;)
-        filter.add_pattern(&quot;*&quot;)
-        chooser.add_filter(filter)
-        
-        filter = gtk.FileFilter()
-        filter.set_name(&quot;Experiment scripts&quot;)
-        filter.add_pattern(&quot;*.plearn&quot;)
-        filter.add_pattern(&quot;*.pyplearn&quot;)
-        chooser.add_filter(filter)
-
-        filter = gtk.FileFilter()
-        filter.set_name(&quot;Data&quot;)
-        filter.add_pattern(&quot;*.pmat&quot;)
-        filter.add_pattern(&quot;.amat&quot;)
-        chooser.add_filter(filter)
-
-        chooser.set_default_response(gtk.RESPONSE_OK)
-        chooser.set_current_folder(self.get_current_tab_directory())
-        response = chooser.run()
-
-        ## Add all files selected by the user
-        if response == gtk.RESPONSE_OK:
-            filenames = chooser.get_filenames()
-            for f in filenames:
-                self.add_intelligent_tab(f, is_new=False)
-            
-        chooser.destroy()
-
-
-    #####  PLearn execution  ############################################
-
-    def pyplearn_executor( self, script_name, script_code, launch_directory,
-                           options_holder ):
-        &quot;&quot;&quot;Execute a pyplearn script within an options context.
-        
-        Operations are as follows:
-        
-        1. We execute the script one more time with the more
-           recent text (may have changed since last time options
-           were set)
-        2. We set the options corresponding each scoped object
-           in their own class
-        3. We parse the manual command-line arguments
-        4. We transform the script to a .plearn
-        5. We grab a hold of the soon-to-be-created expdir
-        6. We hand this script off to PLearn for execution
-        &quot;&quot;&quot;
-        script_env = self.pyplearn_parse( script_name, script_code )
-        if script_env is not None:
-            if options_holder:
-                options_holder.pyplearn_actualize()
-            else:
-                ## FIXME: Generate a brand-new expdir (minor hack)
-                plargs.parse([&quot;expdir=&quot;+generateExpdir()])
-                
-            expdir = plargs.expdir
-            plearn_script = eval('str(PyPLearnScript( main() ))', script_env)
-
-            message = 'Launching script &lt;b&gt;%s&lt;/b&gt; in directory &lt;b&gt;%s&lt;/b&gt;' % \
-                      (script_name, launch_directory)
-            self.status_display(message, has_markup=True)
-            self.log_display   (message, has_markup=True, log_clear=True)
-            if self.w_dump_plearn_to_log.get_active():
-                self.log_display(&quot;Expdir is: %s\n.plearn is:\n%s&quot; %
-                                 (expdir, plearn_script))
-            
-            request_id = self.work_queue.post_work_request(
-                plearn_script, launch_directory, &quot;pyplearn&quot;)
-            
-            print &gt;&gt;sys.stderr, &quot;Caller executing request_id&quot;, request_id
-            sys.stderr.flush()
-            self.work_requests[request_id] = os.path.join(launch_directory,expdir)
-            self.add_plearn_results_monitor( script_name, request_id )
-
-    def add_plearn_results_monitor( self, script_name, request_id, interval = 100 ):
-        &quot;&quot;&quot;Add a monitor callback to check for availability of PLearn
-        results every 'interval' milliseconds.
-        &quot;&quot;&quot;
-        def callback( ):
-            completion_result = \
-                self.work_queue.work_request_completed(request_id)
-
-            if completion_result is not None:
-                gtk.threads_enter()     # This is not a GTK+ callback
-                self.reset_progress()
-                (result_code, result_details) = completion_result
-
-                ## If result_code is &quot;&quot;, it means everything is OK.
-                if result_code == &quot;&quot;:
-                    message = &quot;&lt;b&gt;%s&lt;/b&gt; completed successfully&quot; % script_name
-                    self.status_display(message, has_markup = True)
-                    self.log_display(message, has_markup = True)
-
-                else:
-                    status_msg = &quot;&lt;b&gt;%s&lt;/b&gt; terminated due to errors&quot; % script_name
-                    self.status_display(status_msg, has_markup = True)
-                    message = ('A fatal error of kind &quot;%s&quot; was encountered during ' +\
-                               'execution of script &quot;%s&quot;.') % (result_code, script_name)
-                    details = &quot;Details:\n&quot; + result_details
-                    self.log_display(message+&quot;\n&quot;+details, has_markup = False)
-                    MessageBox(message, details, type=gtk.MESSAGE_ERROR)
-
-                ## Done: don't call again, and add a new tab corresponding
-                ## to the expdir.  Check for expdir existence first, since
-                ## some experiments don't necessarily leave an expdir around
-                if os.path.isdir(self.work_requests[request_id]):
-                    self.add_intelligent_tab(self.work_requests[request_id])
-                gtk.threads_leave()
-                return False
-            else:
-                ## Call again later
-                return True
-
-        ## Add the callback to the GTK list of callback
-        callback_id = gobject.timeout_add(interval, callback)
-        
-        
-    #####  PyPLearn Parse  ##############################################
-    
-    def pyplearn_parse( self, script_name, script_code ):
-        &quot;&quot;&quot;Ensure that a pyplearn script parses without error.
-
-        If an error is encountered, a backtrace is emitted to the log aread
-        and a message box is popped to indicate the error.  Return None in
-        this case.  Return the script execution environment if no error is
-        encountered.
-        &quot;&quot;&quot;
-
-        ## Implementation note: start by compiling the code to catch syntax
-        ## errors in the script.  Then execute with an 'exec' statement and
-        ## separately catch execution errors.
-        compiled_code = None
-        try:
-            self.cursor_hourglass()
-            compiled_code = compile(script_code+'\n', script_name, 'exec')
-        except ValueError:
-            pass
-        except SyntaxError, e:
-            self.cursor_normal()
-            (exc_type, exc_value, tb) = sys.exc_info()
-            self.status_display(&quot;Syntax error in script &lt;b&gt;%s&lt;/b&gt;&quot; % script_name,
-                                True)
-            self.log_display(''.join(traceback.format_exception_only(exc_type, exc_value)))
-            MessageBox('Syntax error in script &quot;%s&quot;.' % script_name,
-                       &quot;Python message: %s\nSee the log area for the detailed traceback.&quot; % \
-                       str(exc_value),
-                       title = &quot;PyPLearn Script Error&quot;,
-                       type=gtk.MESSAGE_ERROR)
-            return None
-
-        if compiled_code:
-            script_env  = { }
-            try:
-                exec compiled_code in script_env
-            except:
-                self.cursor_normal()
-                (exc_type, exc_value, tb) = sys.exc_info()
-                self.log_display(''.join(traceback.format_tb(tb)))
-                self.status_display(&quot;Exception during execution of script &lt;b&gt;%s&lt;/b&gt;.&quot;
-                                    % script_name, True)
-                MessageBox('Script &quot;%s&quot; raised exception &quot;%s: %s&quot;.' \
-                           % (script_name, str(exc_type), str(exc_value)),
-                       &quot;See the log area for the detailed traceback.&quot;,
-                       title = &quot;PyPLearn Script Error&quot;,
-                       type=gtk.MESSAGE_ERROR)
-                return None
-            else:
-                self.cursor_normal()
-                self.status_display(&quot;Script &lt;b&gt;%s&lt;/b&gt; parsed successfully.&quot;
-                                    % script_name, True)
-                return script_env
-
-        self.cursor_normal()
-
-
-#####  Utility Classes  #####################################################
-
-class PLearnWorkQueue( object ):
-    &quot;&quot;&quot;Worker thread for PLearn computation.
-
-    Since PLearn is quite highly dependent on the assumption of single
-    threading, this object simply passes work requests between the GUI
-    thread (which runs Plide) and the main thread (which runs PLearn).
-    Work requests are posted from the GUI the post_work_request() method,
-    which returns a work_id.  You can then poll the worker for task
-    completion status, or sleep until the task is completed.
-
-    Likewise, the main thread calls get_work_request(), which blocks until
-    a work request arrives.  The method returns a 4-tuple of strings of the
-    form [ request_id, script, root_directory, script_type ].  The main
-    thread can post results using the post_work_results() method.
-    &quot;&quot;&quot;
-    def __init__( self ):
-        self.requests_queue     = Queue.Queue()
-        self.results_queue      = Queue.Queue()
-        self.next_request_id    = 1
-        self.completion_results = { }
-
-    def post_work_request( self, script, script_dir, script_kind ):
-        &quot;&quot;&quot;Post a new work request to PLearn and return immediately.
-        &quot;&quot;&quot;
-        request_id = self.next_request_id
-        self.completion_results[str(request_id)] = None
-        self.requests_queue.put((str(request_id), script, script_dir, script_kind))
-        self.next_request_id += 1
-        return request_id
-
-    def get_work( self ):
-        &quot;&quot;&quot;Called by the PLearn main thread to get work to do.  Blocks
-        until there is work.
-        &quot;&quot;&quot;
-        return self.requests_queue.get()
-
-    def post_work_results( self, request_id, code, results ):
-        &quot;&quot;&quot;Called by the PLearn main thread to announce that it has finished
-        processing the work request 'request_id'.
-        &quot;&quot;&quot;
-        self.results_queue.put((request_id, code, results))
-
-    def work_request_completed( self, request_id ):
-        &quot;&quot;&quot;Return a pair (Code,Results) if the given work request is
-        finished processing by PLearn, and None if it's still being
-        processed.
-        &quot;&quot;&quot;
-        while not self.results_queue.empty():
-            (cur_id, code, results) = self.results_queue.get()
-            self.completion_results[cur_id] = (code, results)
-            print &gt;&gt;raw_stderr, &quot;work_request_completed:&quot;, (cur_id, code, results)
-            raw_stderr.flush()
-
-        return self.completion_results[str(request_id)]
-
-    def wait_for_work_request( self, request_id ):
-        &quot;&quot;&quot;Wait (block) until the specified work request is finished
-        processing by PLearn.
-        &quot;&quot;&quot;
-        while self.completion_results[str(request_id)] is None:
-            (cur_id, code, results) = self.results_queue.get()
-            self.completion_results[cur_id] = (code, results)
-
-
-#####  C++ Functional Interface  ############################################
-
-#global plide_main_window
-plide_main_window = None
-
-def StartPlide(argv = [], streams_to_watch= {}):
-    global plide_main_window
-    plide_main_window = PlideMain(streams_to_watch)
-
-    ## Consider each file passed as command-line argument and create a tab
-    ## to view it.
-    for arg in argv:
-        plide_main_window.add_intelligent_tab(arg, not os.path.exists(arg))
-
-    plide_main_window.run()       # Show and start event loop in other thread
-
-def QuitPlide():
-    if not plide_main_window.close_event.isSet():
-        gtk.threads_enter()
-        plide_main_window.quit()
-        gtk.threads_leave()
-
-def GetWork():
-    return plide_main_window.work_queue.get_work()
-
-def PostWorkResults( request_id, code, results ):
-    plide_main_window.work_queue.post_work_results(request_id, code, results)
-
-def LogAppend( kind, severity, message ):
-    gtk.threads_enter()
-    plide_main_window.log_display( message, kind )
-    gtk.threads_leave()
-    
-
-#####  C++ Progress Bar Interface  ##########################################
-
-def AllocateProgressBar( text ):
-    progress_id = plide_main_window.allocate_progress()
-    # print &gt;&gt;raw_stderr, &quot;Allocating progress bar&quot;, progress_id
-    raw_stderr.flush()
-    if progress_id &gt;= 0:
-        gtk.threads_enter()
-        pb = plide_main_window.get_progress_from_id(progress_id)
-        pb.set_text(text)
-        pb.set_fraction(0.0)
-        gtk.threads_leave()
-    return progress_id
-
-def ReleaseProgressBar( progress_id ):
-    # print &gt;&gt;raw_stderr, &quot;Releasing progress bar&quot;, progress_id
-    raw_stderr.flush()
-    if progress_id &gt;= 0:
-        gtk.threads_enter()
-        pb = plide_main_window.get_progress_from_id(progress_id)
-        pb.set_fraction(1.0)            # Make it complete on screen
-        gtk.threads_leave()
-        plide_main_window.release_progress( progress_id )
-
-def ProgressUpdate( progress_id, fraction ):
-    # print &gt;&gt;raw_stderr, &quot;Updating progress bar&quot;, progress_id,&quot;to fraction&quot;,fraction
-    raw_stderr.flush()
-    if progress_id &gt;= 0:
-        gtk.threads_enter()
-        pb = plide_main_window.get_progress_from_id(progress_id)
-        pb.set_fraction(fraction)
-        gtk.threads_leave()
-
-
-#####  Standalone Running  ##################################################
-
-from plearn.io.server import *
-
-class Poubelle(RemotePLearnServer):
-    &quot;&quot;&quot;
-    Patch to test standalone running while 'slave' mode still exists.
-    &quot;&quot;&quot;
-    def __init__(self):
-        command= 'plearn server'
-        self.errstm= None
-        try:
-            from subprocess import Popen, PIPE
-            p= Popen([command], shell=True, stdin=PIPE, stdout=PIPE, stderr=PIPE, close_fds=True)
-            (to_server, from_server, child_pid) = (p.stdin, p.stdout, p.pid)
-            self.errstm= p.stderr
-        except:
-            to_server, from_server = os.popen2(command, 'b')
-            child_pid = -1
-        RemotePLearnServer.__init__(self,from_server, to_server, pid=child_pid)
-
-
-    def getAllClassnames(self): return self.listClasses()
-    def helpResourcesPath(self,path): return self.setResourcesPathHTML(path)
-    def helpIndex(self): return self.helpIndexHTML()
-    def helpClasses(self): return self.helpClassesHTML()
-    def helpCommands(self): return self.helpCommandsHTML()
-    def helpOnCommand(self, command): return self.helpOnCommandHTML(command)
-    def helpOnClass(self, classname): return self.helpOnClassHTML(classname)
-
-if __name__ == &quot;__main__&quot;:
-    #class Poubelle:
-    #    def __getattr__(self, attr): return None
-
-    global plide_main_window
-    global injected
-    injected = Poubelle()
-    
-    StartPlide(streams_to_watch= {injected.errstm.fileno(): 'injected-stderr'})
-    # print &gt;&gt;sys.stderr, &quot;Random stuff to stderr&quot;
-    # print &gt;&gt;sys.stdout, &quot;Random stuff to stdout&quot;
-    # sys.stderr.flush()
-    # sys.stdout.flush()
-
-    # prid = AllocateProgressBar(&quot;Simple Progress Text&quot;)
-    # time.sleep(1)
-    # ProgressUpdate(prid,0.33)
-    # time.sleep(1)
-    # ProgressUpdate(prid,0.66)
-    # time.sleep(1)
-    # ReleaseProgressBar(prid)
-    # time.sleep(1)
-
-    plide_main_window.close_event.wait()  # Wait for window to be closed
-    QuitPlide()
-    

Copied: tags/finlearn3-august2007/python_modules/plearn/plide/plide.py (from rev 7944, trunk/python_modules/plearn/plide/plide.py)

Deleted: tags/finlearn3-august2007/python_modules/plearn/pyplearn/plargs.py
===================================================================
--- trunk/python_modules/plearn/pyplearn/plargs.py	2007-08-07 00:50:45 UTC (rev 7938)
+++ tags/finlearn3-august2007/python_modules/plearn/pyplearn/plargs.py	2007-08-07 20:33:03 UTC (rev 7950)
@@ -1,1221 +0,0 @@
-# plargs.py
-# Copyright (C) 2006 Christian Dorion
-#
-#  Redistribution and use in source and binary forms, with or without
-#  modification, are permitted provided that the following conditions are met:
-#
-#   1. Redistributions of source code must retain the above copyright
-#      notice, this list of conditions and the following disclaimer.
-#
-#   2. Redistributions in binary form must reproduce the above copyright
-#      notice, this list of conditions and the following disclaimer in the
-#      documentation and/or other materials provided with the distribution.
-#
-#   3. The name of the authors may not be used to endorse or promote
-#      products derived from this software without specific prior written
-#      permission.
-#
-#  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
-#  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-#  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
-#  NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-#  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-#  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-#  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-#  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-#  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-#  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-#
-#  This file is part of the PLearn library. For more information on the PLearn
-#  library, go to the PLearn Web site at www.plearn.org
-
-# Author: Christian Dorion
-&quot;&quot;&quot;Management of command-line options.
-
-A custom (and encouraged) practice is to write large PyPLearn scripts
-which behaviour can be modified by command-line arguments, e.g.:: 
-        
-    prompt %&gt; plearn command_line.pyplearn on_cmd_line=&quot;somefile.pmat&quot; input_size=10
-
-with the command_line.pyplearn script being::
-
-    #
-    # command_line.pyplearn
-    #
-    from plearn.pyplearn import *
-
-    dataset = pl.AutoVMatrix( specification = plargs.on_cmd_line,
-                              inputsize     = int( plargs.input_size ),
-                              targetsize    = 1
-                              )
-
-    def main():
-        return pl.SomeRunnableObject( dataset  = dataset,
-                                      internal = SomeObject( dataset = dataset ) )
-
-Those command-line arguments are widely refered as L{plargs}, on
-account of this class, troughout the pyplearn mechanism. Note that
-I{unexpected} (see binders and L{namespaces&lt;plnamespace&gt;} hereafter)
-arguments given on the command line are interpreted as strings, so if
-you want to pass integers (int) or floating-point values (float), you
-will have to cast them as above.
-
-To set default values for some arguments, one can use
-L{plarg_defaults&lt;_plarg_defaults&gt;}. For instance::
-
-    # 
-    # command_line_with_defaults.pyplearn
-    #
-    from plearn.pyplearn import *
-
-    plarg_defaults.on_cmd_line = &quot;some_default_file.pmat&quot;
-    plarg_defaults.input_size  = 10
-    dataset = pl.AutoVMatrix( specification = plargs.on_cmd_line,
-                              inputsize     = plargs.input_size,
-                              targetsize    = 1
-                              )
-
-    def main( ):
-        return pl.SomeRunnableObject( dataset  = dataset,
-                                      internal = SomeObject( dataset = dataset ) )
-    
-which won't fail and use C{&quot;some_default_file.pmat&quot;} with C{input_size=10} if::
-
-    prompt %&gt; plearn command_line_with_defaults.pyplearn
-
-is entered. Note that since I{input_size} was defined as an int
-(C{plarg_defaults.input_size = 10}). Even if
-L{plarg_defaults&lt;_plarg_defaults&gt;} is still supported, it is preferable
-to define all arguments' default values through some I{binder}. We
-refer to subclasses of L{plargs} as I{binders} since they bind default
-values to expected/possible command-line arguments, e.g::
-
-    # 
-    # my_script.pyplearn
-    #
-    from plearn.pyplearn.plargs import *
-
-    class Misc(plargs):
-        algo      = &quot;classical&quot;
-        ma_len    = plopt([126, 252],
-                          doc=&quot;A list of moving average lenghts to be used &quot;
-                          &quot;during the preprocessing.&quot;)
-        n_inputs  = plopt(10, doc=&quot;The number of inputs to be used.&quot;)
-
-    print &gt;&gt;sys.stderr, repr(plargs.algo), repr(plargs.n_inputs)
-    assert plargs.n_inputs==Misc.n_inputs
-
-    print &gt;&gt;sys.stderr, Misc.ma_len
-        
-would print (as first line) C{&quot;classical&quot;, 10}, a string and an int, if
-no command-line arguments override those L{plargs}. One can always
-access the I{plarg} through C{plargs} or C{Misc} (i.e. the assertion
-never fails).
-
-Note the use of L{plopt} instances. While these are not mandatory, they
-are very useful and powerful tools which one can use to make his
-scripts clearer and more user-friendly when used within
-U{plide&lt;<A HREF="http://plearn.berlios.de/plide">http://plearn.berlios.de/plide</A>&gt;}. Note that list can be
-provided to as command-line argument in the CSV format, that is::
-
-    prompt %&gt; plearn my_script.pyplearn ma_len=22,63,126,252
-    &quot;classical&quot;, 10
-    [22, 63, 126, 252]
-
-While I{binders} allow one to define default values for L{plargs},
-these are limited in the sens that clashes can occur::
-
-    # 
-    # complex_script.pyplearn
-    #
-    from plearn.pyplearn.plargs import *
-    
-    class macd(plargs):
-        ma_len = plopt(252,
-                    doc=&quot;The moving average length to be used in the macd model.&quot;)
-
-    class PCA(plargs):
-        algo      = &quot;classical&quot;
-        ma_len    = plopt([126, 252],
-                          doc=&quot;A list of moving average lenghts to be used &quot;
-                          &quot;during the preprocessing.&quot;)
-        n_inputs  = plopt(10, doc=&quot;The number of inputs to be used.&quot;)
-
-    ...
-    #####
-    prompt %&gt; plearn complex_script.pyplearn 
-    Traceback (most recent call last):
-    File &quot;TEST.pyplearn&quot;, line 7, in ?
-        class PCA(plargs):
-    File &quot;/home/dorionc/PLearn/python_modules/plearn/pyplearn/plargs.py&quot;, line 447, in __new__
-        plopt.define(cls, option, value)
-    File &quot;/home/dorionc/PLearn/python_modules/plearn/pyplearn/plargs.py&quot;, line 193, in define
-        raise KeyError(
-    KeyError: &quot;A script should not contain two options of the same name. Clashing
-    definition of plarg 'ma_len' in 'macd' and 'PCA'&quot;
-
-To avoid this type of error, one can L{namespace&lt;plnamespace&gt;} the
-arguments of his script::
-
-    # 
-    # namespaced.pyplearn
-    #
-    from plearn.pyplearn.plargs import *
-    
-    class macd(plnamespace):
-        ma_len = plopt(252,
-                    doc=&quot;The moving average length to be used in the macd model.&quot;)
-
-    class PCA(plnamespace):
-        algo      = &quot;classical&quot;
-        ma_len    = plopt([126, 252],
-                          doc=&quot;A list of moving average lenghts to be used &quot;
-                          &quot;during the preprocessing.&quot;)
-        n_inputs  = plopt(10, doc=&quot;The number of inputs to be used.&quot;)
-
-    print &gt;&gt;sys.stderr, macd.ma_len, PCA.algo, PCA.ma_len
-
-    try:
-        print &gt;&gt;sys.stderr, plargs.n_inputs
-    except AttributeError:
-        print &gt;&gt;sys.stderr, \
-              &quot;n_inputs is namespaced, you must access it through 'PCA'&quot;
-
-    #####
-    prompt %&gt; plearn namespaced.pyplearn macd.ma_len=126 PCA.algo=weird
-    252 weird [126, 252]
-    n_inputs is namespaced, you must access it through 'PCA'
-
-Finally, B{note that} the value of C{plargs.expdir} is generated automatically and
-B{can not} be assigned a default value through binders. This behaviour
-aims to standardize the naming of experiment directories. For debugging
-purpose, however, one may provide on command-line an override to
-C{plargs.expdir} value. Otherwise, one can also provide the I{expdir_root}
-command-line argument as a (relative) path where the expdir should be
-found, e.g.::
-
-    prompt %&gt; plearn my_script.pyplearn expdir_root=Debug
-
-would cause experiment to use the expdir::
-
-    Debug/expdir_2006_05_10_07_58_10
-    
-for instance.
-&quot;&quot;&quot;
-import copy, inspect, logging, new, re, sys
-from plearn.pyplearn.context import *
-from plearn.utilities.Bindings import Bindings
-
-# Helper functions
-
-def neglected_member(name, value):
-    return (name.startswith('_') 
-            or inspect.ismethod(value) or inspect.isfunction(value)
-            or inspect.isroutine(value) or inspect.isclass(value) )
-
-def list_cast(slist, elem_cast):
-    &quot;&quot;&quot;Intelligently casts I{slist} string to a list.
-
-    The I{slist} argument can have the following forms::
-
-        - CSV::
-            slist = &quot;1,2,3&quot; =&gt; casted = [1, 2, 3]
-        - CSV with brackets::
-            slist = &quot;[hello,world]&quot; =&gt; casted = [&quot;hello&quot;, &quot;world&quot;]
-        - List of strings::
-            slist = [ &quot;100.0&quot;, &quot;102.5&quot; ] =&gt; casted = [ 100.0, 102.5 ]
-
-    The element cast is made using the I{elem_cast} argument.
-    &quot;&quot;&quot;
-    # CSV (with or without brackets)
-    slist = slist.strip()
-    #print &gt;&gt;sys.stderr, repr(slist), type(slist)
-    if isinstance(slist,str):
-        if slist==&quot;&quot;:
-            slist = []
-        elif slist.startswith(&quot;[&quot;):
-            assert slist.endswith(&quot;]&quot;)
-            slist = eval(slist)
-        else:
-            slist = slist.split(&quot;,&quot;)
-        return [ elem_cast(e) for e in slist ]
-
-    # List of strings
-    elif isinstance(slist, list):
-        return [ elem_cast(e) for e in slist ]
-
-    else:
-        raise ValueError, &quot;Cannot cast '%s' into a list&quot;, str(slist)
-
-def warn(message, category=UserWarning, stacklevel=0):
-    import os
-    pytest_state = os.environ.get(&quot;PYTEST_STATE&quot;, &quot;&quot;)
-    if pytest_state!=&quot;Active&quot;:        
-        from warnings import warn
-        warn(message, category, stacklevel=stacklevel+3)
-
-#######  Classes to Manage Command-Line Arguments  ############################
-
-class plopt(object):
-    &quot;&quot;&quot;Typed command-line options with constraints for PLearn.
-    
-    This class provides support for default values, strong type checking,
-    conversion from a string representation, documentation, and constraints
-    on the possible values that the option can take.  The syntax to follow
-    is along the lines of::
-    
-        class MyOptions( plargs_namespace ):
-            plot_stuff  = plopt(True, doc='Whether a cute graph should be plotted')
-            K           = plopt(10, min=5, max=25, doc='Number of neighbors to consider')
-            method      = plopt('classical', choices=['new-kind','classical','crazy'])
-            lags        = plopt([1,22,252], doc='Lags to incorporate as inputs, in days')
-            weight_cols = plopt([], elem_type=int)
-
-    The supported keywords are
-
-        - B{doc}: The help string for that option.
-
-        - B{choices}: A list of values accepted for that option. Trying to
-          set this option's value to anything which is not in that list will cause
-          a ValueError to be raised.
-
-        - B{min, max}: Bounds for numeric values. You can specify only one
-          of the two. Trying to set this option to value out of these bounds will
-          cause a ValueError to be raised.
-
-        - B{free_choices}: A list of suggestions as to what the field should contain.
-          Still, this option can be set to whatever value you wish and a ValueError
-          will never be raised.
-
-        - B{type}: This keyword can and must only be used when the default
-          value is None. Otherwise, it is infered using 'type(value)'.
-
-        - B{elem_type}: For list options, the type of the elements is
-          usually infered from the first element of the list. This keyword
-          may however be used to specify the type for the elements of a
-          list which defaults as empty. If the list defaults as empty
-          I{and} 'elem_type' keyword is not provided, then the elements' type is
-          assumed to be 'str'.
-
-    A plopt I{holder} refers to either a plargs binder or a plnamespace.
-    &quot;&quot;&quot;
-    
-    unnamed = &quot;### UNNAMED ###&quot;
-
-    def __init__(self, value, **kwargs):
-        self._name  = kwargs.pop(&quot;name&quot;, self.unnamed)
-        self._doc   = kwargs.pop(&quot;doc&quot;, '')
-        self._gui   = kwargs.pop(&quot;gui&quot;, True)
-
-        # type: This keyword can and must only be used when the default
-        # value is None. Otherwise, it is infered using 'type(value)'.
-        assert not (&quot;type&quot; in kwargs and value is not None)
-        if value is None:
-            if &quot;type&quot; not in kwargs:
-                warn(&quot;When a plopt value defaults to None, a valid type must be &quot;
-                     &quot;provided using the 'type' keyword argument. &quot;
-                     &quot;String is assumed for now...&quot;, FutureWarning, 2)
-                kwargs['type'] = str
-            self._type = kwargs.pop(&quot;type&quot;)
-        else:
-            self._type = type(value)
-
-        # Keep the remaining kwargs for further use.
-        self._kwargs = kwargs
-
-        # Sanity checks
-        self.checkBounds(value)
-        self.checkChoices(value)
-        self.__default_value = value # The check did not raise: 'value' is valid
-
-    def __str__(self):
-        &quot;&quot;&quot;Short string representation of a plopt instance.
-
-        Either::
-            plopt(value = DEFAULT_VALUE)
-        or::
-            plopt(value = VALUE [default: DEFAULT_VALUE])
-
-        where the second occurs if the current value is not equal to the default value.
-        &quot;&quot;&quot;
-        value = self.get()
-        value_str = repr(value)
-        if value != self.__default_value:
-            value_str += &quot; [default: %s]&quot;%repr(self.__default_value)
-        return &quot;plopt(value = %s)&quot;%value_str
-
-    def cast(self, value):
-        casted = None
-        
-        # Special string to bool treatment
-        if self._type is bool and isinstance(value, str):
-            if value == &quot;True&quot;:
-                casted = True
-            elif value == &quot;False&quot;:
-                casted = False
-            else:
-                raise ValueError(&quot;Trying to set value %s to bool-typed option %s&quot;
-                                 %(value, self._name))
-
-        # Special treatment for list option
-        elif self._type is list :
-            elem_type = self._kwargs.pop(&quot;elem_type&quot;, None) 
-            if elem_type is None:
-                got= self.get()
-                if got!=None and len(got) &gt; 0:
-                    elem_type = type(self.get()[0])
-                else:
-                    elem_type = str
-            casted = list_cast(value, elem_type)
-
-        # Simple type cast
-        else:
-            casted = self._type(value)
-
-        return casted
-    
-    def checkBounds(self, value):
-        &quot;&quot;&quot;Checks that value lies between 'min' and 'max' bounds parsed from self.kwargs.&quot;&quot;&quot;
-        minimum = self._kwargs.get(&quot;min&quot;, None)
-        if minimum is not None and value &lt; minimum:
-            raise ValueError(&quot;Option %s (=%s) should greater than %s&quot;
-                             %(self._name, repr(value), repr(minimum)))
-
-        maximum = self._kwargs.get(&quot;max&quot;, None)
-        if maximum is not None and value &gt; maximum:
-            raise ValueError(&quot;Option %s (=%s) should lower than %s&quot;
-                             %(self._name, repr(value), repr(minimum)))
-
-    def checkChoices(self, value):
-        &quot;&quot;&quot;Checks that 'value' is one of the 'choices' parsed from self.kwargs.&quot;&quot;&quot;
-        choices = self._kwargs.get(&quot;choices&quot;, None)
-        if choices is not None and value not in choices:
-            name = &quot;&quot;
-            if self._name != self.unnamed:
-                name = self._name+&quot; &quot; 
-            raise ValueError(
-                &quot;Option %sshould be in choices=%s&quot;%(name, choices))
-
-    def get(self):
-        &quot;&quot;&quot;Returns the current context override, if any, o/w returns the default value.&quot;&quot;&quot;
-        plopt_overrides = actualContext(plopt).plopt_overrides
-        if self in plopt_overrides:
-            return plopt_overrides[self]
-        return self.__default_value
-
-    def getBounds(self):
-        minimum = self._kwargs.get(&quot;min&quot;, None)
-        maximum = self._kwargs.get(&quot;max&quot;, None)
-        return minimum, maximum
-
-    def getChoices(self):
-        return self._kwargs.get(&quot;choices&quot;, None)
-
-    def getDefault(self):
-        return self.__default_value
-
-    def getFreeChoices(self):
-        return self._kwargs.get(&quot;free_choices&quot;, None)
-
-    def getName(self):
-        assert self._name != self.unnamed
-        return self._name
-
-    def getType(self):
-        return self._type
-
-    def getGui(self):
-        return self._gui
-
-    def reset(self):
-        &quot;&quot;&quot;Simply deletes any override for this plopt in the current context.
-        
-        Note that the actual implementation of C{define()} leads to
-        forgetting the command-line override if C{reset()} is called on the
-        plopt instance!
-        &quot;&quot;&quot;
-        actualContext(plopt).plopt_overrides.pop(self, None)
-        
-    def set(self, value):
-        &quot;&quot;&quot;Sets an override for this plopt in the current context&quot;&quot;&quot;
-        if not isinstance(value, self._type):
-            value = self.cast(value)
-        # Sanity checks 
-        self.checkBounds(value)
-        self.checkChoices(value)
-    
-        # The previous didn't raise exeption, the 'value' is valid
-        actualContext(plopt).plopt_overrides[self] = value
-
-    def setDefault(self, default):
-        self.__default_value = default
-
-    #######  Static methods  ######################################################
-
-    def addCmdLineOverride(holder_name, optname, value):
-        context = actualContext(plopt)
-        hldr_key = (holder_name, optname)
-        # Use the 'unique' key to store command-line override's value
-        context.plopt_cmdline_overrides[hldr_key] = value
-    addCmdLineOverride = staticmethod(addCmdLineOverride)
-
-    def popCmdLineOverride(actual_holder, optname):
-        context = actualContext(plopt)
-        hldr_key = (actual_holder.__name__, optname)
-        override_value = context.plopt_cmdline_overrides.pop(hldr_key, None)
-
-        # If the option is not namespaced, it may have been provided
-        # without the binder name as prefix. Try accessing the key with
-        # None instead of the holder's name
-        if override_value is None \
-           and not issubclass(actual_holder, plnamespace):
-            hldr_key = (None, optname)
-            override_value = context.plopt_cmdline_overrides.pop(hldr_key, None)
-
-        # Will return None if no option named 'optname' were overridden on
-        # the command line
-        return override_value
-    popCmdLineOverride = staticmethod(popCmdLineOverride)
-
-    def buildClassContext(context):
-        assert not hasattr(context, 'plopt_binders')
-        context.plopt_binders = {}
-
-        assert not hasattr(context, 'plopt_namespaces')
-        context.plopt_namespaces = {}
-
-        assert not hasattr(context, 'plopt_overrides')
-        context.plopt_overrides = {}
-
-        assert not hasattr(context, 'plopt_cmdline_overrides')
-        context.plopt_cmdline_overrides = {}
-    buildClassContext = staticmethod(buildClassContext)
-
-    def closeClassContext(context):
-        exceptions = [ 'FILEBASE', 'FILEPATH', 'TIME', 'DATETIME',
-                       'FILEEXT', 'DIRPATH', 'DATE', 'HOME', 'FILENAME' ]
-
-        del context.plopt_binders
-        del context.plopt_namespaces
-        del context.plopt_overrides
-
-        unused = []
-        for (hldr_name, optname), value in context.plopt_cmdline_overrides.iteritems():
-            if optname in exceptions:
-                continue
-            elif hldr_name is None:
-                unused.append(&quot;%s=%s&quot;%(optname, value))
-            else:
-                unused.append(&quot;%s.%s=%s&quot;%(hldr_name, optname, value))
-                
-        if unused:
-            from plearn.pyplearn import PyPLearnError
-            raise PyPLearnError(
-                &quot;The following command-line arguments were not expected &quot;
-                &quot;(Misspelled? Or namespaced?): %s&quot; % &quot;, &quot;.join(unused))
-
-        # Finally, delete the list
-        del context.plopt_cmdline_overrides
-    closeClassContext = staticmethod(closeClassContext)    
-
-    def define(holder, option, value):
-        &quot;&quot;&quot;Typical pattern to set a plopt instance member in 'holder' for the first time.&quot;&quot;&quot;
-        context = actualContext(plopt)
-
-        # Check if an override was defined through parsing before the
-        # holder existed. Returns None in the case no override exists.
-        cmdline_override = plopt.popCmdLineOverride(holder, option)
-
-        ### Holder-type specific management
-        plopt._inner_define(holder, option, value)
-
-        # Command-line MUST override mandatory plopts
-        if isinstance(value, mandatory_plopt) and cmdline_override is None:
-            from plearn.pyplearn import PyPLearnError
-            raise PyPLearnError(
-                &quot;Mandatory argument %s.%s was not received on command line.&quot;
-                %(holder.__name__, value.getName()) )
-        
-        # Overrides the default with the command-line override if any. Note
-        # that this way to proceed leads to forgetting the command-line
-        # override if reset() is called on the plopt instance!!!
-        if cmdline_override is not None:
-            plopt.override(holder, option, cmdline_override)            
-    define = staticmethod(define)
-
-    def _inner_define(holder, option, value):
-        &quot;&quot;&quot;Holder-type specific management.&quot;&quot;&quot;
-        context = actualContext(plopt)
-            
-        if issubclass(holder, plargs):
-            # A script should not contain two options of the same name
-            if option in context.plopt_binders:
-                raise KeyError(
-                    &quot;A script should not contain two options of the same name. &quot;
-                    &quot;Clashing definition of plarg '%s' in '%s' and '%s'&quot;%
-                    (option,context.plopt_binders[option].__name__,holder.__name__))
-        
-            # Keep a pointer to the binder in which the option is defined
-            context.plopt_binders[option] = holder
-
-        elif issubclass(holder, plnamespace):
-            # Keep a pointer to the namespace in which the option is defined
-            context.plopt_namespaces[option] = holder
-
-        else:
-            raise TypeError(&quot;Holder '%s' is of an unknown type: %s&quot;
-                            % (holder.__name__, type(holder)) )
-
-        # Enforce all 'holder' members to be (named) plopt instances
-        if isinstance(value, plopt):
-            value._name = option
-        else:
-            value = plopt(value, name=option)
-
-        # Acutally sets the plopt in the holder
-        type.__setattr__(holder, option, value)        
-    _inner_define = staticmethod(_inner_define)
-
-    def getHolder(plopt_name):        
-        return actualContext(plopt).plopt_binders.get(plopt_name)
-    getHolder = staticmethod(getHolder)
-
-    def iterator(holder):
-        &quot;&quot;&quot;Returns an iterator over the plopt instances contained in the I{holder}&quot;&quot;&quot;
-        keys = holder.__dict__.keys()
-        keys.sort()
-        return iter([ holder.__dict__[key] for key in keys
-                      if isinstance(holder.__dict__[key], plopt) ])
-    iterator = staticmethod(iterator)
-
-    def optdict(holder):
-        return dict([ (opt.getName(), opt.get()) for opt in plopt.iterator(holder) ])
-    optdict = staticmethod(optdict)
-
-    def override(holder, option, value):
-        &quot;&quot;&quot;Typical pattern to override the value of an existing plopt instance.&quot;&quot;&quot;
-        plopt_instance = type.__getattribute__(holder, option)
-        plopt_instance.set(value)
-    override = staticmethod(override)
-
-class mandatory_plopt(plopt):
-    def __init__(self, type, **kwargs):
-        self._type  = type
-        self._name  = kwargs.pop(&quot;name&quot;, self.unnamed)
-        self._doc   = kwargs.pop(&quot;doc&quot;, '')        
-
-        # Keep the remaining kwargs for further use.
-        self._kwargs = kwargs
-
-        # For __str__ use only
-        self.__default_value = None
-    
-class plargs(object):
-    &quot;&quot;&quot;Values read from or expected for PLearn command-line variables.
-
-    The core class of this module. See modules documentation for details on
-    possible uses.
-    &quot;&quot;&quot;
-    _extensible_ = False
-
-    #######  Static methods  ######################################################
-
-    def buildClassContext(context):
-        assert not hasattr(context, 'binders')
-        context.binders = {}
-    buildClassContext = staticmethod(buildClassContext)
-
-    def getBinders():
-        &quot;&quot;&quot;Returns a list of all binders in the current context.&quot;&quot;&quot;
-        context = actualContext(plargs)
-        binder_names = context.binders.keys()
-        binder_names.sort()
-
-        binders = []
-        for bname in binder_names:
-            binders.append(context.binders[bname])        
-        return binders
-    getBinders = staticmethod(getBinders)
-
-    def getContextBindings():
-        &quot;&quot;&quot;Returns a L{Bindings} instance of plopt name-to-value pairs.
-
-        The bindings could thereafter be used to re-create the current
-        context from a command-line::
-
-            bindings = plargs.getContextBindings()
-            cmdline = [ &quot;%s=%s&quot;%(opt, bindings['opt']) for opt in bindings ]
-            actual_command_line = &quot; &quot;.join(cmdline)
-        &quot;&quot;&quot;
-        context = actualContext(plargs)
-        bindings = Bindings( )
-
-        for binder in plargs.getBinders():
-            for opt in plopt.iterator(binder):
-                bindings[opt.getName()] = opt.get()
-
-        for namespace in plargs.getNamespaces():
-            for opt in plopt.iterator(namespace):
-                key = &quot;%s.%s&quot;%(namespace.__name__, opt.getName())
-                bindings[key] = opt.get()
-
-        return bindings
-    getContextBindings = staticmethod(getContextBindings)
-
-    def getNamespaces():
-        &quot;&quot;&quot;Returns a list of all namespaces in the current context.&quot;&quot;&quot;
-        # Note the (hackish?) use of plnamespace. Needed to ensure the
-        # existance of context.namepaces...
-        context = actualContext(plnamespace) 
-        nsp_names = context.namespaces.keys()
-        nsp_names.sort()        
-        return [ context.namespaces[nsp] for nsp in nsp_names ]
-    getNamespaces = staticmethod(getNamespaces)
-
-    def getHolder(holder_name):
-        holder = plnamespace.getHolder(holder_name)
-        if holder is None:
-            holder = actualContext(plargs).binders.get(holder_name)
-        return holder
-    getHolder = staticmethod(getHolder)
-
-    def parse(*args):
-        &quot;&quot;&quot;Parses a list of argument strings.&quot;&quot;&quot;
-        if len(args)==1 and isinstance(args[0], list):
-            args = args[0]
-
-        context = actualContext(plargs)
-        for statement in args:
-            assert isinstance(statement, str), statement
-
-            option, value = statement.split('=', 1)
-
-            option = option.strip()
-            value  = value.strip()
-
-            if option==&quot;expdir&quot;:
-                context._expdir_ = value
-                continue
-
-            if option==&quot;expdir_root&quot;:
-                context._expdir_root_ = value
-                continue            
-
-            try:
-                holder_name, option = option.split('.')
-                holder = plargs.getHolder(holder_name)
-
-            # option.split('.') did not return a pair, i.e. not dot in option
-            except ValueError:
-                holder_name, holder = None, plopt.getHolder(option)
-
-            # Was the holder for that option defined?
-            if holder is None:
-                plopt.addCmdLineOverride(holder_name, option, value)
-            else:
-                setattr(holder, option, value)
-    parse = staticmethod(parse)
-    
-    #######  Metaclass  ###########################################################
-    
-    class __metaclass__(type):
-        &quot;&quot;&quot;Overrides the attribute management behavior.&quot;&quot;&quot;
-        def __new__(metacls, clsname, bases, dic):
-            cls = type.__new__(metacls, clsname, bases, dic)
-            plargs = cls
-            if clsname != &quot;plargs&quot;:
-                plargs = globals()['plargs']
-
-            context = actualContext(plargs)
-    
-            # Keep track of binder subclass
-            if clsname != &quot;plargs&quot;:
-                context.binders[clsname] = cls
-
-            # Introspection of the subclasses
-            if cls is not plargs:
-                for option, value in dic.iteritems():                    
-                    if neglected_member(option, value):
-                        continue
-                    
-                    # Define the plopt instance
-                    plopt.define(cls, option, value)
-
-            return cls
-
-        def __setattr__(cls, option, value):
-            if option == &quot;expdir&quot;:
-                raise AttributeError(&quot;Cannot modify the value of 'expdir'.&quot;)
-
-            plargs = cls
-            if cls.__name__ != &quot;plargs&quot;:
-                plargs = globals()['plargs']
-
-            context = actualContext(plargs)
-            if cls is plargs:
-                raise AttributeError(
-                    &quot;Can't set option '%s' directly on plargs. &quot;
-                    &quot;Proceed trough the binder or namespace.&quot; % option)
-
-            try:                    
-                plopt.override(cls, option, value)
-            except AttributeError, err:
-                if cls._extensible_:
-                    plopt.define(cls, option, value)
-                else:
-                    raise AttributeError(
-                        &quot;Binder %s does not contain a plopt instance named %s. &quot;
-                        &quot;One can't set a value to an undefined option. (%s)&quot;
-                        %(cls.__name__, option, err))
-
-        def __getattribute__(cls, key):
-            attr = None
-            try:
-                attr = type.__getattribute__(cls, key)
-                if key.startswith('_') or not isinstance(attr, plopt):
-                    return type.__getattribute__(cls, key)
-            except AttributeError:
-                pass
-
-            # The key should map to a plopt instance, we need the context...
-            plargs = cls
-            if cls.__name__ != &quot;plargs&quot;:
-                plargs = globals()['plargs']
-
-            # Special management of expdir plarg
-            if key == &quot;expdir&quot;:
-                return actualContext(plargs).getExpdir()
-            elif key == &quot;expdir_root&quot;:
-                return actualContext(plargs).getExpdirRoot()
-
-            # Find to holder to which option belongs
-            holder = cls
-            if cls is plargs:
-                try:
-                    holder = actualContext(plargs).plopt_binders[key]
-                except KeyError:
-                    raise AttributeError(&quot;Unknown option '%s'. Is it namespaced?&quot;%key)
-
-            # We now have a valid holder: dig out the plopt *value*
-            plopt_instance = type.__getattribute__(holder, key)
-            assert isinstance(plopt_instance, plopt)
-            return plopt_instance.get()
-
-# For backward compatibility
-class _plarg_defaults:
-    &quot;&quot;&quot;Magic class to L{contextualize&lt;context&gt;} I{plarg_defaults}.
-
-    The I{plarg_defaults} object exists mainly for backward compatibility
-    reasons. It was (is) meant to store a default value for some command
-    argument so that::
-
-        plarg_defaults.algo = &quot;classical&quot;
-        print plargs.algo
-
-    would print &quot;classical&quot; even if no command line argument I{algo} is encountered.
-
-    For clarity sakes, we suggest that one now regroup all default values
-    he wishes to set for &quot;plargs&quot; in some L{binder&lt;plargs&gt;}, e.g.::
-
-        class Misc(plargs):
-            algo      = &quot;classical&quot;
-            n_inputs  = 10
-            n_outputs = 2
-
-        print plargs.algo
-
-    The behavior will be the same, but this syntax allows to I{highlight}
-    the definition of default values while being more aligned with the new
-    generation of U{plargs}.
-    &quot;&quot;&quot;
-    def _getBinder(self):
-        binders = actualContext(plargs).binders
-        if 'plarg_defaults' not in binders:
-            binders['plarg_defaults'] = \
-                new.classobj('plarg_defaults', (plargs,), {'_extensible_' : True})
-        return binders['plarg_defaults']
-
-    def __getattribute__(self, option):
-        return getattr(self._getBinder(), option)
-
-    def __setattr__(self, option, value):
-        defaults = self._getBinder()
-
-        # Say the default was value of a given was set to 'D'. It, the
-        # *default* value, can well be set modified later to 'E'. But we
-        # want this to modify the script behaviour IFF the option's value
-        # was *not* overriden from the command line. A simple call to
-        # 'setattr' would discard the command-line override!
-        if hasattr(defaults, option):
-            attr_plopt = object.__getattribute__(defaults,option)
-            attr_plopt.setDefault(value)
-            return
-
-        setattr(defaults, option, value)
-plarg_defaults = _plarg_defaults()
-        
-class plnamespace:
-    &quot;&quot;&quot;Avoiding name clashes for L{plargs}.
-
-    Alike binders, L{plnamespace} subclasses allow one to define the value
-    of expected L{plargs}, but plarg names are encapsulated in namespaces. This
-    allows many options to have the same name, as long as they are not in
-    the same namespace::
-
-        # 
-        # namespaced.pyplearn
-        #
-        from plearn.pyplearn.plargs import *
-        
-        class macd(plnamespace):
-            ma_len = plopt(252,
-                        doc=&quot;The moving average length to be used in the macd model.&quot;)
-
-        class PCA(plnamespace):
-            algo      = &quot;classical&quot;
-            ma_len    = plopt([126, 252],
-                              doc=&quot;A list of moving average lenghts to be used &quot;
-                              &quot;during the preprocessing.&quot;)
-            n_inputs  = plopt(10, doc=&quot;The number of inputs to be used.&quot;)
-
-        print &gt;&gt;sys.stderr, macd.ma_len, PCA.algo, PCA.ma_len
-
-        try:
-            print &gt;&gt;sys.stderr, plargs.n_inputs
-        except AttributeError:
-            print &gt;&gt;sys.stderr, \
-                  &quot;n_inputs is namespaced, you must access it through 'PCA'&quot;
-
-        #####
-        prompt %&gt; plearn namespaced.pyplearn macd.ma_len=126 PCA.algo=weird
-        252 weird [126, 252]
-        n_inputs is namespaced, you must access it through 'PCA'
-    &quot;&quot;&quot;    
-    def buildClassContext(context):
-        assert not hasattr(context, 'namespaces')
-        context.namespaces = {}
-    buildClassContext = staticmethod(buildClassContext)
-
-    def getHolder(holder_name):
-        return actualContext(plnamespace).namespaces.get(holder_name)
-    getHolder = staticmethod(getHolder)
-
-    def getPlopt(cls, optname):
-        return super(cls, cls).__getattribute__(cls, optname)
-    getPlopt = classmethod(getPlopt)
-
-    def inherit(namespace):
-        &quot;&quot;&quot;A deep-copy driven inheritance-like mechanism.
-
-        In the context of plnamespace, usual (Python) inheritance is not
-        satisfactory. Indeed, the options defined in some base class will be
-        shared among subclasses. However, when one would want to subclass a
-        plnamespace, it is more likely the he want the 'subclass' to have
-        options 'of the same name' than the ones in the base-class but
-        still independent.
-
-        This method provide a concise way to enact this inheritance-like
-        relationship between some New and some Existing namespaces
-
-            class New(plnamespace):
-                __metaclass__ = plnamespace.inherit(Existing)
-
-                other_option  = plopt(&quot;Other&quot;,
-                                      doc=&quot;An option that is not in the base class.&quot;)
-
-        Note that if 'Existing.some_option=VALUE' is overriden through the command-line,
-        the value of 'New.some_option' will be VALUE unless explicitely overrode. 
-        &quot;&quot;&quot;
-        META = namespace.__metaclass__
-        class __metaclass__(META):
-            def __new__(metacls, clsname, bases, dic):
-                # Do not use plopt.optdict: the documentation, choices and other
-                # property would be lost...
-                for opt in plopt.iterator(namespace):
-                    if not opt.getName() in dic:
-                        inh_opt = copy.deepcopy(opt)
-                        inh_opt.set( opt.get() )
-                        dic[inh_opt.getName()] = inh_opt
-                    
-                #OLD: optdict = dict([ (
-                #OLD:     opt.getName(), opt) for opt in plopt.iterator(namespace) ])
-                #OLD: dic.update( copy.deepcopy(optdict) )
-                cls = META.__new__(metacls, clsname, bases, dic)
-                return cls        
-        return __metaclass__
-    inherit = staticmethod(inherit)
-        
-    class __metaclass__(type):
-        def __new__(metacls, clsname, bases, dic):
-            cls = type.__new__(metacls, clsname, bases, dic)
-            if clsname != &quot;plnamespace&quot;:
-                context = actualContext(globals()[&quot;plnamespace&quot;])
-                context.namespaces[clsname] = cls
-
-                for option, value in dic.iteritems():
-                    if neglected_member(option, value):
-                        continue
-                    # Define the plopt instance
-                    plopt.define(cls, option, value)
-            return cls
-
-        def __getattribute__(cls, key):
-            if key.startswith('_'):
-                return type.__getattribute__(cls, key)
-
-            attr = type.__getattribute__(cls, key)
-            try:
-                plopt_instance = attr
-                assert isinstance(plopt_instance, plopt)
-                return plopt_instance.get()
-            except AssertionError:
-                assert inspect.ismethod(attr) or inspect.isfunction(attr)
-                return attr
-
-        def __setattr__(cls, key, value):
-            if key.startswith('_') \
-               or (hasattr(cls, key) and callable(getattr(cls,key))):
-                type.__setattr__(cls,key,value)
-            else:
-                try:
-                    plopt.override(cls, key, value)
-                except AttributeError:
-                    raise AttributeError(
-                        &quot;Namespace %s does not contain a plopt instance named %s. &quot;
-                        &quot;One can't set a value to an undefined option.&quot;%(cls.__name__, key))
-
-class _TmpHolder:
-    def __init__(self, holder_name):
-        self._name = holder_name
-
-    def checkConsistency(self, holder):
-        from plearn.pyplearn import PyPLearnError
-        if self._name is None:
-            assert not issubclass(holder, plnamespace)
-        else:
-            assert holder.__name__ == self._name
-
-# class _TmpHolderMap(dict):
-#     def __getitem__(self, key):
-#         if not key in self:
-#             self.__setitem__(key, [])
-#         return super(ListMap, self).__getitem__(key)
-    
-
-#######  For backward compatibily: will be deprecated soon  ###################
-
-class plargs_binder(plargs):
-    class __metaclass__(plargs.__metaclass__):
-        def __new__(metacls, clsname, bases, dic):            
-            if clsname==&quot;plargs_binder&quot;:
-                return type.__new__(metacls, clsname, bases, dic)
-            warn(&quot;plargs_binder is deprecated. Inherit directly from plargs instead.&quot;,
-                 DeprecationWarning)
-            return plargs.__metaclass__.__new__(metacls, clsname, bases, dic)
-
-class plargs_namespace(plnamespace):
-    class __metaclass__(plnamespace.__metaclass__):
-        def __new__(metacls, clsname, bases, dic):
-            if clsname==&quot;plargs_namespace&quot;:
-                return type.__new__(metacls, clsname, bases, dic)
-            warn(&quot;plargs_namespace is deprecated. Inherit from plnamespace instead.&quot;,
-                 DeprecationWarning)
-            return plnamespace.__metaclass__.__new__(metacls, clsname, bases, dic)
-
-
-#######  Unit Tests: invoked from outside  #####################################
-
-def printCurrentContext(out=sys.stdout):
-    print &gt;&gt;out, &quot;Expdir:&quot;, plargs.expdir
-    
-    for binder in plargs.getBinders():
-        print &gt;&gt;out, &quot;Binder:&quot;, binder.__name__
-        for opt in plopt.iterator(binder):
-            print &gt;&gt;out, '   ',opt.getName()+':', opt
-        print &gt;&gt;out, ''
-    
-    for namespace in plargs.getNamespaces():
-        print &gt;&gt;out, &quot;Namespace:&quot;, namespace.__name__
-        for opt in plopt.iterator(namespace):
-            print &gt;&gt;out, '   ',opt.getName()+':', opt
-
-def test_plargs():                
-    print &quot;#######  Binders  #############################################################\n&quot;
-    class binder(plargs):
-        c = &quot;c&quot;
-        d = &quot;d&quot;
-        e = &quot;e&quot;
-        f = &quot;f&quot;
-
-    def bCheck(attr):
-        plargs_attr = getattr(plargs, attr)
-        binder_attr = getattr(binder, attr)
-        assert not isinstance(binder_attr, plopt)
-
-        print &quot;Access through plargs:&quot;, plargs_attr        
-        print &quot;Direct access:&quot;, binder_attr
-        assert plargs_attr==binder_attr
-
-        # binder_plopt = binder.getPlopt(attr)
-        # print &quot;Access to plopt:&quot;, &quot;TO BE DONE&quot; # binder_plopt
-        print 
-        
-
-    ### Untouched
-    print &quot;+++ Untouched plarg\n&quot;
-    bCheck('c')
-
-    ### Standard assignment
-    print &quot;+++ Standard assignment through binder\n&quot;
-    binder.d = &quot;Youppi&quot;
-    bCheck('d')
-
-    ### Subclass propagation
-    print &quot;+++ Setting binded option using 'dotted' key\n&quot;
-    plargs.parse(&quot;binder.e = ** E **&quot;)
-    bCheck('e')
-
-    print &quot;#######  Namespaces  ##########################################################\n&quot;
-    class n(plnamespace):    
-        namespaced = &quot;within namespace n&quot;
-
-    def nCheck():
-        assert not isinstance(n.namespaced, plopt)
-        print &quot;Direct access:&quot;, n.namespaced
-
-        # n_plopt = n.getPlopt('namespaced')
-        # print &quot;Access to plopt:&quot;, &quot;TO BE DONE&quot; # n_plopt
-        print 
-
-    ### Untouched
-    nCheck()
-    
-    ### Standard assignments
-    print &quot;+++ Standard assignment through namespace\n&quot;
-    n.namespaced = &quot;WITHIN NAMESPACE n&quot;
-    nCheck()
-    
-    ### Subclass propagation
-    plargs.parse(&quot;n.namespaced=FROM_SETATTR&quot;)
-    nCheck()    
-
-    print &quot;#######  Contexts Management  #################################################\n&quot;
-
-    print &quot;+++ Context 1&quot;
-    first_context = getCurrentContext()
-    printCurrentContext()
-    print 
-
-    print &quot;+++ Context 2&quot;        
-    second_context = createNewContext()
-    plarg_defaults.algo = &quot;classical&quot;
-
-    print &quot;-- Before creation of the new 'n' plnamespace:&quot;
-    print n.namespaced
-    printCurrentContext()
-    print
-    
-    class n(plnamespace):
-        namespaced = &quot;NEW NAMESPACED ATTR&quot;
-
-    print &quot;-- After creation of the new 'n' plnamespace:&quot;
-    print n.namespaced
-    printCurrentContext()
-    print
-
-
-    print &quot;+++ Back to Context 1&quot;
-    setCurrentContext(first_context)
-    printCurrentContext()
-    print 
-
-def test_plargs_parsing():
-    def readScript(*command_line):
-        context_handle = createNewContext()
-        
-        plargs.parse(*command_line)
-
-        class MyBinder(plargs):
-            binded1 = &quot;binded1&quot;
-            binded2 = &quot;binded2&quot;
-            binded3 = &quot;binded3&quot;
-
-        class MyNamespace(plnamespace):
-            namespaced1 = &quot;namespaced1&quot;
-            namespaced2 = &quot;namespaced2&quot;
-            namespaced3 = &quot;namespaced3&quot;
-
-        header = &quot;Context %d&quot;%context_handle
-        header += '\n'+(&quot;=&quot;*len(header))
-        print header
-        printCurrentContext()
-        print        
-        return context_handle, header
-    
-    contexts = [ readScript() ]
-    contexts.append(
-        # list argument
-        readScript([&quot;binded1=BINDED1&quot;, &quot;binded2=BINDED2&quot;,
-                    &quot;MyNamespace.namespaced3=NAMESPACED3&quot;]) )
-    contexts.append(
-          # string arguments
-          readScript(&quot;binded3=BINDED3&quot;, &quot;MyNamespace.namespaced1=NAMESPACED1&quot;) )
-
-    print 
-    print &quot;Reprint all contexts to ensure nothing was lost or corrupted.&quot;
-    print &quot;-------------------------------------------------------------&quot;
-    print 
-    for c, header in contexts:
-        setCurrentContext(c)
-        print header
-        printCurrentContext()
-        closeCurrentContext()
-        print 
-
-    print 
-    print &quot;Misspelled command-line argument&quot;
-    print &quot;-------------------------------------------------------------&quot;
-    print
-    from plearn.pyplearn import PyPLearnError
-    try:
-        readScript([&quot;bindd1=BINDED1&quot;, &quot;binded2=BINDED2&quot;,
-                    &quot;MyNamespace.namespaced3=NAMESPACED3&quot;])
-        closeCurrentContext()        
-    except PyPLearnError, err:
-        print 
-        print 'PyPLearnError:', err
-
-
-def test_mandatory_plargs(*command_line):
-    from plearn.pyplearn import PyPLearnError
-    plargs.parse(*command_line)
-
-    try:
-        class MyBinder(plargs):
-            mandatory = mandatory_plopt(int,
-                                        doc=&quot;Some mandatory int command line argument&quot;)
-        
-        print MyBinder.mandatory
-
-    except PyPLearnError, err:
-        print err
-
-def test_misspelled_plargs():
-    from plearn.pyplearn import PyPLearnError
-
-    plargs.parse(&quot;binded1=[]&quot;, &quot;binded2=[ 2 ]&quot;, &quot;namespace='misspelled'&quot;)
-
-    class Binder(plargs):
-        binded1 = [ 1 ]
-        binded2 = plopt([], elem_type=int)
-
-    class Namespace(plnamespace):
-        namespaced = &quot;N&quot;
-
-    print Binder.binded1, Binder.binded2, Namespace.namespaced
-
-    from plearn.pyplearn import PyPLearnError
-    try:
-        closeCurrentContext()
-    except PyPLearnError, err:
-        print err

Copied: tags/finlearn3-august2007/python_modules/plearn/pyplearn/plargs.py (from rev 7939, trunk/python_modules/plearn/pyplearn/plargs.py)


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001397.html">[Plearn-commits] r7949 - trunk/python_modules/plearn/parallel
</A></li>
	<LI>Next message: <A HREF="001399.html">[Plearn-commits] r7951 - trunk/plearn_learners/online
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1398">[ date ]</a>
              <a href="thread.html#1398">[ thread ]</a>
              <a href="subject.html#1398">[ subject ]</a>
              <a href="author.html#1398">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/plearn-commits">More information about the Plearn-commits
mailing list</a><br>
</body></html>
