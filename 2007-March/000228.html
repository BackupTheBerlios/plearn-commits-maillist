<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Plearn-commits] r6779 - trunk/plearn/math
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/plearn-commits/2007-March/index.html" >
   <LINK REL="made" HREF="mailto:plearn-commits%40lists.berlios.de?Subject=Re%3A%20%5BPlearn-commits%5D%20r6779%20-%20trunk/plearn/math&In-Reply-To=%3C200703231909.l2NJ9aPj024733%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000227.html">
   <LINK REL="Next"  HREF="000229.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Plearn-commits] r6779 - trunk/plearn/math</H1>
    <B>chapados at BerliOS</B> 
    <A HREF="mailto:plearn-commits%40lists.berlios.de?Subject=Re%3A%20%5BPlearn-commits%5D%20r6779%20-%20trunk/plearn/math&In-Reply-To=%3C200703231909.l2NJ9aPj024733%40sheep.berlios.de%3E"
       TITLE="[Plearn-commits] r6779 - trunk/plearn/math">chapados at mail.berlios.de
       </A><BR>
    <I>Fri Mar 23 20:09:36 CET 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000227.html">[Plearn-commits] r6778 - trunk/doc
</A></li>
        <LI>Next message: <A HREF="000229.html">[Plearn-commits] r6780 - trunk/plearn/math
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#228">[ date ]</a>
              <a href="thread.html#228">[ thread ]</a>
              <a href="subject.html#228">[ subject ]</a>
              <a href="author.html#228">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: chapados
Date: 2007-03-23 20:09:36 +0100 (Fri, 23 Mar 2007)
New Revision: 6779

Modified:
   trunk/plearn/math/TMat_maths_impl.h
Log:
Systematically guard against calls to .data() on an empty vector/matrix ; fixed most code up to line 2342

Modified: trunk/plearn/math/TMat_maths_impl.h
===================================================================
--- trunk/plearn/math/TMat_maths_impl.h	2007-03-21 20:12:26 UTC (rev 6778)
+++ trunk/plearn/math/TMat_maths_impl.h	2007-03-23 19:09:36 UTC (rev 6779)
@@ -48,6 +48,7 @@
 #define TMat_maths_impl_H
 
 #include &lt;algorithm&gt;
+#include &lt;limits&gt;
 
 namespace PLearn {
 using namespace std;
@@ -58,15 +59,16 @@
     int len = vec.length();
 
     TVec&lt;T&gt; sign_( len );
-    T*  v   = vec.data();
-    T*  s   = sign_.data();
-
-    while(--len &gt;= 0)
-    {
-        *s = sign( *v );
-        v++; s++; 
+    if (len &gt; 0) {
+        T*  v   = vec.data();
+        T*  s   = sign_.data();
+        
+        while(--len &gt;= 0)
+        {
+            *s = sign( *v );
+            v++; s++; 
+        }
     }
-  
     return sign_;
 }
 
@@ -74,12 +76,14 @@
 void compute_sign(const TVec&lt;T&gt;&amp; vec, const TVec&lt;T&gt;&amp; dest)
 {
     int len = vec.length();
-    T*  v   = vec.data();
-    T*  s   = dest.data();
-    while(--len &gt;= 0)
-    {
-        *s = sign( *v );
-        v++; s++; 
+    if (len &gt; 0) {
+        T*  v   = vec.data();
+        T*  s   = dest.data();
+        while(--len &gt;= 0)
+        {
+            *s = sign( *v );
+            v++; s++; 
+        }
     }
 }
 
@@ -110,15 +114,17 @@
                                 const int target)
 {
     int N = output.length();
-    T*  o = output.data();
     T total_hinge_loss = 0;
-    while(--N &gt;= 0)
-    {
-        if (N==target)
-            total_hinge_loss += hinge_loss(*o,1);
-        else
-            total_hinge_loss += hinge_loss(*o,-1);
-        o++;
+    if (N &gt; 0) {
+        T*  o = output.data();
+        while(--N &gt;= 0)
+        {
+            if (N==target)
+                total_hinge_loss += hinge_loss(*o,1);
+            else
+                total_hinge_loss += hinge_loss(*o,-1);
+            o++;
+        }
     }
     return total_hinge_loss;
 }
@@ -134,46 +140,30 @@
 {
     int N = output.length();
     d_output.resize(N);
-    T*  o = output.data();
-    T*  d_o = d_output.data();
-    //MNT old buggy code (opposite numbering of outputs):
-    /*while(--N &gt;= 0)
-      {
-      if (N==target)
-      *d_o = d_hinge_loss(*o,1);
-      else
-      *d_o = d_hinge_loss(*o,-1);
-      o++; d_o++;
-      }
-    */
-    for( int i = 0; i &lt; N; i++ ) {
-        if ( i == target )
-            *d_o = d_hinge_loss( *o, 1 );
-        else
-            *d_o = d_hinge_loss( *o, -1 );
-        o++; d_o++;
+    if (N &gt; 0) {
+        T*  o = output.data();
+        T*  d_o = d_output.data();
+        //MNT old buggy code (opposite numbering of outputs):
+        /*while(--N &gt;= 0)
+          {
+          if (N==target)
+          *d_o = d_hinge_loss(*o,1);
+          else
+          *d_o = d_hinge_loss(*o,-1);
+          o++; d_o++;
+          }
+        */
+        for( int i = 0; i &lt; N; i++ ) {
+            if ( i == target )
+                *d_o = d_hinge_loss( *o, 1 );
+            else
+                *d_o = d_hinge_loss( *o, -1 );
+            o++;
+            d_o++;
+        }
     }
 }
 
-template &lt;class T&gt; 
-T max(const TVec&lt;T&gt;&amp; vec)
-{
-#ifdef BOUNDCHECK
-    if(vec.length()==0)
-        PLERROR(&quot;IN max(const NumericVec&amp; vec) TVec has zero length()&quot;);
-#endif
-    T* pv = vec.data();
-    T maxval = *pv++;
-    int n = vec.length();
-    while(--n)
-    {
-        if(*pv&gt;maxval)
-            maxval = *pv;
-        ++pv;
-    }
-    return maxval;
-}
-
 //! y = softmax(x)
 template &lt;class T&gt;
 void softmax(const TVec&lt;T&gt;&amp; x, const TVec&lt;T&gt;&amp; y)
@@ -364,6 +354,8 @@
 {
     T moy = mean(avg);
     int n=avg.length();
+    if (!n)
+        return;
     T* a = avg.data();
     if (scale==T(1))
         for (int i=0;i&lt;n;i++)
@@ -564,6 +556,8 @@
 #endif
     double res = 0.0;
     int n = 0;
+    if (vec.size() == 0)
+        return MISSING_VALUE;
     T* v = vec.data();
     for(int i=0; i&lt;vec.length(); i++)
         if (!is_missing(v[i]))
@@ -586,6 +580,8 @@
     if(vec.length()==0)
         PLERROR(&quot;IN T geometric_mean(const TVec&lt;T&gt;&amp; vec) vec has zero length&quot;);
 #endif
+    if (vec.size() == 0)
+        return MISSING_VALUE;
     double res = 0.0;
     T* v = vec.data();
     for(int i=0; i&lt;vec.length(); i++)
@@ -606,6 +602,8 @@
     if(vec.length()!=weights.length() || vec.length() == 0)
         PLERROR(&quot;IN T weighted_mean(const TVec&lt;T&gt;&amp; vec, const TVec&lt;T&gt;&amp; weights) vec and weights must have equal (non-zero) lengths&quot;);
 #endif
+    if (vec.size() == 0)
+        return MISSING_VALUE;
     double res = 0.0;
     T sum_weights = 0.0;
     T* v = vec.data();
@@ -633,6 +631,8 @@
     if(vec.length()&lt;=1)
         PLERROR(&quot;IN T variance(const TVec&lt;T&gt;&amp; vec, T meanval) vec length must be more than one&quot;);
 #endif
+    if (vec.size() == 0)
+        return MISSING_VALUE;
     double res = 0.0;
     T* v = vec.data();
     int n = 0;
@@ -661,9 +661,11 @@
         PLERROR(&quot;IN T covariance(const TVec&lt;T&gt;&amp; vec1, const TVec&lt;T&gt;&amp; vec2, T mean1, T mean2) vec1's length must be more than one&quot;);
     if(vec2.length()&lt;=1)
         PLERROR(&quot;IN T covariance(const TVec&lt;T&gt;&amp; vec1, const TVec&lt;T&gt;&amp; vec2, T mean1, T mean2) vec2's length must be more than one&quot;);
-#endif
     if(vec1.length() != vec2.length())
         PLERROR(&quot;IN T covariance(const TVec&lt;T&gt;&amp; vec1, const TVec&lt;T&gt;&amp; vec2, T mean1, T mean2) the lengths of vec1 and vec2 must be same&quot;);
+#endif
+    if (vec1.size() == 0 || vec2.size() == 0)
+        return MISSING_VALUE;
     int length = vec1.length();
     double res = 0.0;
     T* v1 = vec1.data();
@@ -683,6 +685,8 @@
     if(vec.length()!=weights.length() || vec.length()==0)
         PLERROR(&quot;IN T weighted_variance(const TVec&lt;T&gt;&amp; vec, const TVec&lt;T&gt;&amp; weights, T no_weighted_mean, T weighted_mean) vec and weights must have equal (non-zero) lengths&quot;);
 #endif
+    if (vec.size() == 0)
+        return MISSING_VALUE;
     double res = 0.0;
     T* v = vec.data();
     T* w = weights.data();
@@ -710,6 +714,27 @@
 }
 
 
+template &lt;class T&gt; 
+T max(const TVec&lt;T&gt;&amp; vec)
+{
+#ifdef BOUNDCHECK
+    if(vec.length()==0)
+        PLERROR(&quot;IN max(const NumericVec&amp; vec) TVec has zero length()&quot;);
+#endif
+    int n = vec.length();
+    if (!n)
+        return std::numeric_limits&lt;T&gt;::min();
+    T* pv = vec.data();
+    T maxval = *pv++;
+    while(--n)
+    {
+        if(*pv&gt;maxval)
+            maxval = *pv;
+        ++pv;
+    }
+    return maxval;
+}
+
 template&lt;class T&gt;
 T min(const TVec&lt;T&gt;&amp; vec)
 {
@@ -717,6 +742,8 @@
     if(vec.length()==0)
         PLERROR(&quot;IN T min(const TVec&lt;T&gt;&amp; vec) vec has zero length&quot;);
 #endif
+    if (vec.size() == 0)
+        return std::numeric_limits&lt;T&gt;::max();
     T* v = vec.data();
     T minval = v[0];
     for(int i=1; i&lt;vec.length(); i++)
@@ -732,6 +759,8 @@
     if(vec.length()==0)
         PLERROR(&quot;IN T maxabs(const TVec&lt;T&gt;&amp; vec) vec has zero length&quot;);
 #endif
+    if (vec.size() == 0)
+        return std::numeric_limits&lt;T&gt;::min();
     T* v = vec.data();
     T maxval = fabs(v[0]);
     for(int i=1; i&lt;vec.length(); i++)
@@ -743,24 +772,6 @@
     return maxval;
 }
 
-// template&lt;class T&gt;
-// T minabs(const TVec&lt;T&gt;&amp; vec)
-// {
-//   #ifdef BOUNDCHECK
-//   if(vec.length()==0)
-//     PLERROR(&quot;IN T minabs(const TVec&lt;T&gt;&amp; vec) vec has zero length&quot;);
-//   #endif
-//   T* v = vec.data();
-//   T minval = fabs(v[0]);
-//   for(int i=1; i&lt;vec.length(); i++)
-//     {
-//       T a=fabs(v[i]);
-//       if(a&lt;minval)
-//         minval = a;
-//     }
-//   return minval;
-// }
-
 template&lt;class T&gt;
 T minabs(const TVec&lt;T&gt;&amp; vec, int index = int())
 {
@@ -768,6 +779,8 @@
     if(vec.length()==0)
         PLERROR(&quot;IN T minabs(const TVec&lt;T&gt;&amp; vec) vec has zero length&quot;);
 #endif
+    if (vec.size() == 0)
+        return std::numeric_limits&lt;T&gt;::max();
     T* v = vec.data();
     T minval = fabs(v[0]);
     for(int i=1; i&lt;vec.length(); i++)
@@ -889,6 +902,8 @@
 T pownorm(const TVec&lt;T&gt;&amp; vec, double n)
 {
     double result = 0.0;
+    if (vec.size() == 0)
+        return result;
     T* v = vec.data();
     if(n==1.0)
     {
@@ -1023,37 +1038,39 @@
         PLERROR(&quot;In weighted_powdistance: vec1, vec2 and weights vector should have the same length&quot;);
 #endif
     T result = 0.0;
-    T* v1 = vec1.data();
-    T* v2 = vec2.data();
-    T* w = weights.data();
-    int length = vec1.length();
-    if(n==1.0) // L1 distance
-    {
-        for(int i=0; i&lt;length; i++)
+    if (vec1.size() &gt; 0 &amp;&amp; vec2.size() &gt; 0 &amp;&amp; weights.size() &gt; 0) {
+        T* v1 = vec1.data();
+        T* v2 = vec2.data();
+        T* w = weights.data();
+        int length = vec1.length();
+        if(n==1.0) // L1 distance
         {
-            T diff = w[i]*(v1[i]-v2[i]);
-            if(diff&gt;=0)
-                result += diff;
-            else
-                result -= diff;
+            for(int i=0; i&lt;length; i++)
+            {
+                T diff = w[i]*(v1[i]-v2[i]);
+                if(diff&gt;=0)
+                    result += diff;
+                else
+                    result -= diff;
+            }
         }
-    }
-    else if(n==2.0)
-    {
-        for(int i=0; i&lt;length; i++)
+        else if(n==2.0)
         {
-            T diff = w[i]*(v1[i]-v2[i]);
-            result += diff*diff;
+            for(int i=0; i&lt;length; i++)
+            {
+                T diff = w[i]*(v1[i]-v2[i]);
+                result += diff*diff;
+            }
         }
-    }
-    else
-    {
-        for(int i=0; i&lt;length; i++)
+        else
         {
-            T diff = w[i]*(v1[i]-v2[i]);
-            if(diff&lt;0)
-                diff = -diff;
-            result += mypow(diff,n);
+            for(int i=0; i&lt;length; i++)
+            {
+                T diff = w[i]*(v1[i]-v2[i]);
+                if(diff&lt;0)
+                    diff = -diff;
+                result += mypow(diff,n);
+            }
         }
     }
     return result;
@@ -1071,25 +1088,107 @@
 }
 
 
+//!  element-wise +
 template&lt;class T&gt;
+inline void operator+=(const TVec&lt;T&gt;&amp; vec1, const TVec&lt;T&gt;&amp; vec2)
+{
+#ifdef BOUNDCHECK
+    if(vec1.size() != vec2.size())
+        PLERROR(&quot;In operator+=, vec1 and vec2 vectors must have the same length&quot;);
+#endif
+    if (vec1.size() &gt; 0 &amp;&amp; vec2.size() &gt; 0) {
+        T* v1 = vec1.data();
+        T* v2 = vec2.data();
+        int l = vec1.length();
+        for(int i=0; i&lt;l; i++)
+            *v1++ += *v2++;
+    }
+}
+
+template&lt;class T&gt;
+void operator+=(const TVec&lt;T&gt;&amp; vec, T scalar)
+{
+    if (vec.size() &gt; 0) {
+        T* v = vec.data();
+        for(int i=0; i&lt;vec.length(); i++)
+            v[i] += scalar;
+    }
+}
+
+template&lt;class T&gt;
+TVec&lt;T&gt; operator-(const TVec&lt;T&gt;&amp; vec)
+{
+    if (vec.size() &gt; 0) {
+        TVec&lt;T&gt; opposite(vec.length());
+        T *v=vec.data();
+        T *o=opposite.data();
+        for (int i=0;i&lt;vec.length();i++)
+            o[i] = - v[i];
+        return opposite;
+    }
+}
+
+template&lt;class T&gt;
 void operator-=(const TVec&lt;T&gt;&amp; vec1, const TVec&lt;T&gt;&amp; vec2)
 {
-    T* v1 = vec1.data();
-    T* v2 = vec2.data();
-    for(int i=0; i&lt;vec1.length(); i++)
-        v1[i] -= v2[i];
+#ifdef BOUNDCHECK
+    if(vec1.size() != vec2.size())
+        PLERROR(&quot;In operator-=, vec1 and vec2 vectors must have the same length&quot;);
+#endif
+    if (vec1.size() &gt; 0 &amp;&amp; vec2.size() &gt; 0) {
+        T* v1 = vec1.data();
+        T* v2 = vec2.data();
+        for(int i=0; i&lt;vec1.length(); i++)
+            v1[i] -= v2[i];
+    }
 }
 
 template&lt;class T&gt;
+void operator-=(const TVec&lt;T&gt;&amp; vec, T scalar)
+{ vec += -scalar; }
+
+template&lt;class T&gt;
 void operator*=(const TVec&lt;T&gt;&amp; vec1, const TVec&lt;T&gt;&amp; vec2)
 {
-    T* v1 = vec1.data();
-    T* v2 = vec2.data();
-    for(int i=0; i&lt;vec1.length(); i++)
-        v1[i] *= v2[i];
+#ifdef BOUNDCHECK
+    if(vec1.size() != vec2.size())
+        PLERROR(&quot;In operator*=, vec1 and vec2 vectors must have the same length&quot;);
+#endif
+    if (vec1.size() &gt; 0 &amp;&amp; vec2.size() &gt; 0) {
+        T* v1 = vec1.data();
+        T* v2 = vec2.data();
+        for(int i=0; i&lt;vec1.length(); i++)
+            v1[i] *= v2[i];
+    }
 }
 
 template&lt;class T&gt;
+void operator*=(const TVec&lt;T&gt;&amp; vec, T factor)
+{
+    if (vec.size() &gt; 0) {
+        T* p = vec.data();
+        int l = vec.length();
+        for (int i=0;i&lt;l;i++) 
+            *p++ *= factor;
+    }
+}
+
+template&lt;class T&gt;
+void operator/=(const TVec&lt;T&gt;&amp; vec1, const TVec&lt;T&gt;&amp; vec2)
+{
+#ifdef BOUNDCHECK
+    if(vec1.size() != vec2.size())
+        PLERROR(&quot;In operator/=, vec1 and vec2 vectors must have the same length&quot;);
+#endif
+    if (vec1.size() &gt; 0 &amp;&amp; vec2.size() &gt; 0) {
+        T* v1 = vec1.data();
+        T* v2 = vec2.data();
+        for(int i=0; i&lt;vec1.length(); i++)
+            v1[i] /= v2[i];
+    }
+}
+
+template&lt;class T&gt;
 inline void operator/=(const TVec&lt;T&gt;&amp; vec, T scalar) 
 { vec *= T(1.0)/scalar; }
 
@@ -1104,11 +1203,13 @@
     if(src.length()!=dest.length())
         PLERROR(&quot;In log, src and dest vectors must have the same length&quot;);
 #endif
-    T* ps = src.data();
-    T* pd = dest.data();
-    int n = src.length();
-    for(int i=0; i&lt;n; i++)
-        *pd++ = pl_log(*ps++);
+    if (sec.size() &gt; 0 &amp;&amp; dest.size() &gt; 0) {
+        T* ps = src.data();
+        T* pd = dest.data();
+        int n = src.length();
+        for(int i=0; i&lt;n; i++)
+            *pd++ = pl_log(*ps++);
+    }
 }
 
 template&lt;class T&gt;
@@ -1122,11 +1223,13 @@
     if(src.length()!=dest.length())
         PLERROR(&quot;In sqrt, src and dest vectors must have the same length&quot;);
 #endif
-    T* ps = src.data();
-    T* pd = dest.data();
-    int n = src.length();
-    for(int i=0; i&lt;n; i++)
-        *pd++ = sqrt(*ps++);
+    if (src.size() &gt; 0 &amp;&amp; dest.size() &gt; 0) {
+        T* ps = src.data();
+        T* pd = dest.data();
+        int n = src.length();
+        for(int i=0; i&lt;n; i++)
+            *pd++ = sqrt(*ps++);
+    }
 }
 
 template&lt;class T&gt;
@@ -1140,11 +1243,13 @@
     if(src.length()!=dest.length())
         PLERROR(&quot;In safelog, src and dest vectors must have the same length&quot;);
 #endif
-    T* ps = src.data();
-    T* pd = dest.data();
-    int n = src.length();
-    for(int i=0; i&lt;n; i++)
-        *pd++ = safelog(*ps++);
+    if (src.size() &gt; 0 &amp;&amp; dest.size() &gt; 0) {
+        T* ps = src.data();
+        T* pd = dest.data();
+        int n = src.length();
+        for(int i=0; i&lt;n; i++)
+            *pd++ = safelog(*ps++);
+    }
 }
 
 template&lt;class T&gt;
@@ -1152,26 +1257,19 @@
 { TVec&lt;T&gt; dest(src.length()); compute_safelog(src,dest); return dest; }
 
 template&lt;class T&gt;
-void operator/=(const TVec&lt;T&gt;&amp; vec1, const TVec&lt;T&gt;&amp; vec2)
-{
-    T* v1 = vec1.data();
-    T* v2 = vec2.data();
-    for(int i=0; i&lt;vec1.length(); i++)
-        v1[i] /= v2[i];
-}
-
-template&lt;class T&gt;
 void compute_tanh(const TVec&lt;T&gt;&amp; src, const TVec&lt;T&gt;&amp; dest)
 {
 #ifdef BOUNDCHECK
     if(src.length()!=dest.length())
         PLERROR(&quot;In tanh, src and dest vectors must have the same length&quot;);
 #endif
-    T* ps = src.data();
-    T* pd = dest.data();
-    int n = src.length();
-    for(int i=0; i&lt;n; i++)
-        *pd++ = tanh(*ps++);
+    if (src.size() &gt; 0 &amp;&amp; dest.size() &gt; 0) {
+        T* ps = src.data();
+        T* pd = dest.data();
+        int n = src.length();
+        for(int i=0; i&lt;n; i++)
+            *pd++ = tanh(*ps++);
+    }
 }
 
 template&lt;class T&gt;
@@ -1181,15 +1279,17 @@
     if(tanh_x.length()!=d_tanh_x.length())
         PLERROR(&quot;In bprop_tanh, src and dest vectors must have the same length&quot;);
 #endif
-    int n = tanh_x.length();
-    if (n != d_x.length()) d_x.resize(n);
-    T* y = tanh_x.data();
-    T* dy = d_tanh_x.data();
-    T* dx = d_x.data();
-    for(int i=0; i&lt;n; i++)
-    {
-        real yi = *y++;
-        *dx++ = *dy++ * (1 - yi*yi);
+    if (tanh_x.size() &gt; 0 &amp;&amp; d_tanh_x.size() &gt; 0 &amp;&amp; d_x.size() &gt; 0) {
+        int n = tanh_x.length();
+        if (n != d_x.length()) d_x.resize(n);
+        T* y = tanh_x.data();
+        T* dy = d_tanh_x.data();
+        T* dx = d_x.data();
+        for(int i=0; i&lt;n; i++)
+        {
+            real yi = *y++;
+            *dx++ = *dy++ * (1 - yi*yi);
+        }
     }
 }
 
@@ -1205,11 +1305,13 @@
     if(src.length()!=dest.length())
         PLERROR(&quot;In fasttanh, src and dest vectors must have the same length&quot;);
 #endif
-    T* ps = src.data();
-    T* pd = dest.data();
-    int n = src.length();
-    for(int i=0; i&lt;n; i++)
-        *pd++ = fasttanh(*ps++);
+    if (src.size() &gt; 0 &amp;&amp; dest.size() &gt; 0) {
+        T* ps = src.data();
+        T* pd = dest.data();
+        int n = src.length();
+        for(int i=0; i&lt;n; i++)
+            *pd++ = fasttanh(*ps++);
+    }
 }
 
 template&lt;class T&gt;
@@ -1223,11 +1325,13 @@
     if(src.length()!=dest.length())
         PLERROR(&quot;In sigmoid, src and dest vectors must have the same length&quot;);
 #endif
-    T* ps = src.data();
-    T* pd = dest.data();
-    int n = src.length();
-    for(int i=0; i&lt;n; i++)
-        *pd++ = sigmoid(*ps++);
+    if (src.size() &gt; 0 &amp;&amp; dest.size() &gt; 0) {
+        T* ps = src.data();
+        T* pd = dest.data();
+        int n = src.length();
+        for(int i=0; i&lt;n; i++)
+            *pd++ = sigmoid(*ps++);
+    }
 }
 
 template&lt;class T&gt;
@@ -1237,11 +1341,13 @@
     if(src.length()!=dest.length())
         PLERROR(&quot;In sigmoid, src and dest vectors must have the same length&quot;);
 #endif
-    T* ps = src.data();
-    T* pd = dest.data();
-    int n = src.length();
-    for(int i=0; i&lt;n; i++)
-        *pd++ = log_sigmoid(*ps++);
+    if (src.size() &gt; 0 &amp;&amp; dest.size() &gt; 0) {
+        T* ps = src.data();
+        T* pd = dest.data();
+        int n = src.length();
+        for(int i=0; i&lt;n; i++)
+            *pd++ = log_sigmoid(*ps++);
+    }
 }
 
 template&lt;class T&gt;
@@ -1256,11 +1362,13 @@
     if(src.length()!=dest.length())
         PLERROR(&quot;In fastsigmoid, src and dest vectors must have the same length&quot;);
 #endif
-    T* ps = src.data();
-    T* pd = dest.data();
-    int n = src.length();
-    for(int i=0; i&lt;n; i++)
-        *pd++ = fastsigmoid(*ps++);
+    if (src.size() &gt; 0 &amp;&amp; dest.size() &gt; 0) {
+        T* ps = src.data();
+        T* pd = dest.data();
+        int n = src.length();
+        for(int i=0; i&lt;n; i++)
+            *pd++ = fastsigmoid(*ps++);
+    }
 }
 
 template&lt;class T&gt;
@@ -1274,11 +1382,13 @@
     if(src.length()!=dest.length())
         PLERROR(&quot;In inverse_sigmoid, src and dest vectors must have the same length&quot;);
 #endif
-    T* ps = src.data();
-    T* pd = dest.data();
-    int n = src.length();
-    for(int i=0; i&lt;n; i++)
-        *pd++ = inverse_sigmoid(*ps++);
+    if (src.size() &gt; 0 &amp;&amp; dest.size() &gt; 0) {
+        T* ps = src.data();
+        T* pd = dest.data();
+        int n = src.length();
+        for(int i=0; i&lt;n; i++)
+            *pd++ = inverse_sigmoid(*ps++);
+    }
 }
 
 template&lt;class T&gt;
@@ -1289,66 +1399,50 @@
 template&lt;class T&gt;
 void negateElements(const TVec&lt;T&gt;&amp; vec)
 {
-    T* v = vec.data();
-    for(int i=0; i&lt;vec.length(); i++)
-        v[i] = -v[i];
+    if (vec.size() &gt; 0) {
+        T* v = vec.data();
+        for(int i=0; i&lt;vec.length(); i++)
+            v[i] = -v[i];
+    }
 }
 
 template&lt;class T&gt;
 void invertElements(const TVec&lt;T&gt;&amp; vec)
 {
-    T* v = vec.data();
-    for(int i=0; i&lt;vec.length(); i++)
-        v[i] = 1.0/v[i];
+    if (vec.size() &gt; 0) {
+        T* v = vec.data();
+        for(int i=0; i&lt;vec.length(); i++)
+            v[i] = 1.0/v[i];
+    }
 }
 
 template&lt;class T&gt;
 TVec&lt;T&gt; inverted(const TVec&lt;T&gt;&amp; vec)
 {
     TVec&lt;T&gt; ret(vec.length());
-    T* v = vec.data();
-    for(int i=0; i&lt;vec.length(); i++)
-        ret[i] = 1.0/v[i];
+    if (vec.size() &gt; 0) {
+        T* v = vec.data();
+        for(int i=0; i&lt;vec.length(); i++)
+            ret[i] = 1.0/v[i];
+    }
     return ret;
 }
 
 
 template&lt;class T&gt;
-void operator+=(const TVec&lt;T&gt;&amp; vec, T scalar)
-{
-    T* v = vec.data();
-    for(int i=0; i&lt;vec.length(); i++)
-        v[i] += scalar;
-}
-
-template&lt;class T&gt;
-void operator-=(const TVec&lt;T&gt;&amp; vec, T scalar)
-{ vec += -scalar; }
-
-template&lt;class T&gt;
-TVec&lt;T&gt; operator-(TVec&lt;T&gt; vec)
-{
-    TVec&lt;T&gt; opposite(vec.length());
-    T *v=vec.data();
-    T *o=opposite.data();
-    for (int i=0;i&lt;vec.length();i++)
-        o[i] = - v[i];
-    return opposite;
-}
-
-template&lt;class T&gt;
 T dot(const TVec&lt;T&gt;&amp; vec1, const TVec&lt;T&gt;&amp; vec2)
 {
 #ifdef BOUNDCHECK
     if(vec1.length()!=vec2.length())
         PLERROR(&quot;In T operator*(const TVec&lt;T&gt;&amp; vec1, const TVec&lt;T&gt;&amp; vec2) (dot product) the 2 vecs must have the same length.&quot;);
 #endif
-
     T res = 0;
-    T* v1 = vec1.data();
-    T* v2 = vec2.data();
-    for(int i=0; i&lt;vec1.length(); i++)
-        res += v1[i]*v2[i];
+    if (vec1.size() &gt; 0 &amp;&amp; vec2.size() &gt; 0) {
+        T* v1 = vec1.data();
+        T* v2 = vec2.data();
+        for(int i=0; i&lt;vec1.length(); i++)
+            res += v1[i]*v2[i];
+    }
     return res;
 }
 
@@ -1364,12 +1458,13 @@
     if(vec1.length()!=vec2.length())
         PLERROR(&quot;In T operator*(const TVec&lt;T&gt;&amp; vec1, const TVec&lt;T&gt;&amp; vec2) (dot product) the 2 vecs must have the same length.&quot;);
 #endif
-
     V res = 0;
-    T* v1 = vec1.data();
-    U* v2 = vec2.data();
-    for(int i=0; i&lt;vec1.length(); i++)
-        res += v1[i]*v2[i];
+    if (vec1.size() &gt; 0 &amp;&amp; vec2.size() &gt; 0) {
+        T* v1 = vec1.data();
+        U* v2 = vec2.data();
+        for(int i=0; i&lt;vec1.length(); i++)
+            res += v1[i]*v2[i];
+    }
     return res;
 }
 
@@ -1382,17 +1477,19 @@
 #endif
 
     T res = 0;
-    T* v1 = m1.data();
-    T* v2 = m2.data();
-    if (m1.isCompact() &amp;&amp; m2.isCompact())
-        for(int i=0; i&lt;m1.size(); i++)
-            res += v1[i]*v2[i];
-    else
-    {
-        TMatElementIterator&lt;T&gt; p1 = m1.begin();
-        TMatElementIterator&lt;T&gt; p2 = m2.begin();
-        for (int i=0; i&lt;m1.size(); i++,++p1,++p2)
-            res += *p1 * *p2;
+    if (m1.size() &gt; 0 &amp;&amp; m2.size() &gt; 0) {
+        T* v1 = m1.data();
+        T* v2 = m2.data();
+        if (m1.isCompact() &amp;&amp; m2.isCompact())
+            for(int i=0; i&lt;m1.size(); i++)
+                res += v1[i]*v2[i];
+        else
+        {
+            TMatElementIterator&lt;T&gt; p1 = m1.begin();
+            TMatElementIterator&lt;T&gt; p2 = m2.begin();
+            for (int i=0; i&lt;m1.size(); i++,++p1,++p2)
+                res += *p1 * *p2;
+        }
     }
     return res;
 }
@@ -1499,10 +1596,12 @@
 {
     int n=v2.length();
     TVec&lt;T&gt; v(n);
-    T* s2=v2.data();
-    T* d=v.data();
-    for (int i=0;i&lt;n;i++)
-        d[i] = v1/s2[i];
+    if (v2.size() &gt; 0) {
+        T* s2=v2.data();
+        T* d=v.data();
+        for (int i=0;i&lt;n;i++)
+            d[i] = v1/s2[i];
+    }
     return v;
 }
 
@@ -1595,11 +1694,17 @@
 template&lt;class T&gt;
 void square(TVec&lt;T&gt;&amp; result, const TVec&lt;T&gt;&amp; vec)
 {
+#ifdef BOUNDCHECK
+    if (result.size() != vec.size())
+        PLERROR(&quot;In square, 'result' and 'vec' must have the same size&quot;);
+#endif
     int n = vec.length();
-    T* v = vec.data();
-    T* r = result.data();
-    for(int i=0; i&lt;n; i++)
-        r[i] = v[i]*v[i];
+    if (n &gt; 0) {
+        T* v = vec.data();
+        T* r = result.data();
+        for(int i=0; i&lt;n; i++)
+            r[i] = v[i]*v[i];
+    }
 }
 
 template&lt;class T&gt;
@@ -1607,10 +1712,12 @@
 {
     int n = vec.length();
     TVec&lt;T&gt; result(n);
-    T* v = vec.data();
-    T* r = result.data();
-    for(int i=0; i&lt;n; i++)
+    if (n &gt; 0) {
+        T* v = vec.data();
+        T* r = result.data();
+        for(int i=0; i&lt;n; i++)
         r[i] = sqrt(v[i]);
+    }
     return result;
 }
 
@@ -1620,13 +1727,15 @@
     int n = vec.length();
     int n_non_missing = 0;
     TVec&lt;T&gt; result(n);
-    T* v = vec.data();
-    T* r = result.data();
-    for(int i=0; i&lt;n; i++) {
-        if (!is_missing(v[i]))
-            r[n_non_missing++] = v[i];
+    if (n &gt; 0) {
+        T* v = vec.data();
+        T* r = result.data();
+        for(int i=0; i&lt;n; i++) {
+            if (!is_missing(v[i]))
+                r[n_non_missing++] = v[i];
+        }
+        result.resize(n_non_missing);
     }
-    result.resize(n_non_missing);
     return result;
 }
 
@@ -1648,10 +1757,12 @@
     if (n!=destination.length())
         PLERROR(&quot;apply: source(%d) and destination(%d) TVec&lt;T&gt;'s must have same length&quot;,
                 n,destination.length());
-    T* s = source.data();
-    U* d = destination.data();
-    for(int i=0; i&lt;n; i++)
-        d[i]=func(s[i]);
+    if (n &gt; 0) {
+        T* s = source.data();
+        U* d = destination.data();
+        for(int i=0; i&lt;n; i++)
+            d[i]=func(s[i]);
+    }
 }
 
 //! Transform a vector of T and a vector of U into a vector of V,
@@ -1663,11 +1774,13 @@
     int n=src1.length();
     if (n!=dest.length() || n!=src2.length())
         PLERROR(&quot;apply: src1, src2 and destination TVec&lt;T&gt;'s must have same length&quot;);
-    T* s1 = src1.data();
-    U* s2 = src2.data();
-    V* d = dest.data();
-    for(int i=0; i&lt;n; i++)
-        d[i]=func(s1[i],s2[i]);
+    if (n &gt; 0) {
+        T* s1 = src1.data();
+        U* s2 = src2.data();
+        V* d = dest.data();
+        for(int i=0; i&lt;n; i++)
+            d[i]=func(s1[i],s2[i]);
+    }
 }
 
 
@@ -1683,11 +1796,13 @@
                 n,source2.length());
     if (n!=destination.length())
         destination.resize(n);
-    T* s1=source1.data();
-    T* s2=source2.data();
-    T* d=destination.data();
-    for (int i=0;i&lt;n;i++)
-        d[i] = s1[i]*s2[i];
+    if (n &gt; 0) {
+        T* s1=source1.data();
+        T* s2=source2.data();
+        T* d=destination.data();
+        for (int i=0;i&lt;n;i++)
+            d[i] = s1[i]*s2[i];
+    }
 }
 
 // destination[i] = source1[i] + source2[i]*source3
@@ -1701,11 +1816,13 @@
                 n,source2.length());
     if (n!=destination.length())
         destination.resize(n);
-    T* s1=source1.data();
-    T* s2=source2.data();
-    T* d=destination.data();
-    for (int i=0;i&lt;n;i++)
-        d[i] = s1[i]+s2[i]*source3;
+    if (n &gt; 0) {
+        T* s1=source1.data();
+        T* s2=source2.data();
+        T* d=destination.data();
+        for (int i=0;i&lt;n;i++)
+            d[i] = s1[i]+s2[i]*source3;
+    }
 }
 
 // destination[i] = a*destination[i] + b*source[i]
@@ -1716,10 +1833,12 @@
     if (n!=destination.length())
         PLERROR(&quot;multiply: source and destination (l=%d and %d) must have same length&quot;,
                 n,destination.length());
-    T* s=source.data();
-    T* d=destination.data();
-    for (int i=0;i&lt;n;i++)
-        d[i] = a*d[i] + b*s[i];
+    if (n &gt; 0) {
+        T* s=source.data();
+        T* d=destination.data();
+        for (int i=0;i&lt;n;i++)
+            d[i] = a*d[i] + b*s[i];
+    }
 }
 
 // destination[i] = source1[i]+source2[i]
@@ -1732,11 +1851,13 @@
                 n,source2.length());
     if (n!=destination.length())
         destination.resize(n);
-    T* s1=source1.data();
-    T* s2=source2.data();
-    T* d=destination.data();
-    for (int i=0;i&lt;n;i++)
-        d[i] = s1[i]+s2[i];
+    if (n &gt; 0) {
+        T* s1=source1.data();
+        T* s2=source2.data();
+        T* d=destination.data();
+        for (int i=0;i&lt;n;i++)
+            d[i] = s1[i]+s2[i];
+    }
 }
 
 // destination[i] = source1[i]+source2
@@ -1746,10 +1867,12 @@
     int n=source1.length();
     if (n!=destination.length())
         destination.resize(n);
-    T* s1=source1.data();
-    T* d=destination.data();
-    for (int i=0;i&lt;n;i++)
-        d[i] = s1[i]+source2;
+    if (n &gt; 0) {
+        T* s1=source1.data();
+        T* d=destination.data();
+        for (int i=0;i&lt;n;i++)
+            d[i] = s1[i]+source2;
+    }
 }
 
 template&lt;class T&gt;
@@ -1766,11 +1889,13 @@
                 n,source2.length());
     if (n!=destination.length())
         destination.resize(n);
-    T* s1=source1.data();
-    T* s2=source2.data();
-    T* d=destination.data();
-    for (int i=0;i&lt;n;i++)
-        d[i] = s1[i]-s2[i];
+    if (n &gt; 0) {
+        T* s1=source1.data();
+        T* s2=source2.data();
+        T* d=destination.data();
+        for (int i=0;i&lt;n;i++)
+            d[i] = s1[i]-s2[i];
+    }
 }
 
 // destination[i] += source1[i]-source2[i]
@@ -1783,11 +1908,13 @@
                 n,source2.length());
     if (n!=destination.length())
         destination.resize(n);
-    T* s1=source1.data();
-    T* s2=source2.data();
-    T* d=destination.data();
-    for (int i=0;i&lt;n;i++)
-        d[i] += s1[i]-s2[i];
+    if (n &gt; 0) {
+        T* s1=source1.data();
+        T* s2=source2.data();
+        T* d=destination.data();
+        for (int i=0;i&lt;n;i++)
+            d[i] += s1[i]-s2[i];
+    }
 }
 
 // destination[i] = source1-source2[i]
@@ -1797,10 +1924,12 @@
   int n=source2.length();
   if (n!=destination.length())
     destination.resize(n);
-  T* s2=source2.data();
-  T* d=destination.data();
-  for (int i=0;i&lt;n;i++)
-    d[i] = source1-s2[i];
+  if (n &gt; 0) {
+      T* s2=source2.data();
+      T* d=destination.data();
+      for (int i=0;i&lt;n;i++)
+          d[i] = source1-s2[i];
+  }
 }
 
 template&lt;class T&gt;
@@ -1817,11 +1946,13 @@
                 n,source2.length());
     if (n!=destination.length())
         destination.resize(n);
-    T* s1=source1.data();
-    T* s2=source2.data();
-    T* d=destination.data();
-    for (int i=0;i&lt;n;i++)
-        d[i] = s1[i]/s2[i];
+    if (n &gt; 0) {
+        T* s1=source1.data();
+        T* s2=source2.data();
+        T* d=destination.data();
+        for (int i=0;i&lt;n;i++)
+            d[i] = s1[i]/s2[i];
+    }
 }
 
 // destination[i] = source1/source2[i]
@@ -1831,10 +1962,12 @@
     int n=source2.length();
     if (n!=destination.length())
         destination.resize(n);
-    T* s2=source2.data();
-    T* d=destination.data();
-    for (int i=0;i&lt;n;i++)
-        d[i] = source1/s2[i];
+    if (n &gt; 0) {
+        T* s2=source2.data();
+        T* d=destination.data();
+        for (int i=0;i&lt;n;i++)
+            d[i] = source1/s2[i];
+    }
 }
 
 // destination[i] = max(source1[i],source2[i])
@@ -1847,11 +1980,13 @@
                 n,source2.length());
     if (n!=destination.length())
         destination.resize(n);
-    T* s1=source1.data();
-    T* s2=source2.data();
-    T* d=destination.data();
-    for (int i=0;i&lt;n;i++)
-        d[i] = MAX(s1[i],s2[i]);
+    if (n &gt; 0) {
+        T* s1=source1.data();
+        T* s2=source2.data();
+        T* d=destination.data();
+        for (int i=0;i&lt;n;i++)
+            d[i] = MAX(s1[i],s2[i]);
+    }
 }
 
 // destination[i] = max(source1[i],source2)
@@ -1861,10 +1996,12 @@
     int n=source1.length();
     if (n!=destination.length())
         destination.resize(n);
-    T* s1=source1.data();
-    T* d=destination.data();
-    for (int i=0;i&lt;n;i++)
-        d[i] = MAX(s1[i],source2);
+    if (n &gt; 0) {
+        T* s1=source1.data();
+        T* d=destination.data();
+        for (int i=0;i&lt;n;i++)
+            d[i] = MAX(s1[i],source2);
+    }
 }
 
 
@@ -1878,11 +2015,13 @@
                 n,source2.length());
     if (n!=destination.length())
         destination.resize(n);
-    T* s1=source1.data();
-    T* s2=source2.data();
-    T* d=destination.data();
-    for (int i=0;i&lt;n;i++)
-        d[i] = MIN(s1[i],s2[i]);
+    if (n &gt; 0) {
+        T* s1=source1.data();
+        T* s2=source2.data();
+        T* d=destination.data();
+        for (int i=0;i&lt;n;i++)
+            d[i] = MIN(s1[i],s2[i]);
+    }
 }
 
 // destination[i] = min(source1[i],source2)
@@ -1892,10 +2031,12 @@
     int n=source1.length();
     if (n!=destination.length())
         destination.resize(n);
-    T* s1=source1.data();
-    T* d=destination.data();
-    for (int i=0;i&lt;n;i++)
-        d[i] = MIN(s1[i],source2);
+    if (n &gt; 0) {
+        T* s1=source1.data();
+        T* d=destination.data();
+        for (int i=0;i&lt;n;i++)
+            d[i] = MIN(s1[i],source2);
+    }
 }
 
 
@@ -1939,6 +2080,8 @@
 TVec&lt;T&gt; nonZeroIndices(TVec&lt;T&gt; v)
 {
     int n=v.length();
+    if (!n)
+        return TVec&lt;T&gt;();
     TVec&lt;T&gt; indices(n);
     int ni=0;
     T* val = v.data();
@@ -1955,6 +2098,8 @@
 TVec&lt;T&gt; nonZeroIndices(TVec&lt;bool&gt; v)
 {
     int n=v.length();
+    if (!n)
+        return TVec&lt;T&gt;();
     TVec&lt;T&gt; indices(n);
     int ni=0;
     bool* val = v.data();
@@ -1990,92 +2135,105 @@
 template&lt;class T&gt;
 void equals(const TVec&lt;T&gt;&amp; src, T v, TVec&lt;T&gt;&amp; dest)
 {
-    T* s=src.data();
-    T* d=dest.data();
     int n=src.length();
 #ifdef BOUNDCHECK
     if (n!=dest.length())
         PLERROR(&quot;equals(TVec&lt;T&gt;(%d),T,TVec&lt;T&gt;(%d)) args of unequal lengths&quot;,
                 n,dest.length());
 #endif
-    for (int i=0;i&lt;n;i++)
-        if (s[i]==v) d[i]=1.0; else d[i]=0.0;
+    if (n &gt; 0) {
+        T* s=src.data();
+        T* d=dest.data();
+        for (int i=0;i&lt;n;i++)
+            if (s[i]==v) d[i]=1.0; else d[i]=0.0;
+    }
 }
 
 // dest[i] = 1 if first[i] &gt; second[i], 0 otherwise
 template&lt;class T&gt;
 void isLargerThan(const TVec&lt;T&gt;&amp; first, const TVec&lt;T&gt;&amp; second, TVec&lt;T&gt;&amp; dest)
 {
-    T* f=first.data();
-    T* s=second.data();
-    T* d=dest.data();
     int n=first.length();
     if(n!=second.length() || n!=dest.length())
         PLERROR(&quot;isLargerThan(TVec&lt;T&gt;(%d), TVec&lt;T&gt;(%d), TVec&lt;T&gt;(%d)) args of unequal length&quot;, 
                 n, second.length(), dest.length());
-    for (int i=0; i&lt;n; i++)
-        d[i] = f[i] &gt; s[i];
+    if (n &gt; 0) {
+        T* f=first.data();
+        T* s=second.data();
+        T* d=dest.data();
+        for (int i=0; i&lt;n; i++)
+            d[i] = f[i] &gt; s[i];
+    }
 }
 
 // dest[i] = 1 if first[i] &gt;= second[i], 0 otherwise
 template&lt;class T&gt;
 void isLargerThanOrEqualTo(const TVec&lt;T&gt;&amp; first, const TVec&lt;T&gt;&amp; second, TVec&lt;T&gt;&amp; dest)
 {
-    T* f=first.data();
-    T* s=second.data();
-    T* d=dest.data();
     int n=first.length();
     if(n!=second.length() || n!=dest.length())
         PLERROR(&quot;isLargerThan(TVec&lt;T&gt;(%d), TVec&lt;T&gt;(%d), TVec&lt;T&gt;(%d)) args of unequal length&quot;, 
                 n, second.length(), dest.length());
-    for (int i=0; i&lt;n; i++)
-        d[i] = f[i] &gt;= s[i];
+    if (n &gt; 0) {
+        T* f=first.data();
+        T* s=second.data();
+        T* d=dest.data();
+        for (int i=0; i&lt;n; i++)
+            d[i] = f[i] &gt;= s[i];
+    }
 }
 
 // dest[i] = 1 if first[i] &lt; second[i], 0 otherwise
 template&lt;class T&gt;
 void isSmallerThan(const TVec&lt;T&gt;&amp; first, const TVec&lt;T&gt;&amp; second, TVec&lt;T&gt;&amp; dest)
 {
-    T* f=first.data();
-    T* s=second.data();
-    T* d=dest.data();
     int n=first.length();
     if(n!=second.length() || n!=dest.length())
         PLERROR(&quot;isLargerThan(TVec&lt;T&gt;(%d), TVec&lt;T&gt;(%d), TVec&lt;T&gt;(%d)) args of unequal length&quot;, 
                 n, second.length(), dest.length());
-    for (int i=0; i&lt;n; i++)
-        d[i] = f[i] &lt; s[i];
+    if (n &gt; 0) {
+        T* f=first.data();
+        T* s=second.data();
+        T* d=dest.data();
+        for (int i=0; i&lt;n; i++)
+            d[i] = f[i] &lt; s[i];
+    }
 }
   
 // dest[i] = 1 if first[i] &lt;= second[i], 0 otherwise
 template&lt;class T&gt;
 void isSmallerThanOrEqualTo(const TVec&lt;T&gt;&amp; first, const TVec&lt;T&gt;&amp; second, TVec&lt;T&gt;&amp; dest)
 {
-    T* f=first.data();
-    T* s=second.data();
-    T* d=dest.data();
     int n=first.length();
     if(n!=second.length() || n!=dest.length())
         PLERROR(&quot;isLargerThan(TVec&lt;T&gt;(%d), TVec&lt;T&gt;(%d), TVec&lt;T&gt;(%d)) args of unequal length&quot;, 
                 n, second.length(), dest.length());
-    for (int i=0; i&lt;n; i++)
-        d[i] = f[i] &lt;= s[i];
+    if (n &gt; 0) {
+        T* f=first.data();
+        T* s=second.data();
+        T* d=dest.data();
+        for (int i=0; i&lt;n; i++)
+            d[i] = f[i] &lt;= s[i];
+    }
 }
 
 // dest[i] = if_vec[i] ? then_vec[i] : else_vec[i];
 template&lt;class T&gt;
-void ifThenElse(const TVec&lt;T&gt;&amp; if_vec, const TVec&lt;T&gt;&amp; then_vec, const TVec&lt;T&gt;&amp; else_vec, TVec&lt;T&gt;&amp; dest)
+void ifThenElse(const TVec&lt;T&gt;&amp; if_vec, const TVec&lt;T&gt;&amp; then_vec,
+                const TVec&lt;T&gt;&amp; else_vec, TVec&lt;T&gt;&amp; dest)
 {
-    T* i_=if_vec.data();
-    T* t_=then_vec.data();
-    T* e_=else_vec.data();
-    T* d_=dest.data();  
     int n=if_vec.length(); 
-    if (n!=then_vec.length() || n!=else_vec.length())
+    if (n!=then_vec.length() || n!=else_vec.length() || n!=dest_vec.length())
         PLERROR(&quot;ifThenElse(TVec&lt;T&gt;(%d), TVec&lt;T&gt;(%d), TVec&lt;T&gt;(%d), TVec&lt;T&gt;(%d)) args of unequal lengths&quot;, 
                 n, then_vec.length(), else_vec.length(), dest.length());
-    for (int i=0;i&lt;n;i++)
-        d_[i] = i_[i] ? t_[i] : e_[i];
+    if (n &gt; 0) {
+        T* i_=if_vec.data();
+        T* t_=then_vec.data();
+        T* e_=else_vec.data();
+        T* d_=dest.data();  
+        for (int i=0;i&lt;n;i++)
+            d_[i] = i_[i] ? t_[i] : e_[i];
+    }
 }
 
 // returns the number of times that src[i] == value
@@ -2084,10 +2242,12 @@
 {
     int len = src.length();
     int n = 0;
-    T *p = src.data();
-    for (int i=0; i&lt;len; i++, p++)
-        if (*p == value)
-            n++;
+    if (len &gt; 0) {
+        T *p = src.data();
+        for (int i=0; i&lt;len; i++, p++)
+            if (*p == value)
+                n++;
+    }
     return n;
 }
 
@@ -2096,10 +2256,12 @@
 int vec_find(const TVec&lt;T&gt;&amp; src, T f)
 {
     int len = src.length();
-    T *p = src.data();
-    for (int i=0; i&lt;len; i++, p++)
-        if (*p == f)
-            return(i);
+    if (len &gt; 0) {
+        T *p = src.data();
+        for (int i=0; i&lt;len; i++, p++)
+            if (*p == f)
+                return(i);
+    }
     return -1;
 }
 
@@ -2313,27 +2475,7 @@
     }
 }
 
-template&lt;class T&gt;
-void operator*=(const TVec&lt;T&gt;&amp; vec, T factor)
-{
-    T* p = vec.data();
-    int l = vec.length();
-    for (int i=0;i&lt;l;i++) 
-        *p++ *= factor;
-}
 
-//!  element-wise +
-template&lt;class T&gt;
-inline void operator+=(const TVec&lt;T&gt;&amp; vec1, const TVec&lt;T&gt;&amp; vec2)
-{
-    T* v1 = vec1.data();
-    T* v2 = vec2.data();
-    int l = vec1.length();
-    for(int i=0; i&lt;l; i++)
-        *v1++ += *v2++;
-}
-
-
 //!  vec[i] += x[i]*scale;
 template&lt;class T&gt;
 void multiplyAcc(const TVec&lt;T&gt;&amp; vec, const TVec&lt;T&gt;&amp; x, T scale)


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000227.html">[Plearn-commits] r6778 - trunk/doc
</A></li>
	<LI>Next message: <A HREF="000229.html">[Plearn-commits] r6780 - trunk/plearn/math
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#228">[ date ]</a>
              <a href="thread.html#228">[ thread ]</a>
              <a href="subject.html#228">[ subject ]</a>
              <a href="author.html#228">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/plearn-commits">More information about the Plearn-commits
mailing list</a><br>
</body></html>
