<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Plearn-commits] r6723 - in trunk: plearn/base plearn/io	plearn/math plearn/misc plearn_learners/generic	plearn_learners/testers python_modules/plearn/pymake
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/plearn-commits/2007-March/index.html" >
   <LINK REL="made" HREF="mailto:plearn-commits%40lists.berlios.de?Subject=Re%3A%20%5BPlearn-commits%5D%20r6723%20-%20in%20trunk%3A%20plearn/base%20plearn/io%0A%09plearn/math%20plearn/misc%20plearn_learners/generic%0A%09plearn_learners/testers%20python_modules/plearn/pymake&In-Reply-To=%3C200703090031.l290V9Tl002326%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000171.html">
   <LINK REL="Next"  HREF="000173.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Plearn-commits] r6723 - in trunk: plearn/base plearn/io	plearn/math plearn/misc plearn_learners/generic	plearn_learners/testers python_modules/plearn/pymake</H1>
    <B>saintmlx at BerliOS</B> 
    <A HREF="mailto:plearn-commits%40lists.berlios.de?Subject=Re%3A%20%5BPlearn-commits%5D%20r6723%20-%20in%20trunk%3A%20plearn/base%20plearn/io%0A%09plearn/math%20plearn/misc%20plearn_learners/generic%0A%09plearn_learners/testers%20python_modules/plearn/pymake&In-Reply-To=%3C200703090031.l290V9Tl002326%40sheep.berlios.de%3E"
       TITLE="[Plearn-commits] r6723 - in trunk: plearn/base plearn/io	plearn/math plearn/misc plearn_learners/generic	plearn_learners/testers python_modules/plearn/pymake">saintmlx at mail.berlios.de
       </A><BR>
    <I>Fri Mar  9 01:31:09 CET 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000171.html">[Plearn-commits] r6722 - trunk/plearn/io
</A></li>
        <LI>Next message: <A HREF="000173.html">[Plearn-commits] r6724 - in	trunk/plearn/math/test/VecStatsCollector/.pytest/PL_constant_regressor_script/expected_results/expdir:	. Split0 Split0/test1_confidence.pmat.metadata	Split0/test1_costs.pmat.metadata	Split0/test1_outputs.pmat.metadata global_stats.pmat.metadata	split_stats.pmat.metadata
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#172">[ date ]</a>
              <a href="thread.html#172">[ thread ]</a>
              <a href="subject.html#172">[ subject ]</a>
              <a href="author.html#172">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: saintmlx
Date: 2007-03-09 01:31:06 +0100 (Fri, 09 Mar 2007)
New Revision: 6723

Modified:
   trunk/plearn/base/CopiesMap.h
   trunk/plearn/base/Object.cc
   trunk/plearn/base/tuple.h
   trunk/plearn/io/PStream.h
   trunk/plearn/math/ObservationWindow.cc
   trunk/plearn/math/ObservationWindow.h
   trunk/plearn/math/StatsCollector.cc
   trunk/plearn/math/StatsCollector.h
   trunk/plearn/math/TMat_decl.h
   trunk/plearn/math/VecStatsCollector.cc
   trunk/plearn/math/VecStatsCollector.h
   trunk/plearn/misc/PLearnServer.cc
   trunk/plearn/misc/PLearnService.cc
   trunk/plearn/misc/RemotePLearnServer.cc
   trunk/plearn/misc/RemotePLearnServer.h
   trunk/plearn_learners/generic/NNet.cc
   trunk/plearn_learners/generic/PLearner.cc
   trunk/plearn_learners/generic/PLearner.h
   trunk/plearn_learners/generic/VPLPreprocessedLearner2.cc
   trunk/plearn_learners/generic/VPLPreprocessedLearner2.h
   trunk/plearn_learners/testers/PTester.cc
   trunk/python_modules/plearn/pymake/pymake.py
Log:
- parallelized PLearner::test (with [Remote]PLearnServ{er|ice})
- PStream: skipBlanks[AndComments[...]] ONLY BEFORE READING, NOT AFTER! (please!)
- added possibility to merge [Vec]StatsCollector[Counts] (todo: observation windows)
- don't try to access storage of an empty TMat
- ObservationWindow is now an Object
- added object map to RemotePLearnServer
- added deepCopyField for tuples (up to 6 elts.)
- ... and a few minor changes here and there



Modified: trunk/plearn/base/CopiesMap.h
===================================================================
--- trunk/plearn/base/CopiesMap.h	2007-03-07 21:12:26 UTC (rev 6722)
+++ trunk/plearn/base/CopiesMap.h	2007-03-09 00:31:06 UTC (rev 6723)
@@ -46,6 +46,7 @@
 #include &lt;utility&gt;      //!&lt; For pair.
 #include &quot;plerror.h&quot;    //!&lt; For PLWARNING.
 
+
 //! Macro to define deep copy for types that actually do not require
 //! any deep copy (such as int, real, etc.).
 //! Since the copy constructor of an array does copy the content of
@@ -201,8 +202,6 @@
         deepCopyField(*it, copies);
 }
 
-
-
 //#####  Fallbacks  ###########################################################
 
 //!  Any type not handled below: do nothing

Modified: trunk/plearn/base/Object.cc
===================================================================
--- trunk/plearn/base/Object.cc	2007-03-07 21:12:26 UTC (rev 6722)
+++ trunk/plearn/base/Object.cc	2007-03-09 00:31:06 UTC (rev 6723)
@@ -791,37 +791,44 @@
         in.get(); // Eat '*'
         unsigned int id;
         in &gt;&gt; id;
-        in.skipBlanksAndCommentsAndSeparators();
+        //don't skip blanks before we need to read something else (read might block).
+        //in.skipBlanksAndCommentsAndSeparators();
         if (id==0)
             x = 0;
-        else if (in.peek() == '-') 
+        else
         {
-            in.get(); // Eat '-'
-            char cc = in.get();
-            if(cc != '&gt;') // Eat '&gt;'
-                PLERROR(&quot;In PStream::operator&gt;&gt;(Object*&amp;)  Wrong format. &quot;
-                        &quot;Expecting \&quot;*%d-&gt;\&quot; but got \&quot;*%d-%c\&quot;.&quot;, id, id, cc);
-            in.skipBlanksAndCommentsAndSeparators();
-            if(x)
-                in &gt;&gt; *x;
-            else // x is null
-                x = readObject(in, id);
-            // in.skipBlanksAndCommentsAndSeparators();
-            in.copies_map_in[id]= x;
-        } 
-        else 
-        {
-            // Find it in map and return ptr;
-            map&lt;unsigned int, void *&gt;::iterator it = in.copies_map_in.find(id);
-            if (it == in.copies_map_in.end())
-                PLERROR(&quot;In PStream::operator&gt;&gt;(Object*&amp;) object (ptr) to be read with id='%d' &quot;
-                        &quot;has not been previously defined&quot;, id);
-            x= static_cast&lt;Object *&gt;(it-&gt;second);
+            in.skipBlanksAndCommentsAndSeparators(); 
+            if (in.peek() == '-') 
+            {
+                in.get(); // Eat '-'
+                char cc = in.get();
+                if(cc != '&gt;') // Eat '&gt;'
+                    PLERROR(&quot;In PStream::operator&gt;&gt;(Object*&amp;)  Wrong format. &quot;
+                            &quot;Expecting \&quot;*%d-&gt;\&quot; but got \&quot;*%d-%c\&quot;.&quot;, id, id, cc);
+                in.skipBlanksAndCommentsAndSeparators();
+                if(x)
+                    in &gt;&gt; *x;
+                else // x is null
+                    x = readObject(in, id);
+                //don't skip blanks before we need to read something else (read might block).
+                // in.skipBlanksAndCommentsAndSeparators();
+                in.copies_map_in[id]= x;
+            } 
+            else 
+            {
+                // Find it in map and return ptr;
+                map&lt;unsigned int, void *&gt;::iterator it = in.copies_map_in.find(id);
+                if (it == in.copies_map_in.end())
+                    PLERROR(&quot;In PStream::operator&gt;&gt;(Object*&amp;) object (ptr) to be read with id='%d' &quot;
+                            &quot;has not been previously defined&quot;, id);
+                x= static_cast&lt;Object *&gt;(it-&gt;second);
+            }
         }
-    } 
+    }
     else
     {
         x = readObject(in);
+        //don't skip blanks before we need to read something else (read might block).
         // in.skipBlanksAndCommentsAndSeparators();
     }
 

Modified: trunk/plearn/base/tuple.h
===================================================================
--- trunk/plearn/base/tuple.h	2007-03-07 21:12:26 UTC (rev 6722)
+++ trunk/plearn/base/tuple.h	2007-03-09 00:31:06 UTC (rev 6723)
@@ -325,6 +325,55 @@
     return in;
 }
 
+
+//! Tuples handle deepCopying by distributing it to each element
+template&lt;typename T0&gt;
+inline void deepCopyField(tuple&lt;T0&gt;&amp; t, CopiesMap&amp; copies)
+{
+    deepCopyField(get&lt;0&gt;(t), copies);
+}
+template&lt;typename T0, typename T1&gt;
+inline void deepCopyField(tuple&lt;T0,T1&gt;&amp; t, CopiesMap&amp; copies)
+{
+    deepCopyField(get&lt;0&gt;(t), copies);
+    deepCopyField(get&lt;1&gt;(t), copies);
+}
+template&lt;typename T0, typename T1, typename T2&gt;
+inline void deepCopyField(tuple&lt;T0,T1,T2&gt;&amp; t, CopiesMap&amp; copies)
+{
+    deepCopyField(get&lt;0&gt;(t), copies);
+    deepCopyField(get&lt;1&gt;(t), copies);
+    deepCopyField(get&lt;2&gt;(t), copies);
+}
+template&lt;typename T0, typename T1, typename T2, typename T3&gt;
+inline void deepCopyField(tuple&lt;T0,T1,T2,T3&gt;&amp; t, CopiesMap&amp; copies)
+{
+    deepCopyField(get&lt;0&gt;(t), copies);
+    deepCopyField(get&lt;1&gt;(t), copies);
+    deepCopyField(get&lt;2&gt;(t), copies);
+    deepCopyField(get&lt;3&gt;(t), copies);
+}
+template&lt;typename T0, typename T1, typename T2, typename T3, typename T4&gt;
+inline void deepCopyField(tuple&lt;T0,T1,T2,T3,T4&gt;&amp; t, CopiesMap&amp; copies)
+{
+    deepCopyField(get&lt;0&gt;(t), copies);
+    deepCopyField(get&lt;1&gt;(t), copies);
+    deepCopyField(get&lt;2&gt;(t), copies);
+    deepCopyField(get&lt;3&gt;(t), copies);
+    deepCopyField(get&lt;4&gt;(t), copies);
+}
+template&lt;typename T0, typename T1, typename T2, typename T3, typename T4, typename T5&gt;
+inline void deepCopyField(tuple&lt;T0,T1,T2,T3,T4,T5&gt;&amp; t, CopiesMap&amp; copies)
+{
+    deepCopyField(get&lt;0&gt;(t), copies);
+    deepCopyField(get&lt;1&gt;(t), copies);
+    deepCopyField(get&lt;2&gt;(t), copies);
+    deepCopyField(get&lt;3&gt;(t), copies);
+    deepCopyField(get&lt;4&gt;(t), copies);
+    deepCopyField(get&lt;5&gt;(t), copies);
+}
+
+
 } // namespace PLearn
 
 #endif //ndef pl_tuple_INC

Modified: trunk/plearn/io/PStream.h
===================================================================
--- trunk/plearn/io/PStream.h	2007-03-07 21:12:26 UTC (rev 6722)
+++ trunk/plearn/io/PStream.h	2007-03-09 00:31:06 UTC (rev 6723)
@@ -527,44 +527,54 @@
 template &lt;class T&gt; 
 inline PStream&amp; operator&gt;&gt;(PStream&amp; in, T*&amp; x)
 {
+
     in.skipBlanksAndCommentsAndSeparators();
     if (in.peek() == '*')
     {
         in.get(); // Eat '*'
         unsigned int id;
         in &gt;&gt; id;
-        in.skipBlanksAndCommentsAndSeparators();
+        //don't skip blanks before we need to read something else (read might block).
+        //in.skipBlanksAndCommentsAndSeparators();
         if (id==0)
             x = 0;
-        else if (in.peek() == '-') 
+        else
         {
-            in.get(); // Eat '-'
-            char cc = in.get();
-            if(cc != '&gt;') // Eat '&gt;'
-                PLERROR(&quot;In PStream::operator&gt;&gt;(T*&amp;)  Wrong format.  Expecting \&quot;*%d-&gt;\&quot; but got \&quot;*%d-%c\&quot;.&quot;, id, id, cc);
             in.skipBlanksAndCommentsAndSeparators();
-            if(!x)
-                x= new T();
-            in &gt;&gt; *x;
-            in.skipBlanksAndCommentsAndSeparators();
-            in.copies_map_in[id]= x;
-        } 
-        else 
-        {
-            // Find it in map and return ptr;
-            map&lt;unsigned int, void *&gt;::iterator it = in.copies_map_in.find(id);
-            if (it == in.copies_map_in.end())
-                PLERROR(&quot;In PStream::operator&gt;&gt;(T*&amp;) object (ptr) to be read with id='%d' &quot;
-                        &quot;has not been previously defined&quot;, id);
-            x= static_cast&lt;T *&gt;(it-&gt;second);
+            if (in.peek() == '-') 
+            {
+                in.get(); // Eat '-'
+                char cc = in.get();
+                if(cc != '&gt;') // Eat '&gt;'
+                    PLERROR(&quot;In PStream::operator&gt;&gt;(T*&amp;)  Wrong format.  Expecting \&quot;*%d-&gt;\&quot; but got \&quot;*%d-%c\&quot;.&quot;, id, id, cc);
+                //don't skip blanks before we need to read something else (read might block).
+                //in.skipBlanksAndCommentsAndSeparators();
+                if(!x)
+                    x= new T();
+                in.skipBlanksAndCommentsAndSeparators();
+                in &gt;&gt; *x;
+                //don't skip blanks before we need to read something else (read might block).
+                //in.skipBlanksAndCommentsAndSeparators();
+                in.copies_map_in[id]= x;
+            } 
+            else 
+            {
+                // Find it in map and return ptr;
+                map&lt;unsigned int, void *&gt;::iterator it = in.copies_map_in.find(id);
+                if (it == in.copies_map_in.end())
+                    PLERROR(&quot;In PStream::operator&gt;&gt;(T*&amp;) object (ptr) to be read with id='%d' &quot;
+                            &quot;has not been previously defined&quot;, id);
+                x= static_cast&lt;T *&gt;(it-&gt;second);
+            }
         }
     } 
     else
     {
         in &gt;&gt; *x;
-        in.skipBlanksAndCommentsAndSeparators();
+        //don't skip blanks before we need to read something else (read might block).
+        //in.skipBlanksAndCommentsAndSeparators();
     }
-
+    
     return in;
 }
 
@@ -1016,8 +1026,10 @@
         typename SequenceType::iterator it = seq.begin();
         while(n--)
         {
+            in.skipBlanks();
             in &gt;&gt; *it; 
-            in.skipBlanks();
+            //don't skip blanks before we need to read something else (read might block).
+            //in.skipBlanks();
             ++it;
         }
     }
@@ -1044,8 +1056,8 @@
         else if(c=='[') // read until ']'
         {
             in.get(); // skip '['
+            seq.resize(0);
             in.skipBlanksAndCommentsAndSeparators();
-            seq.resize(0);
             while(in.peek()!=']' &amp;&amp; in.peek()!=EOF &amp;&amp; !in.eof())
             {
                 typename SequenceType::value_type x;
@@ -1065,15 +1077,18 @@
             c = in.get();
             if(c!='[')
                 PLERROR(&quot;Error in readSequence(SequenceType&amp; seq), expected '[', read '%c'&quot;,c);
-            in.skipBlanksAndCommentsAndSeparators();
+            //don't skip blanks before we need to read something else (read might block).
+            //in.skipBlanksAndCommentsAndSeparators();
             seq.resize((typename SequenceType::size_type) n);
             if (n&gt;0)
             {
                 typename SequenceType::iterator it = seq.begin();
                 while(n--)
                 {
+                    in.skipBlanksAndCommentsAndSeparators();
                     in &gt;&gt; *it;
-                    in.skipBlanksAndCommentsAndSeparators();
+                    //don't skip blanks before we need to read something else (read might block).
+                    //in.skipBlanksAndCommentsAndSeparators();
                     ++it;
                 }
             }
@@ -1180,8 +1195,8 @@
     {
         typename SetT::value_type val;
         in &gt;&gt; val;
+        s.insert(val);
         in.skipBlanksAndCommentsAndSeparators();
-        s.insert(val);
         c = in.peek(); // do we have a ']' ?
     }
     in.get(); // eat the ']'

Modified: trunk/plearn/math/ObservationWindow.cc
===================================================================
--- trunk/plearn/math/ObservationWindow.cc	2007-03-07 21:12:26 UTC (rev 6722)
+++ trunk/plearn/math/ObservationWindow.cc	2007-03-09 00:31:06 UTC (rev 6723)
@@ -2,7 +2,7 @@
 // ObservationWindow.cc
 // 
 // Copyright (C) 2006 Christian Dorion
-// Copyright (C) 2006 ApStat Technologies Inc.
+// Copyright (C) 2006,2007 ApStat Technologies Inc.
 // 
 // Redistribution and use in source and binary forms, with or without
 // modification, are permitted provided that the following conditions are met:
@@ -38,12 +38,106 @@
 namespace PLearn {
 using namespace std;
 
+PLEARN_IMPLEMENT_OBJECT(
+    ObservationWindow,
+    &quot;ONE LINE USER DESCRIPTION&quot;,
+    &quot;MULTI LINE\nHELP FOR USERS&quot;
+    );
+
+
 ObservationWindow::ObservationWindow(int window)
     : m_window(window)
 {
     forget();
 }
 
+
+// ### Nothing to add here, simply calls build_
+void ObservationWindow::build()
+{
+    inherited::build();
+    build_();
+}
+
+void ObservationWindow::makeDeepCopyFromShallowCopy(CopiesMap&amp; copies)
+{
+    inherited::makeDeepCopyFromShallowCopy(copies);
+
+    // ### Call deepCopyField on all &quot;pointer-like&quot; fields
+    // ### that you wish to be deepCopied rather than
+    // ### shallow-copied.
+    // ### ex:
+    // deepCopyField(trainvec, copies);
+
+    // ### Remove this line when you have fully implemented this method.
+    //PLERROR(&quot;ObservationWindow::makeDeepCopyFromShallowCopy not fully (correctly) implemented yet!&quot;);
+
+    deepCopyField(m_observations, copies);
+    deepCopyField(m_obs_weights,  copies);
+    deepCopyField(m_last_update_rvalue,  copies);
+
+}
+
+void ObservationWindow::declareOptions(OptionList&amp; ol)
+{
+    // ### Declare all of this object's options here.
+    // ### For the &quot;flags&quot; of each option, you should typically specify
+    // ### one of OptionBase::buildoption, OptionBase::learntoption or
+    // ### OptionBase::tuningoption. If you don't provide one of these three,
+    // ### this option will be ignored when loading values from a script.
+    // ### You can also combine flags, for example with OptionBase::nosave:
+    // ### (OptionBase::buildoption | OptionBase::nosave)
+
+    // ### ex:
+    // declareOption(ol, &quot;myoption&quot;, &amp;ObservationWindow::myoption,
+    //               OptionBase::buildoption,
+    //               &quot;Help text describing this option&quot;);
+    // ...
+
+    declareOption(ol, &quot;window&quot;, &amp;ObservationWindow::m_window,
+                  OptionBase::buildoption,
+                  &quot;Window length&quot;);
+
+    declareOption(ol, &quot;nobs&quot;, &amp;ObservationWindow::m_nobs,
+                  OptionBase::learntoption,
+                  &quot;nb. observations&quot;);
+
+    declareOption(ol, &quot;cursor&quot;, &amp;ObservationWindow::m_cursor,
+                  OptionBase::learntoption | OptionBase::nosave,
+                  &quot;cursor pos.&quot;);
+
+    declareOption(ol, &quot;observations&quot;, &amp;ObservationWindow::m_observations,
+                  OptionBase::learntoption | OptionBase::nosave,
+                  &quot;the observations themselves&quot;);
+
+    declareOption(ol, &quot;obs_weights&quot;, &amp;ObservationWindow::m_obs_weights,
+                  OptionBase::learntoption | OptionBase::nosave,
+                  &quot;observation weights&quot;);
+
+    declareOption(ol, &quot;last_update_rvalue&quot;, &amp;ObservationWindow::m_last_update_rvalue,
+                  OptionBase::learntoption | OptionBase::nosave,
+                  &quot;last_update_rvalue&quot;);
+
+    // Now call the parent class' declareOptions
+    inherited::declareOptions(ol);
+}
+
+void ObservationWindow::build_()
+{
+    // ### This method should do the real building of the object,
+    // ### according to set 'options', in *any* situation.
+    // ### Typical situations include:
+    // ###  - Initial building of an object from a few user-specified options
+    // ###  - Building of a &quot;reloaded&quot; object: i.e. from the complete set of
+    // ###    all serialised options.
+    // ###  - Updating or &quot;re-building&quot; of an object after a few &quot;tuning&quot;
+    // ###    options have been modified.
+    // ### You should assume that the parent class' build_() has already been
+    // ### called.
+}
+
+
+
 int ObservationWindow::length() const
 {
     return m_observations.length();
@@ -125,7 +219,7 @@
     return m_obs_weights[last_obs];
 }
 
-
+/*
 //! Deep copying
 ObservationWindow* ObservationWindow::deepCopy(CopiesMap&amp; copies) const
 {
@@ -144,8 +238,8 @@
     //!  return the completed deep_copy
     return deep_copy;
 }
+*/
 
-
 } // end of namespace PLearn
 
 

Modified: trunk/plearn/math/ObservationWindow.h
===================================================================
--- trunk/plearn/math/ObservationWindow.h	2007-03-07 21:12:26 UTC (rev 6722)
+++ trunk/plearn/math/ObservationWindow.h	2007-03-09 00:31:06 UTC (rev 6723)
@@ -2,7 +2,7 @@
 // ObservationWindow.h
 // 
 // Copyright (C) 2006 Christian Dorion
-// Copyright (C) 2006 ApStat Technologies Inc.
+// Copyright (C) 2006,2007 ApStat Technologies Inc.
 // 
 // Redistribution and use in source and binary forms, with or without
 // modification, are permitted provided that the following conditions are met:
@@ -40,6 +40,7 @@
 #include &lt;map&gt;
 
 // From PLearn
+#include &lt;plearn/base/Object.h&gt;
 #include &lt;plearn/base/PP.h&gt;
 #include &lt;plearn/base/tuple.h&gt;
 #include &lt;plearn/math/TVec.h&gt;
@@ -47,8 +48,10 @@
 namespace PLearn {
 using namespace std;
 
-class ObservationWindow: public PPointable
+class ObservationWindow: public Object
 {
+    typedef Object inherited;
+
 public:    
     int m_window;
 
@@ -77,10 +80,42 @@
     const Vec lastObs() const;
     real lastWeight() const;
     
+
+    //#####  PLearn::Object Protocol  #########################################
+
+    // Declares other standard object methods.
+    // ### If your class is not instantiatable (it has pure virtual methods)
+    // ### you should replace this by PLEARN_DECLARE_ABSTRACT_OBJECT
+    PLEARN_DECLARE_OBJECT(ObservationWindow);
+
+    // Simply calls inherited::build() then build_()
+    virtual void build();
+
+    //! Transforms a shallow copy into a deep copy
+    // (PLEASE IMPLEMENT IN .cc)
+    virtual void makeDeepCopyFromShallowCopy(CopiesMap&amp; copies);
+
     //! Deep copying
-    ObservationWindow* deepCopy(CopiesMap&amp; copies) const;
+    //ObservationWindow* deepCopy(CopiesMap&amp; copies) const;
+
+protected:
+    //#####  Protected Member Functions  ######################################
+
+    //! Declares the class options.
+    // (PLEASE IMPLEMENT IN .cc)
+    static void declareOptions(OptionList&amp; ol);
+
+private:
+    //#####  Private Member Functions  ########################################
+
+    //! This does the actual building.
+    // (PLEASE IMPLEMENT IN .cc)
+    void build_();
+
+
 };
 
+/*
 inline PStream&amp; operator&lt;&lt;(PStream&amp; out, const ObservationWindow&amp; win)
 {
     out &lt;&lt; &quot;ObservationWindow(len=&quot; &lt;&lt; win.length() &lt;&lt; &quot;, window=&quot; &lt;&lt; win.m_window &lt;&lt; &quot;)&quot;;
@@ -92,7 +127,10 @@
     out &lt;&lt; *win;
     return out;
 }
+*/
 
+DECLARE_OBJECT_PTR(ObservationWindow);
+
 } // end of namespace PLearn
 
 #endif

Modified: trunk/plearn/math/StatsCollector.cc
===================================================================
--- trunk/plearn/math/StatsCollector.cc	2007-03-07 21:12:26 UTC (rev 6722)
+++ trunk/plearn/math/StatsCollector.cc	2007-03-09 00:31:06 UTC (rev 6723)
@@ -45,6 +45,7 @@
 #include &quot;StatsCollector.h&quot;
 #include &quot;TMat_maths.h&quot;
 #include &quot;pl_erf.h&quot;
+#include &quot;pl_math.h&quot;
 #include &lt;assert.h&gt;
 #include &lt;plearn/io/openString.h&gt;
 #include &lt;plearn/math/random.h&gt;   //!&lt; For shuffleRows().
@@ -164,6 +165,8 @@
     return (d&lt;0)?-1:(fast_exact_is_equal(d, 0) ? 0:1);
 }
 
+/**
+ * DEPRECATED: don't sort ids -xsm
 //! fix 'id' attribute of all StatCollectorCounts so that increasing ids correspond to increasing real values
 //! *** NOT TESTED YET (Julien)
 void StatsCollector::sortIds()
@@ -177,6 +180,7 @@
         allreals[i].second-&gt;id=i;
     delete allreals;
 }
+*/
 
 void StatsCollector::declareOptions(OptionList&amp; ol)
 {
@@ -230,6 +234,10 @@
         &quot;well as a last element which maps FLT_MAX, so that we do not miss\n&quot;
         &quot;anything (remains empty if maxnvalues == 0).&quot;);
 
+    declareOption(ol, &quot;count_ids&quot;, &amp;StatsCollector::count_ids,
+                                OptionBase::learntoption | OptionBase::nosave,
+        &quot;Maps an id to a count value.&quot;);
+
     declareOption(ol, &quot;more_than_maxnvalues&quot;, &amp;StatsCollector::more_than_maxnvalues, OptionBase::learntoption,
                   &quot;Set to 1 when more than 'maxnvalues' are seen. This is to warn the user when computing\n&quot;
                   &quot;statistics that may be inaccurate when not all values are kept (e.g., LIFT).&quot;);
@@ -248,9 +256,16 @@
     // but rounded to some precision, and there would be 2 keys approx.=  FLT_MAX
     if(storeCounts() &amp;&amp; counts.size()==0)
         counts[FLT_MAX] = StatsCollectorCounts();
+
     // If no values are kept, then we always see more than 0 values.
     if (maxnvalues == 0)
         more_than_maxnvalues = true;
+    
+    // build count_ids
+    count_ids.clear();
+    for(map&lt;real, StatsCollectorCounts&gt;::iterator it= counts.begin();
+        it != counts.end(); ++it)
+        count_ids[it-&gt;second.id]= it-&gt;first;
 }
 
 ///////////
@@ -320,15 +335,18 @@
             {
                 // Still remembering new unseen values
                 it = counts.find(val);
+
                 if(it==counts.end()) {
                     // Create a new entry.
                     // Note that doing this in a single operation is not recommended.
                     // Indeed, depending on the compiler, counts.size() may differ by 1
                     // because the [] operator may be called before or after. That's why
                     // we explicitly call counts.size() first.
-                    int id = int(counts.size()) - 1;
+                    int id = int(counts.size());
                     counts[val].id = id;
+                    count_ids[id]= val;
                 }
+
                 counts[val].n += weight;
             }
             else // We've filled up counts already
@@ -1117,6 +1135,113 @@
     return 2 * zpr1t();
 }
 
+
+void StatsCollector::merge(const StatsCollector&amp; other)
+{
+    if(storeCounts() &amp;&amp; other.maxnvalues != -1)
+        PLERROR(&quot;Cannot merge stats collectors w/counts if 'other' stats col. has maxnvalues != -1&quot;);
+
+    if(fast_exact_is_equal(nnonmissing_,0))    // this was empty before merge
+    {
+        min_= other.min_;
+        max_= other.max_;
+        first_= other.first_;
+        last_= other.last_;
+    }
+
+    sum_+= other.sum() - first_*other.nnonmissing_;
+    double first2= first_*first_;
+    sumsquare_+= other.sumsquare() - 2.0*first_*other.sum() + first2*other.nnonmissing_;
+    double ofirst2= other.first_*other.first_;
+    double osum3= other.sumcube_ + 3.0*other.first_*other.sumsquare() 
+        - 3.0*ofirst2*other.sum() + ofirst2*other.first_*other.nnonmissing_;
+    sumcube_+= osum3 - 3.0*first_*other.sumsquare() 
+        + 3.0*first2*other.sum() - first2*first_*other.nnonmissing_;
+    double osum4= other.sumfourth_ + 4.0*other.first_*osum3 - 6.0*ofirst2*other.sumsquare() 
+        + 4.0*other.first_*ofirst2*other.sum() - ofirst2*ofirst2*other.nnonmissing_;
+    sumfourth_+= osum4 - 4.0*first_*osum3 + 6.0*first2*other.sumsquare() 
+        - 4.0*first_*first2*other.sum() + first2*first2*other.nnonmissing_;
+
+    nmissing_+= other.nmissing_;
+    nnonmissing_+= other.nnonmissing_;
+    sumsquarew_+= other.sumsquarew_;
+
+    min_= std::min(min_, other.min_);
+    max_= std::max(max_, other.max_);
+    last_= other.last_; //assume this is first and other is last.
+    sorted = false;
+
+    if (storeCounts())//now merge counts
+    {
+        
+        int nextid= 0;
+        set&lt;real&gt; already_merged;
+        map&lt;real,StatsCollectorCounts&gt;::iterator it;
+        map&lt;real,StatsCollectorCounts&gt;::const_iterator ito;
+        map&lt;int, real&gt;::const_iterator iti;
+        while(nextid &lt; int(other.counts.size()) &amp;&amp; (maxnvalues == -1 || int(counts.size()) &lt;= maxnvalues))
+        {// merge counts with smallest ids until maxnvalues reached
+
+            iti= other.count_ids.find(nextid);
+            if(iti == other.count_ids.end())
+            {
+                PLWARNING(&quot;Can't find count id %d&quot;, nextid);
+                break;
+            }
+            real val= iti-&gt;second;
+            ito= other.counts.find(val);
+            if(ito == other.counts.end())
+            {
+                PLWARNING(&quot;Can't find count id %d, val %f&quot;, nextid, val);
+                break;
+            }
+
+            int newid= int(counts.size());
+
+            it= counts.find(val);
+            if(it != counts.end())
+                it-&gt;second.merge(ito-&gt;second);
+            else
+            {
+                counts[val]= ito-&gt;second;
+                counts[val].id= newid;
+                count_ids[newid]= val;
+            }
+            ++nextid;
+            already_merged.insert(val);
+        }
+
+        for(ito= other.counts.begin(); ito != other.counts.end(); ++ito)
+        {
+            real val= ito-&gt;first;
+            if(already_merged.count(val) == 0)//skip those merged earlier
+            {
+                it= counts.find(val);
+                if(it != counts.end())
+                    it-&gt;second.merge(ito-&gt;second);
+                else if(maxnvalues == -1 || int(counts.size()) &lt;= maxnvalues)
+                {
+                    int id= int(counts.size());
+                    counts[val]= ito-&gt;second;
+                    counts[val].id= id;
+                    count_ids[id]= val;
+                }
+                else
+                {
+                    more_than_maxnvalues= true;
+                    it= counts.lower_bound(val);
+                    real weight= ito-&gt;second.n;
+                    it-&gt;second.nbelow+= ito-&gt;second.nbelow + weight;
+                    it-&gt;second.sum+= val*weight;//ito-&gt;second.sum;
+                    it-&gt;second.sumsquare+= val*val*weight;//ito-&gt;second.sumsquare;
+                }
+            }
+        }
+    }
+    if (!approximate_counts.empty()) approximate_counts.clear();
+}
+
+
 } // end of namespace PLearn
 
 

Modified: trunk/plearn/math/StatsCollector.h
===================================================================
--- trunk/plearn/math/StatsCollector.h	2007-03-07 21:12:26 UTC (rev 6722)
+++ trunk/plearn/math/StatsCollector.h	2007-03-09 00:31:06 UTC (rev 6723)
@@ -4,6 +4,7 @@
 //
 // Copyright (C) 2001,2002 Pascal Vincent
 // Copyright (C) 2005 University of Montreal
+// Copyright (C) 2007 Xavier Saint-Mleux, ApSTAT Technologies inc.
 //
 
 // Redistribution and use in source and binary forms, with or without
@@ -65,7 +66,21 @@
   
     StatsCollectorCounts(): 
         n(0), nbelow(0),
-        sum(0.), sumsquare(0.),id(0) {}          
+        sum(0.), sumsquare(0.),id(0) 
+    {}          
+
+    /**
+     * merge: Merge counts from another StatsCollectorCounts
+     *        into this one.
+     */
+    virtual void merge(const StatsCollectorCounts&amp; other)
+    {
+        //don't change id
+        n+= other.n;
+        nbelow+= other.nbelow;
+        sum+= other.sum;
+        sumsquare+= other.sumsquare;
+    }
 };
 
 typedef pair&lt;real,StatsCollectorCounts*&gt; PairRealSCCType;
@@ -86,10 +101,8 @@
     StatsCollectorCounts refer_sc, other_sc;
     PStream in = openString(refer, PStream::plearn_ascii);
     in &gt;&gt; refer_sc;
-    in.flush();
     in = openString(other, PStream::plearn_ascii);
     in &gt;&gt; other_sc;
-    in.flush();
     int n_diffs = 0;
     PP&lt;OptionBase&gt; opt_double = new Option&lt;ObjectType, double&gt;
         (&quot;&quot;, 0, 0, TypeTraits&lt;double&gt;::name(), &quot;&quot;, &quot;&quot;);
@@ -157,6 +170,7 @@
     bool more_than_maxnvalues;
 
     map&lt;real, StatsCollectorCounts&gt; counts; 
+    map&lt;int, real&gt; count_ids;
 
 protected:
 
@@ -295,9 +309,12 @@
      */
     real pseudo_quantile(real q) const;
 
+    /**
+     * DEPRECATED: DO NOT SORT IDs -xsm
     //! fix 'id' attribute of all StatCollectorCounts so that increasing ids correspond to increasing real values
     //! *** NOT TESTED YET
     void sortIds();
+    */
 
     //! returns a mapping that maps values to a bin number
     //! (from 0 to mapping.length()-1)
@@ -331,6 +348,9 @@
     //! Overridden to have a fancy output for raw_ascii and pretty_ascii modes.
     virtual void newwrite(PStream&amp; out) const;
 
+    //! merge another StatsCollector into this one
+    virtual void merge(const StatsCollector&amp; other);
+
 };
 
 DECLARE_OBJECT_PTR(StatsCollector);

Modified: trunk/plearn/math/TMat_decl.h
===================================================================
--- trunk/plearn/math/TMat_decl.h	2007-03-07 21:12:26 UTC (rev 6722)
+++ trunk/plearn/math/TMat_decl.h	2007-03-09 00:31:06 UTC (rev 6723)
@@ -458,12 +458,13 @@
     //! Note that users should rather use the form in &gt;&gt; m;
     void read(PStream&amp; in)
     {
+
         switch(in.inmode)
         {
         case PStream::raw_ascii:
         case PStream::raw_binary:
         {
-            T* ptr = data();
+            T* ptr = (length_&gt;0 &amp;&amp; width_&gt;0)? data():0;
             for(int i=0; i&lt;length_; i++, ptr+=mod_)
                 for(int j=0; j&lt;width_; j++)
                     in &gt;&gt; ptr[j];
@@ -534,7 +535,7 @@
                         endianswap(&amp;w);
                     }
                     resize(l,w);
-                    T* ptr = data();
+                    T* ptr = (l&gt;0 &amp;&amp; w&gt;0)? data():0;
                     for(int i=0; i&lt;length_; i++, ptr+=mod_)                    
                         binread_(in, ptr, width_, typecode);
                 }

Modified: trunk/plearn/math/VecStatsCollector.cc
===================================================================
--- trunk/plearn/math/VecStatsCollector.cc	2007-03-07 21:12:26 UTC (rev 6722)
+++ trunk/plearn/math/VecStatsCollector.cc	2007-03-09 00:31:06 UTC (rev 6723)
@@ -137,7 +137,7 @@
     declareOption(
         ol, &quot;sum_non_missing_square_weights&quot;, &amp;VecStatsCollector::sum_non_missing_square_weights, OptionBase::learntoption,
         &quot;Sum of square weights for vectors with no missing value.&quot;);
-    
+  
     // Now call the parent class' declareOptions
     inherited::declareOptions(ol);
 }
@@ -619,6 +619,81 @@
     }
 }
 
+void VecStatsCollector::merge(VecStatsCollector&amp; other)
+{
+    if(m_window &gt; 0 || other.m_window &gt; 0)
+        PLERROR(&quot;VecStatsCollector::merge does not support observation windows yet!&quot;);
+
+    if(fieldnames != other.fieldnames)
+        PLERROR(&quot;VecStatsCollector::merge : cannot merge VecStatsCollectors with different fieldnames.&quot;);
+
+    if(stats.size()==0)//if this one is empty, resize stats before merging
+    {
+        int n= other.stats.size();
+        stats.resize(n);
+        for(int k=0; k&lt;n; k++)
+        {
+            // TODO It would be cool to have a simple (or automatic) mechanism
+            // to be able to specify a different value of 'maxnvalues' for each
+            // StatsCollector (e.g. when only one StatsCollector is meant to
+            // compute a lift statistics).
+            stats[k].maxnvalues          = maxnvalues;
+            stats[k].no_removal_warnings = no_removal_warnings;
+            stats[k].forget();
+        }
+        if(compute_covariance)
+        {
+            cov.resize(n,n);
+            sum_cross.resize(n,n);
+            sum_cross_weights.resize(n,n);
+            sum_cross_square_weights.resize(n,n);
+            cov.fill(0);
+            sum_cross.fill(0);
+            sum_cross_weights.fill(0);
+            sum_cross_square_weights.fill(0);
+        }      
+    }
+
+    if(stats.length() != other.stats.length())
+        PLERROR(&quot;VecStatsCollector::merge : cannot merge VecStatsCollectors with different stats length.&quot;);
+
+    for(int i= 0; i &lt; stats.length(); ++i)
+        stats[i].merge(other.stats[i]);
+
+    if(compute_covariance)
+    {
+        for(int i= 0; i &lt; cov.length(); ++i)
+            for(int j= 0; j &lt; cov.width(); ++j)
+            {
+                cov(i,j)+= other.cov(i,j);
+                sum_cross(i,j)+= other.sum_cross(i,j);
+                sum_cross_weights(i,j)+= other.sum_cross_weights(i,j);
+                sum_cross_square_weights(i,j)+= other.sum_cross_square_weights(i,j);
+            }
+        sum_non_missing_weights+= other.sum_non_missing_weights;
+        sum_non_missing_square_weights+= other.sum_non_missing_square_weights;
+    }
+
+
+    /****
+     * TODO: proper merge of observation windows -xsm
+    
+    PP&lt;ObservationWindow&gt; oow= other.m_observation_window;
+    if((oow &amp;&amp; oow-&gt;isFull()) || (m_observation_window &amp;&amp; m_observation_window-&gt;isEmpty()))
+        m_observation_window= oow;
+    else if(oow &amp;&amp; m_observation_window)
+        for(int i= 0; i &lt; oow-&gt;length(); ++i)
+        {
+            tuple&lt;Vec, real&gt; outdated= m_observation_window-&gt;update(oow-&gt;getObs(i), oow-&gt;getWeight(i));
+            Vec&amp; obs = get&lt;0&gt;(outdated);
+            real w = get&lt;1&gt;(outdated);
+            if ( obs.isNotEmpty() )
+                remove_observation(obs, w);
+        }
+    */
+
+}
+
 void VecStatsCollector::makeDeepCopyFromShallowCopy(CopiesMap&amp; copies)
 {
     inherited::makeDeepCopyFromShallowCopy(copies);

Modified: trunk/plearn/math/VecStatsCollector.h
===================================================================
--- trunk/plearn/math/VecStatsCollector.h	2007-03-07 21:12:26 UTC (rev 6722)
+++ trunk/plearn/math/VecStatsCollector.h	2007-03-09 00:31:06 UTC (rev 6723)
@@ -167,6 +167,9 @@
     const StatsCollector&amp; getStats(int i) const 
     { return stats[i]; }
 
+    //! returns non-const statistics for element i
+    StatsCollector&amp; getStats(int i) { return stats[i]; }
+
     //! returns the empirical mean (sample average) vec
     Vec getMean() const {
         Vec mean;
@@ -229,6 +232,9 @@
 
     const Mat&amp; getObservations() const;
     const PP&lt;ObservationWindow&gt; getObservationWindow() const;
+
+    //! merges another VecStatsCollector into this one
+    virtual void merge(VecStatsCollector&amp; other);
     
     //! Transforms a shallow copy into a deep copy
     virtual void makeDeepCopyFromShallowCopy(CopiesMap&amp; copies);

Modified: trunk/plearn/misc/PLearnServer.cc
===================================================================
--- trunk/plearn/misc/PLearnServer.cc	2007-03-07 21:12:26 UTC (rev 6722)
+++ trunk/plearn/misc/PLearnServer.cc	2007-03-09 00:31:06 UTC (rev 6723)
@@ -229,7 +229,7 @@
             io.copies_map_in.clear();
             io.copies_map_out.clear();
             for (ObjMap::iterator it = objmap.begin(); it != objmap.end(); ++it)
-                io.copies_map_in[it-&gt;first] = it-&gt;second;
+                io.copies_map_in[it-&gt;first]= it-&gt;second;
         }
         int c = -1;
         do 
@@ -312,6 +312,7 @@
                 io &gt;&gt; obj_id;
                 DBG_LOG &lt;&lt; &quot;  ojbj_id = &quot; &lt;&lt; obj_id &lt;&lt; endl;
                 found = objmap.find(obj_id);
+                DBG_LOG &lt;&lt; &quot;objmap= &quot; &lt;&lt; objmap &lt;&lt; endl;
                 if(found == objmap.end()) // unexistant obj_id
                     PLERROR(&quot;Calling a method on a non-existing object&quot;);
                 else 

Modified: trunk/plearn/misc/PLearnService.cc
===================================================================
--- trunk/plearn/misc/PLearnService.cc	2007-03-07 21:12:26 UTC (rev 6722)
+++ trunk/plearn/misc/PLearnService.cc	2007-03-09 00:31:06 UTC (rev 6723)
@@ -135,7 +135,6 @@
 
 void PLearnService::disconnectFromServers()
 {
-    //available_servers = TVec&lt; PP&lt;RemotePLearnServer&gt; &gt;();
     while(available_servers.length() &gt; 0)
         disconnectFromServer(available_servers[0]);
 }
@@ -400,8 +399,6 @@
 
 void PLearnService::log_callback(PP&lt;RemotePLearnServer&gt; server, const string&amp; module_name, int vlevel, const string&amp; msg)
 { 
-    //unsigned int server_id= reinterpret_cast&lt;unsigned int&gt;(static_cast&lt;RemotePLearnServer*&gt;(server));
-    //unsigned int server_id= getServerID(server);
     PL_LOG(vlevel) &lt;&lt; &quot;&lt;From server &quot; &lt;&lt; servers_ids[server] &lt;&lt; &quot;&gt; [&quot; &lt;&lt; module_name &lt;&lt; &quot;] &quot; &lt;&lt; msg &lt;&lt; flush; 
 }
 
@@ -413,7 +410,9 @@
     static bool need_to_set_pb_plugin= true;
     if(need_to_set_pb_plugin)
     {
-        ProgressBar::setPlugin(new LineOutputProgressBarPlugin(cerr));
+        PP&lt;ProgressBarPlugin&gt; orig_pb_plugin= ProgressBar::getCurrentPlugin();
+        if(dynamic_cast&lt;NullProgressBarPlugin*&gt;(static_cast&lt;ProgressBarPlugin*&gt;(orig_pb_plugin)) == 0)
+            ProgressBar::setPlugin(new LineOutputProgressBarPlugin(cerr));
         need_to_set_pb_plugin= false;
     }
 

Modified: trunk/plearn/misc/RemotePLearnServer.cc
===================================================================
--- trunk/plearn/misc/RemotePLearnServer.cc	2007-03-07 21:12:26 UTC (rev 6722)
+++ trunk/plearn/misc/RemotePLearnServer.cc	2007-03-09 00:31:06 UTC (rev 6723)
@@ -55,10 +55,42 @@
   
 void RemotePLearnServer::clearMaps()
 {
-    io.copies_map_in.clear();
-    io.copies_map_out.clear();
+    io.clearInOutMaps();
+    // copy local object map to stream's out map
+    for(ObjMap::iterator it= objmap.begin(); it != objmap.end(); ++it)
+        io.copies_map_out[it-&gt;second]= it-&gt;first;
 }
   
+void RemotePLearnServer::link(unsigned int objid, void* obj)
+{ 
+    io.copies_map_out[obj]= objid;
+    objmap[objid]= obj; 
+    rev_objmap[obj]= objid;
+
+    DBG_LOG &lt;&lt; &quot;copies map: &quot; &lt;&lt; objmap &lt;&lt; endl;
+}
+
+void RemotePLearnServer::unlink(unsigned int objid)
+{ 
+    ObjMap::iterator it= objmap.find(objid);
+    if(it == objmap.end())
+        PLERROR(&quot;in RemotePLearnServer::unlink : cannot unlink an object which is not linked&quot;);
+    objmap.erase(it);
+    rev_objmap.erase(it-&gt;second);
+    io.copies_map_out.erase(it-&gt;second);
+}
+
+void RemotePLearnServer::unlink(void* obj)
+{ 
+    ReverseObjMap::iterator it= rev_objmap.find(obj);
+    if(it == rev_objmap.end())
+        PLERROR(&quot;in RemotePLearnServer::unlink : cannot unlink an object which is not linked&quot;);
+    rev_objmap.erase(it);
+    objmap.erase(it-&gt;second);
+    io.copies_map_out.erase(obj);
+}
+
+
 void RemotePLearnServer::newObject(int objid, const Object&amp; model)
 { 
     clearMaps();

Modified: trunk/plearn/misc/RemotePLearnServer.h
===================================================================
--- trunk/plearn/misc/RemotePLearnServer.h	2007-03-07 21:12:26 UTC (rev 6722)
+++ trunk/plearn/misc/RemotePLearnServer.h	2007-03-09 00:31:06 UTC (rev 6723)
@@ -61,9 +61,13 @@
     PStream io; // io communication channel with remote PLearnServer
     RemotePLearnServer(const PStream&amp; serverio);
 
+    typedef map&lt;unsigned int, void*&gt; ObjMap;
+    ObjMap objmap;
+    typedef map&lt;void*, unsigned int&gt; ReverseObjMap;
+    ReverseObjMap rev_objmap;
+
 public:
 
-
     void killServer() { io &lt;&lt; &quot;!K &quot; &lt;&lt; endl; }
     
     //! Builds an object based on the given model on the remote server,
@@ -112,7 +116,12 @@
     //! Deletes all objects of the remote server.
     void deleteAllObjectsAsync();
 
+    // object map related methods
     void clearMaps();
+    // Should link/unlink be called automatically in newObject/deleteObject ? -xsm
+    void link(unsigned int objid, void* obj);
+    void unlink(unsigned int objid);
+    void unlink(void* obj);
 
     //! Users generally won't have to call this, but rather one of the callFunction methods.
     inline void sendFunctionCallHeader(const string&amp; function_name, int nargs)

Modified: trunk/plearn_learners/generic/NNet.cc
===================================================================
--- trunk/plearn_learners/generic/NNet.cc	2007-03-07 21:12:26 UTC (rev 6722)
+++ trunk/plearn_learners/generic/NNet.cc	2007-03-09 00:31:06 UTC (rev 6723)
@@ -1062,13 +1062,13 @@
         // optimizer-&gt;verifyGradient(1e-6); // Uncomment if you want to check your new Var.
         train_stats-&gt;finalize();
         if(verbosity&gt;2)
-            cout &lt;&lt; &quot;Epoch &quot; &lt;&lt; stage &lt;&lt; &quot; train objective: &quot; &lt;&lt; train_stats-&gt;getMean() &lt;&lt; endl;
+            pout &lt;&lt; &quot;Epoch &quot; &lt;&lt; stage &lt;&lt; &quot; train objective: &quot; &lt;&lt; train_stats-&gt;getMean() &lt;&lt; endl;
         ++stage;
         if(pb)
             pb-&gt;update(stage-initial_stage);
     }
     if(verbosity&gt;1)
-        cout &lt;&lt; &quot;EPOCH &quot; &lt;&lt; stage &lt;&lt; &quot; train objective: &quot; &lt;&lt; train_stats-&gt;getMean() &lt;&lt; endl;
+        pout &lt;&lt; &quot;EPOCH &quot; &lt;&lt; stage &lt;&lt; &quot; train objective: &quot; &lt;&lt; train_stats-&gt;getMean() &lt;&lt; endl;
 
     output_and_target_to_cost-&gt;recomputeParents();
     test_costf-&gt;recomputeParents();

Modified: trunk/plearn_learners/generic/PLearner.cc
===================================================================
--- trunk/plearn_learners/generic/PLearner.cc	2007-03-07 21:12:26 UTC (rev 6722)
+++ trunk/plearn_learners/generic/PLearner.cc	2007-03-09 00:31:06 UTC (rev 6723)
@@ -6,6 +6,7 @@
 // Copyright (C) 1999-2002 Yoshua Bengio, Nicolas Chapados, Charles Dugas, Rejean Ducharme, Universite de Montreal
 // Copyright (C) 2001,2002 Francis Pieraut, Jean-Sebastien Senecal
 // Copyright (C) 2002 Frederic Morin, Xavier Saint-Mleux, Julien Keable
+// Copyright (C) 2007 Xavier Saint-Mleux, ApSTAT Technologies inc.
 // 
 // Redistribution and use in source and binary forms, with or without
 // modification, are permitted provided that the following conditions are met:
@@ -48,6 +49,8 @@
 #include &lt;plearn/io/pl_log.h&gt;
 #include &lt;plearn/math/pl_erf.h&gt;
 #include &lt;plearn/vmat/FileVMatrix.h&gt;
+#include &lt;plearn/vmat/MemoryVMatrix.h&gt;
+#include &lt;plearn/vmat/RowsSubVMatrix.h&gt;
 #include &lt;plearn/misc/PLearnService.h&gt;
 #include &lt;plearn/misc/RemotePLearnServer.h&gt;
 #include &lt;plearn/vmat/PLearnerOutputVMatrix.h&gt;
@@ -65,6 +68,8 @@
       verbosity(1),
       nservers(0),
       save_trainingset_prefix(&quot;&quot;),
+      parallelize_here(true),
+      master_sends_testset_rows(false),
       inputsize_(-1),
       targetsize_(-1),
       weightsize_(-1),
@@ -188,6 +193,7 @@
 
     declareOption(
         ol, &quot;nservers&quot;, &amp;PLearner::nservers, OptionBase::buildoption, 
+        &quot;DEPRECATED: use parallelize_here instead.\n&quot;
         &quot;Max number of computation servers to use in parallel with the main process.\n&quot;
         &quot;If &lt;=0 no parallelization will occur at this level.\n&quot;);
 
@@ -203,6 +209,15 @@
         &quot;complex nested learner structures, and you want to ensure that\n&quot;
         &quot;the inner learner is getting the correct results.  (Default=&quot;&quot;,\n&quot;
         &quot;i.e. don't save anything.)\n&quot;);
+
+    declareOption(
+        ol, &quot;parallelize_here&quot;, &amp;PLearner::parallelize_here, OptionBase::buildoption | OptionBase::nosave,
+        &quot;Reserve remote servers at this level if true.\n&quot;);
+
+    declareOption(
+        ol, &quot;master_sends_testset_rows&quot;, &amp;PLearner::master_sends_testset_rows, OptionBase::buildoption | OptionBase::nosave,
+        &quot;For parallel PLearner::test : wether the master should read the testset and send rows to the slaves,\n&quot;
+        &quot;or send a serialized description of the testset.\n&quot;);
   
     inherited::declareOptions(ol);
 }
@@ -264,7 +279,18 @@
                  &quot;stage==nstages, updating the stats with training costs measured on-line\n&quot;
                  &quot;in the process.\n&quot;)));
 
+
     declareMethod(
+        rmm, &quot;test&quot;, &amp;PLearner::rtest,
+        (BodyDoc(&quot;Test on a given testset and return stats, outputs and costs.&quot;),
+         ArgDoc(&quot;testset&quot;,&quot;test set&quot;),
+         ArgDoc(&quot;test_stats&quot;,&quot;VecStatsCollector to use&quot;),
+         ArgDoc(&quot;rtestoutputs&quot;,&quot;wether to return outputs&quot;),
+         ArgDoc(&quot;rtestcosts&quot;,&quot;wether to return costs&quot;),
+         RetDoc (&quot;tuple of (stats, outputs, costs)&quot;)));
+
+
+    declareMethod(
         rmm, &quot;resetInternalState&quot;, &amp;PLearner::resetInternalState,
         (BodyDoc(&quot;If the learner is a stateful one (inherits from StatefulLearner),\n&quot;
                  &quot;this resets the internal state to its initial value; by default,\n&quot;
@@ -763,39 +789,161 @@
     Vec output(outputsize());
     Vec costs(nTestCosts());
 
-    PP&lt;ProgressBar&gt; pb;
-    if (report_progress) 
-        pb = new ProgressBar(&quot;Testing learner&quot;, len);
-
     if (len == 0) {
         // Empty test set: we give -1 cost arbitrarily.
         costs.fill(-1);
         test_stats-&gt;update(costs);
     }
 
-    for (int i = 0; i &lt; len; i++)
-    {
-        testset.getExample(i, input, target, weight);
-      
-        // Always call computeOutputAndCosts, since this is better
-        // behaved with stateful learners
-        computeOutputAndCosts(input,target,output,costs);
-      
-        if (testoutputs)
-            testoutputs-&gt;putOrAppendRow(i, output);
+    PLearnService&amp; service(PLearnService::instance());
 
-        if (testcosts)
-            testcosts-&gt;putOrAppendRow(i, costs);
+    //DUMMY: need to find a better way to calc. nservers -xsm
+    const int chunksize= 10000;//nb. rows in each chunk sent to a remote server
+    const int chunks_per_server= 10;//ideal nb. chunks per server
+    int nservers= min(len/(chunks_per_server*chunksize), service.availableServers());
 
-        if (test_stats)
-            test_stats-&gt;update(costs, weight);
+    if(nservers &gt; 1 &amp;&amp; parallelize_here &amp;&amp; !isStatefulLearner()
+       &amp;&amp; (!test_stats || test_stats-&gt;m_window == -1)) //VecStatsCollector does not support merge w/observation_window yet
+    {// parallel test
+        CopiesMap copies;
+        PP&lt;VecStatsCollector&gt; template_vsc= test_stats? test_stats-&gt;deepCopy(copies) : 0;
+        TVec&lt;PP&lt;RemotePLearnServer&gt; &gt; servers= service.reserveServers(nservers);
+        nservers= servers.length();
+        int curpos= 0;
+        int chunks_called= 0;
+        int last_chunknum= -1;
+        map&lt;PP&lt;RemotePLearnServer&gt;, int&gt; learners_ids;
+        map&lt;PP&lt;RemotePLearnServer&gt;, int&gt; chunknums;
+        map&lt;int, PP&lt;VecStatsCollector&gt; &gt; vscs;
 
-        if (report_progress)
-            pb-&gt;update(i);
+        for(int i= 0; i &lt; nservers; ++i)
+            servers[i]-&gt;newObjectAsync(*this);
+        while(nservers &gt; 0)
+        {
+            PP&lt;RemotePLearnServer&gt; s= service.waitForResult();
+            if(learners_ids.find(s) == learners_ids.end())
+            {
+                if(curpos &lt; len) // get learner id and send first chunk to process
+                {
+                    /* step 1 (once per slave) */
+                    int id;
+                    s-&gt;getResults(id);
+                    learners_ids[s]= id;
+                    int clen= min(chunksize, testset.length()-curpos);
+                    VMat sts= new RowsSubVMatrix(testset, curpos, clen);
+                    if(master_sends_testset_rows)
+                        sts= new MemoryVMatrix(sts.toMat());
+                    else
+                    {
+                        // send testset once and for all, put it in object map of remote server
+                        int tsid= s-&gt;newObject(*testset);
+                        s-&gt;link(tsid, testset);
+                    }
+                    curpos+= clen;
+                    s-&gt;callMethod(id, &quot;test&quot;, sts, template_vsc, 
+                                  static_cast&lt;bool&gt;(testoutputs), static_cast&lt;bool&gt;(testcosts));
+                    chunknums[s]= chunks_called;
+                    ++chunks_called;
+                }
+                else // all chunks processed, free server
+                {
+                    /* step 4 (once per slave) */
+                    s-&gt;getResults(); // learner deleted
+                    service.freeServer(s);
+                    --nservers;
+                }
+            }
+            else // get chunk result
+            {
+                PP&lt;VecStatsCollector&gt; vsc;
+                VMat chunkout, chunkcosts;
+
+                s-&gt;getResults(vsc, chunkout, chunkcosts);
+
+                int chunknum= chunknums[s];
+                if(curpos &lt; len) // more chunks to do, assign one to this server
+                {
+                    /* step 2 (repeat as needed) */
+                    int clen= min(chunksize, testset.length()-curpos);
+                    VMat sts= new RowsSubVMatrix(testset, curpos, clen);
+                    if(master_sends_testset_rows)
+                        sts= new MemoryVMatrix(sts.toMat());
+                    curpos+= clen;
+                    s-&gt;callMethod(learners_ids[s], &quot;test&quot;, sts, template_vsc, 
+                                  static_cast&lt;bool&gt;(testoutputs), static_cast&lt;bool&gt;(testcosts));
+                    chunknums[s]= chunks_called;
+                    ++chunks_called;
+                }
+                else // all chunks processed, delete learner form server
+                {
+                    /* step 3 (once per slave) */
+                    s-&gt;deleteObjectAsync(learners_ids[s]);
+                    learners_ids.erase(s);
+                }
+
+                // now merge chunk results w/ global results
+                if(test_stats)
+                {
+                    vscs[chunknum]= vsc;
+                    map&lt;int, PP&lt;VecStatsCollector&gt; &gt;::iterator it= vscs.find(last_chunknum+1);
+                    while(it != vscs.end())
+                    {
+                        ++last_chunknum;
+                        test_stats-&gt;merge(*(it-&gt;second));
+                        vscs.erase(it);
+                        it= vscs.find(last_chunknum+1);
+                    }
+                }
+
+                if(testoutputs)
+                    for(int i= 0, j= chunknum*chunksize; i &lt; chunksize &amp;&amp; j &lt; len; ++i, ++j)
+                        testoutputs-&gt;forcePutRow(j, chunkout-&gt;getRowVec(i));
+                if(testcosts)
+                    for(int i= 0, j= chunknum*chunksize; i &lt; chunksize &amp;&amp; j &lt; len; ++i, ++j)
+                        testcosts-&gt;forcePutRow(j, chunkcosts-&gt;getRowVec(i));
+            }
+        }
     }
+    else // Sequential test 
+    {
+        PP&lt;ProgressBar&gt; pb;
+        if (report_progress) 
+            pb = new ProgressBar(&quot;Testing learner&quot;, len);
+        for (int i = 0; i &lt; len; i++)
+        {
+            testset.getExample(i, input, target, weight);
+            // Always call computeOutputAndCosts, since this is better
+            // behaved with stateful learners
+            computeOutputAndCosts(input,target,output,costs);
+            if (testoutputs) testoutputs-&gt;putOrAppendRow(i, output);
+            if (testcosts) testcosts-&gt;putOrAppendRow(i, costs);
+            if (test_stats) test_stats-&gt;update(costs, weight);
+            if (report_progress) pb-&gt;update(i);
+        }
+    }
 
 }
 
+////////////////////////////////////////////////////////////////
+// test ('remote' version which returns a tuple w/ results.) //
+//////////////////////////////////////////////////////////////
+tuple&lt;PP&lt;VecStatsCollector&gt;, VMat, VMat&gt; PLearner::rtest(VMat testset, PP&lt;VecStatsCollector&gt; test_stats, bool rtestoutputs, bool rtestcosts) const
+{
+    VMat testoutputs= 0;
+    VMat testcosts= 0;
+    int outsize= outputsize();
+    int costsize= nTestCosts();
+    int len= testset.length();
+    if(rtestoutputs) testoutputs= new MemoryVMatrix(len, outsize);
+    if(rtestcosts) testcosts= new MemoryVMatrix(len, costsize);
+    if(test_stats &amp;&amp; test_stats-&gt;maxnvalues &gt; 0)
+        test_stats-&gt;maxnvalues= -1; // get all counts from a chunk
+    test(testset, test_stats, testoutputs, testcosts);
+    return make_tuple(test_stats, testoutputs, testcosts);
+}
+
+
+
 ///////////////
 // initTrain //
 ///////////////

Modified: trunk/plearn_learners/generic/PLearner.h
===================================================================
--- trunk/plearn_learners/generic/PLearner.h	2007-03-07 21:12:26 UTC (rev 6722)
+++ trunk/plearn_learners/generic/PLearner.h	2007-03-09 00:31:06 UTC (rev 6723)
@@ -6,6 +6,7 @@
 // Copyright (C) 1999-2002 Yoshua Bengio, Nicolas Chapados, Charles Dugas, Rejean Ducharme, Universite de Montreal
 // Copyright (C) 2001,2002 Francis Pieraut, Jean-Sebastien Senecal
 // Copyright (C) 2002 Frederic Morin, Xavier Saint-Mleux, Julien Keable
+// Copyright (C) 2007 Xavier Saint-Mleux, ApSTAT Technologies inc.
 // 
 // Redistribution and use in source and binary forms, with or without
 // modification, are permitted provided that the following conditions are met:
@@ -147,6 +148,7 @@
     /**
      *  Max number of computation servers to use in parallel with the main
      *  process.
+     *  DEPRECATED: use parallelize_here instead
      */
     int nservers; 
 
@@ -161,7 +163,19 @@
      *  the correct results.  (Default=&quot;&quot;, i.e. don't save anything.)
      */
     string save_trainingset_prefix;
-  
+
+    /**
+     * Wether parallelism should be exploited at this object's level
+     */
+    bool parallelize_here;
+
+    /**
+     * For PLearner::test in parallel:
+     * if true, the master reads the testset and sends rows to the slaves;
+     * otherwise, the master sends a description of the testset to the slaves
+     */
+    bool master_sends_testset_rows;
+
 protected:
 
     /**
@@ -530,6 +544,14 @@
                       VMat testoutputs=0, VMat testcosts=0) const;
 
     /**
+     *  &quot;remote&quot; test:
+     *  Performs test on testset, returns stats and optionally testoutputs and testcosts
+     */
+    virtual tuple&lt;PP&lt;VecStatsCollector&gt;, VMat, VMat&gt; rtest(VMat testset, PP&lt;VecStatsCollector&gt; test_stats,
+                                                      bool rtestoutputs, bool rtestcosts) const;
+    
+
+    /**
      * Process a full dataset (possibly containing input,target,weight,extra
      * parts). Returns processed view of that dataset. The default version
      * uses computeOutput to process the input part, and simply passes on

Modified: trunk/plearn_learners/generic/VPLPreprocessedLearner2.cc
===================================================================
--- trunk/plearn_learners/generic/VPLPreprocessedLearner2.cc	2007-03-07 21:12:26 UTC (rev 6722)
+++ trunk/plearn_learners/generic/VPLPreprocessedLearner2.cc	2007-03-09 00:31:06 UTC (rev 6723)
@@ -359,12 +359,12 @@
     initializeOutputPrograms();
 }
 
-
+/*
 void VPLPreprocessedLearner2::test(VMat testset, PP&lt;VecStatsCollector&gt; test_stats, VMat testoutputs, VMat testcosts) const
 {
 
     inherited::test(testset, test_stats, testoutputs, testcosts);
-
+*/
 /*
     VMat filtered_testset = testset;
     PPath filtered_testset_metadatadir = getExperimentDirectory() / &quot;filtered_test_set.metadata&quot;;
@@ -440,7 +440,9 @@
             pb-&gt;update(i);
     }
 */
+/*
 }
+*/
 
 
 

Modified: trunk/plearn_learners/generic/VPLPreprocessedLearner2.h
===================================================================
--- trunk/plearn_learners/generic/VPLPreprocessedLearner2.h	2007-03-07 21:12:26 UTC (rev 6722)
+++ trunk/plearn_learners/generic/VPLPreprocessedLearner2.h	2007-03-09 00:31:06 UTC (rev 6723)
@@ -180,7 +180,7 @@
 
     virtual void train();
 
-    virtual void test(VMat testset, PP&lt;VecStatsCollector&gt; test_stats, VMat testoutputs, VMat testcosts) const;
+    //virtual void test(VMat testset, PP&lt;VecStatsCollector&gt; test_stats, VMat testoutputs, VMat testcosts) const;
 
     virtual void computeOutput(const Vec&amp; input, Vec&amp; output) const;
 

Modified: trunk/plearn_learners/testers/PTester.cc
===================================================================
--- trunk/plearn_learners/testers/PTester.cc	2007-03-07 21:12:26 UTC (rev 6722)
+++ trunk/plearn_learners/testers/PTester.cc	2007-03-09 00:31:06 UTC (rev 6723)
@@ -1048,11 +1048,11 @@
 
 
     PLearnService&amp; service(PLearnService::instance());
-    TVec&lt;PP&lt;RemotePLearnServer&gt; &gt; servers= service.reserveServers(nsplits);
-    int nservers= servers.length();
+    int nservers= min(nsplits, service.availableServers());
 
     if(nservers &gt; 1 &amp;&amp; parallelize_here &amp;&amp; (!should_train || call_forget))
     {
+        TVec&lt;PP&lt;RemotePLearnServer&gt; &gt; servers= service.reserveServers(nsplits);
         map&lt;PP&lt;RemotePLearnServer&gt;, int&gt; testers_ids;
         map&lt;PP&lt;RemotePLearnServer&gt;, int&gt; splitnums;
         for (int splitnum= 0; splitnum &lt; nservers &amp;&amp; splitnum &lt; nsplits; ++splitnum)

Modified: trunk/python_modules/plearn/pymake/pymake.py
===================================================================
--- trunk/python_modules/plearn/pymake/pymake.py	2007-03-07 21:12:26 UTC (rev 6722)
+++ trunk/python_modules/plearn/pymake/pymake.py	2007-03-09 00:31:06 UTC (rev 6723)
@@ -2612,6 +2612,7 @@
     for target in otherargs:
         configpath = get_config_path(target)
         execfile( configpath, globals() )
+
         # remove duplicates from sourcedirs
         sourcedirs = unique(sourcedirs)
 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000171.html">[Plearn-commits] r6722 - trunk/plearn/io
</A></li>
	<LI>Next message: <A HREF="000173.html">[Plearn-commits] r6724 - in	trunk/plearn/math/test/VecStatsCollector/.pytest/PL_constant_regressor_script/expected_results/expdir:	. Split0 Split0/test1_confidence.pmat.metadata	Split0/test1_costs.pmat.metadata	Split0/test1_outputs.pmat.metadata global_stats.pmat.metadata	split_stats.pmat.metadata
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#172">[ date ]</a>
              <a href="thread.html#172">[ thread ]</a>
              <a href="subject.html#172">[ subject ]</a>
              <a href="author.html#172">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/plearn-commits">More information about the Plearn-commits
mailing list</a><br>
</body></html>
