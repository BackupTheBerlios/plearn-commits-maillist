<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Plearn-commits] r8601 - trunk/plearn_learners/online
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/plearn-commits/2008-February/index.html" >
   <LINK REL="made" HREF="mailto:plearn-commits%40lists.berlios.de?Subject=Re%3A%20%5BPlearn-commits%5D%20r8601%20-%20trunk/plearn_learners/online&In-Reply-To=%3C200802282214.m1SME5Qx027472%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002048.html">
   <LINK REL="Next"  HREF="002050.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Plearn-commits] r8601 - trunk/plearn_learners/online</H1>
    <B>larocheh at BerliOS</B> 
    <A HREF="mailto:plearn-commits%40lists.berlios.de?Subject=Re%3A%20%5BPlearn-commits%5D%20r8601%20-%20trunk/plearn_learners/online&In-Reply-To=%3C200802282214.m1SME5Qx027472%40sheep.berlios.de%3E"
       TITLE="[Plearn-commits] r8601 - trunk/plearn_learners/online">larocheh at mail.berlios.de
       </A><BR>
    <I>Thu Feb 28 23:14:05 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="002048.html">[Plearn-commits] r8600 - trunk/plearn/var
</A></li>
        <LI>Next message: <A HREF="002050.html">[Plearn-commits] r8602 - trunk/plearn_learners_experimental
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2049">[ date ]</a>
              <a href="thread.html#2049">[ thread ]</a>
              <a href="subject.html#2049">[ subject ]</a>
              <a href="author.html#2049">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: larocheh
Date: 2008-02-28 23:14:04 +0100 (Thu, 28 Feb 2008)
New Revision: 8601

Modified:
   trunk/plearn_learners/online/RBMLateralBinomialLayer.cc
   trunk/plearn_learners/online/RBMLateralBinomialLayer.h
Log:
Added an option to train a parametric mean-field approximator...


Modified: trunk/plearn_learners/online/RBMLateralBinomialLayer.cc
===================================================================
--- trunk/plearn_learners/online/RBMLateralBinomialLayer.cc	2008-02-28 19:37:18 UTC (rev 8600)
+++ trunk/plearn_learners/online/RBMLateralBinomialLayer.cc	2008-02-28 22:14:04 UTC (rev 8601)
@@ -60,7 +60,8 @@
     topographic_patch_vradius( 5 ),
     topographic_patch_hradius( 5 ),
     topographic_lateral_weights_init_value( 0. ),
-    do_not_learn_topographic_lateral_weights( false )
+    do_not_learn_topographic_lateral_weights( false ),
+    use_parametric_mean_field( false )
 {
 }
 
@@ -100,6 +101,13 @@
     for( int i=0; i&lt;topographic_lateral_weights.length(); i++ )
         //topographic_lateral_weights[i].clear();
         topographic_lateral_weights[i].fill( topographic_lateral_weights_init_value );
+
+    mean_field_output_weights.clear();
+    for( int i=0; i&lt;mean_field_output_weights.length(); i++ )
+        mean_field_output_weights(i,i) = 1;
+    for( int i=0; i&lt;mean_field_output_bias.length(); i++ )
+        mean_field_output_bias[i] = -0.5;
+    
 }
 
 ////////////////////
@@ -114,8 +122,7 @@
             &quot;before calling generateSample()&quot;);
 
     for( int i=0 ; i&lt;size ; i++ )
-        sample[i] = random_gen-&gt;binomial_sample( expectation[i] );
-    
+        sample[i] = random_gen-&gt;binomial_sample( expectation[i] );    
 }
 
 /////////////////////
@@ -145,73 +152,115 @@
     if( expectation_is_up_to_date )
         return;
 
-    if( temp_output.length() != n_lateral_connections_passes+1 )
+    if( use_parametric_mean_field )
     {
-        temp_output.resize(n_lateral_connections_passes+1);
-        for( int i=0 ; i&lt;n_lateral_connections_passes+1 ; i++ )
-            temp_output[i].resize(size);
-    }       
+        if (use_fast_approximations)
+            for( int i=0 ; i&lt;size ; i++ )
+                mean_field_input[i] = fastsigmoid( activation[i] );
+        else
+            for( int i=0 ; i&lt;size ; i++ )
+                mean_field_input[i] = sigmoid( activation[i] );
+        
+        product(pre_sigmoid_mean_field_output, mean_field_output_weights, mean_field_input);
+        pre_sigmoid_mean_field_output += mean_field_output_bias;
 
-    current_temp_output = temp_output[0];
-    temp_output.last() = expectation;
+        if (use_fast_approximations)
+            for( int i=0 ; i&lt;size ; i++ )
+                expectation[i] = fastsigmoid( pre_sigmoid_mean_field_output[i] );
+        else
+            for( int i=0 ; i&lt;size ; i++ )
+                expectation[i] = sigmoid( pre_sigmoid_mean_field_output[i] );
 
-    if (use_fast_approximations)
+        // Update mean-field predictor, using KL-divergence gradient:
+        //   dKL/dp_i = -activation[i] - \sum_{j \neq i} p_j + V_i h
+        // where - V_i is the ith row of mean_field_output_weights
+        //       - h is sigmoid(activation)
+
+        real mean_field_i;
+        product(temp_mean_field_gradient, lateral_weights, expectation);
+        temp_mean_field_gradient += activation;
         for( int i=0 ; i&lt;size ; i++ )
-            current_temp_output[i] = fastsigmoid( activation[i] );
+        {
+            mean_field_i = expectation[i];
+            temp_mean_field_gradient[i] = (pre_sigmoid_mean_field_output[i] 
+                                           - temp_mean_field_gradient[i]) 
+                * mean_field_i * (1 - mean_field_i);
+        }
+
+        externalProductScaleAcc( mean_field_output_weights, temp_mean_field_gradient, 
+                                 mean_field_input, -learning_rate );
+        multiplyScaledAdd( temp_mean_field_gradient, 1.0, -learning_rate, mean_field_output_bias);
+    }
     else
-        for( int i=0 ; i&lt;size ; i++ )
-            current_temp_output[i] = sigmoid( activation[i] );
-
-    for( int t=0; t&lt;n_lateral_connections_passes; t++ )
-    {
-        previous_temp_output = current_temp_output;
-        current_temp_output = temp_output[t+1];
-        if( topographic_lateral_weights.length() == 0 )
-            product(dampening_expectation, lateral_weights, previous_temp_output);
+    {        
+        if( temp_output.length() != n_lateral_connections_passes+1 )
+        {
+            temp_output.resize(n_lateral_connections_passes+1);
+            for( int i=0 ; i&lt;n_lateral_connections_passes+1 ; i++ )
+                temp_output[i].resize(size);
+        }       
+        
+        current_temp_output = temp_output[0];
+        temp_output.last() = expectation;
+        
+        if (use_fast_approximations)
+            for( int i=0 ; i&lt;size ; i++ )
+                current_temp_output[i] = fastsigmoid( activation[i] );
         else
-            productTopoLateralWeights( dampening_expectation, previous_temp_output );
-        dampening_expectation += activation;
-        if (use_fast_approximations)
+            for( int i=0 ; i&lt;size ; i++ )
+                current_temp_output[i] = sigmoid( activation[i] );
+        
+        for( int t=0; t&lt;n_lateral_connections_passes; t++ )
         {
-            if( fast_exact_is_equal( dampening_factor, 0) )
+            previous_temp_output = current_temp_output;
+            current_temp_output = temp_output[t+1];
+            if( topographic_lateral_weights.length() == 0 )
+                product(dampening_expectation, lateral_weights, previous_temp_output);
+            else
+                productTopoLateralWeights( dampening_expectation, previous_temp_output );
+            dampening_expectation += activation;
+            if (use_fast_approximations)
             {
-                for( int i=0 ; i&lt;size ; i++ )
-                    current_temp_output[i] = fastsigmoid( dampening_expectation[i] );
+                if( fast_exact_is_equal( dampening_factor, 0) )
+                {
+                    for( int i=0 ; i&lt;size ; i++ )
+                        current_temp_output[i] = fastsigmoid( dampening_expectation[i] );
+                }
+                else
+                {
+                    for( int i=0 ; i&lt;size ; i++ )
+                        current_temp_output[i] = 
+                            (1-dampening_factor) * fastsigmoid( dampening_expectation[i] ) 
+                            + dampening_factor * previous_temp_output[i];
+                }
             }
             else
             {
-                for( int i=0 ; i&lt;size ; i++ )
-                    current_temp_output[i] = 
-                        (1-dampening_factor) * fastsigmoid( dampening_expectation[i] ) 
-                        + dampening_factor * previous_temp_output[i];
+                if( fast_exact_is_equal( dampening_factor, 0) )
+                {
+                    for( int i=0 ; i&lt;size ; i++ )
+                        current_temp_output[i] = sigmoid( dampening_expectation[i] );
+                }
+                else
+                {
+                    for( int i=0 ; i&lt;size ; i++ )
+                        current_temp_output[i] = 
+                            (1-dampening_factor) * sigmoid( dampening_expectation[i] ) 
+                            + dampening_factor * previous_temp_output[i];
+                }
             }
-        }
-        else
-        {
-            if( fast_exact_is_equal( dampening_factor, 0) )
+            if( !fast_exact_is_equal(mean_field_precision_threshold, 0.) &amp;&amp; 
+                dist(current_temp_output, previous_temp_output,2)/size &lt; mean_field_precision_threshold )
             {
-                for( int i=0 ; i&lt;size ; i++ )
-                    current_temp_output[i] = sigmoid( dampening_expectation[i] );
+                expectation &lt;&lt; current_temp_output;
+                break;
             }
-            else
-            {
-                for( int i=0 ; i&lt;size ; i++ )
-                    current_temp_output[i] = 
-                        (1-dampening_factor) * sigmoid( dampening_expectation[i] ) 
-                        + dampening_factor * previous_temp_output[i];
-            }
+            //cout &lt;&lt; sqrt(max(square(current_temp_output-previous_temp_output))) &lt;&lt; &quot; &quot;;
+            //cout &lt;&lt; dist(current_temp_output, previous_temp_output,2)/current_temp_output.length() &lt;&lt; &quot; &quot;;
         }
-        if( !fast_exact_is_equal(mean_field_precision_threshold, 0.) &amp;&amp; 
-            dist(current_temp_output, previous_temp_output,2)/size &lt; mean_field_precision_threshold )
-        {
-            expectation &lt;&lt; current_temp_output;
-            break;
-        }
-        //cout &lt;&lt; sqrt(max(square(current_temp_output-previous_temp_output))) &lt;&lt; &quot; &quot;;
-        //cout &lt;&lt; dist(current_temp_output, previous_temp_output,2)/current_temp_output.length() &lt;&lt; &quot; &quot;;
+        //cout &lt;&lt; endl;
+        //expectation &lt;&lt; current_temp_output;
     }
-    //cout &lt;&lt; endl;
-    //expectation &lt;&lt; current_temp_output;
     expectation_is_up_to_date = true;
 }
 
@@ -225,78 +274,87 @@
 
     PLASSERT( expectations.width() == size
               &amp;&amp; expectations.length() == batch_size );
-    dampening_expectations.resize( batch_size, size );
 
-    if( temp_outputs.length() != n_lateral_connections_passes+1 )
+    if( use_parametric_mean_field )
     {
-        temp_outputs.resize(n_lateral_connections_passes+1);
-        for( int i=0 ; i&lt;n_lateral_connections_passes+1 ; i++ )
-            temp_outputs[i].resize( batch_size, size);
-    }       
-
-    current_temp_outputs = temp_outputs[0];
-    temp_outputs.last() = expectations;
-
-    if (use_fast_approximations)
-        for (int k = 0; k &lt; batch_size; k++)
-            for (int i = 0 ; i &lt; size ; i++)
-                current_temp_outputs(k, i) = fastsigmoid(activations(k, i));
+        PLERROR(&quot;RBMLateralBinomialLayer::computeExpectations(): use_parametric_mean_field=true &quot;
+            &quot;not implemented yet.&quot;);
+    }
     else
-        for (int k = 0; k &lt; batch_size; k++)
-            for (int i = 0 ; i &lt; size ; i++)
-                current_temp_outputs(k, i) = sigmoid(activations(k, i));
-
-    for( int t=0; t&lt;n_lateral_connections_passes; t++ )
     {
-        previous_temp_outputs = current_temp_outputs;
-        current_temp_outputs = temp_outputs[t+1];
-        if( topographic_lateral_weights.length() == 0 )
-            productTranspose(dampening_expectations, previous_temp_outputs, 
-                             lateral_weights);
+        dampening_expectations.resize( batch_size, size );
+        
+        if( temp_outputs.length() != n_lateral_connections_passes+1 )
+        {
+            temp_outputs.resize(n_lateral_connections_passes+1);
+            for( int i=0 ; i&lt;n_lateral_connections_passes+1 ; i++ )
+                temp_outputs[i].resize( batch_size, size);
+        }       
+        
+        current_temp_outputs = temp_outputs[0];
+        temp_outputs.last() = expectations;
+        
+        if (use_fast_approximations)
+            for (int k = 0; k &lt; batch_size; k++)
+                for (int i = 0 ; i &lt; size ; i++)
+                    current_temp_outputs(k, i) = fastsigmoid(activations(k, i));
         else
-            for( int b = 0; b&lt;dampening_expectations.length(); b++)
-                productTopoLateralWeights( dampening_expectations(b), 
-                                           previous_temp_outputs(b) );
+            for (int k = 0; k &lt; batch_size; k++)
+                for (int i = 0 ; i &lt; size ; i++)
+                    current_temp_outputs(k, i) = sigmoid(activations(k, i));
 
-        dampening_expectations += activations;
-        if (use_fast_approximations)
+        for( int t=0; t&lt;n_lateral_connections_passes; t++ )
         {
-            if( fast_exact_is_equal( dampening_factor, 0) )
-            {
-                for(int k = 0; k &lt; batch_size; k++)
-                    for( int i=0 ; i&lt;size ; i++ )
-                        current_temp_outputs(k, i) = 
-                            fastsigmoid( dampening_expectations(k, i) );
-            }
+            previous_temp_outputs = current_temp_outputs;
+            current_temp_outputs = temp_outputs[t+1];
+            if( topographic_lateral_weights.length() == 0 )
+                productTranspose(dampening_expectations, previous_temp_outputs, 
+                                 lateral_weights);
             else
+                for( int b = 0; b&lt;dampening_expectations.length(); b++)
+                    productTopoLateralWeights( dampening_expectations(b), 
+                                               previous_temp_outputs(b) );
+
+            dampening_expectations += activations;
+            if (use_fast_approximations)
             {
-                for(int k = 0; k &lt; batch_size; k++)
-                    for( int i=0 ; i&lt;size ; i++ )
-                        current_temp_outputs(k, i) = (1-dampening_factor)
-                            * fastsigmoid( dampening_expectations(k, i) ) 
-                            + dampening_factor * previous_temp_outputs(k, i);
+                if( fast_exact_is_equal( dampening_factor, 0) )
+                {
+                    for(int k = 0; k &lt; batch_size; k++)
+                        for( int i=0 ; i&lt;size ; i++ )
+                            current_temp_outputs(k, i) = 
+                                fastsigmoid( dampening_expectations(k, i) );
+                }
+                else
+                {
+                    for(int k = 0; k &lt; batch_size; k++)
+                        for( int i=0 ; i&lt;size ; i++ )
+                            current_temp_outputs(k, i) = (1-dampening_factor)
+                                * fastsigmoid( dampening_expectations(k, i) ) 
+                                + dampening_factor * previous_temp_outputs(k, i);
+                }
             }
-        }
-        else
-        {
-            if( fast_exact_is_equal( dampening_factor, 0) )
-            {
-                for(int k = 0; k &lt; batch_size; k++)
-                    for( int i=0 ; i&lt;size ; i++ )
-                        current_temp_outputs(k, i) = 
-                            sigmoid( dampening_expectations(k, i) );
-            }
             else
             {
-                for(int k = 0; k &lt; batch_size; k++)
-                    for( int i=0 ; i&lt;size ; i++ )
-                        current_temp_outputs(k, i) = (1-dampening_factor) 
-                            * sigmoid( dampening_expectations(k, i) ) 
-                            + dampening_factor * previous_temp_outputs(k, i);
+                if( fast_exact_is_equal( dampening_factor, 0) )
+                {
+                    for(int k = 0; k &lt; batch_size; k++)
+                        for( int i=0 ; i&lt;size ; i++ )
+                            current_temp_outputs(k, i) = 
+                                sigmoid( dampening_expectations(k, i) );
+                }
+                else
+                {
+                    for(int k = 0; k &lt; batch_size; k++)
+                        for( int i=0 ; i&lt;size ; i++ )
+                            current_temp_outputs(k, i) = (1-dampening_factor) 
+                                * sigmoid( dampening_expectations(k, i) ) 
+                                + dampening_factor * previous_temp_outputs(k, i);
+                }
             }
         }
+        //expectations &lt;&lt; current_temp_outputs;
     }
-    //expectations &lt;&lt; current_temp_outputs;
     expectations_are_up_to_date = true;
 }
 
@@ -310,60 +368,83 @@
 
     add(bias, input, bias_plus_input);
 
-    if( temp_output.length() != n_lateral_connections_passes+1 )
+    if( use_parametric_mean_field )
     {
-        temp_output.resize(n_lateral_connections_passes+1);
-        for( int i=0 ; i&lt;n_lateral_connections_passes+1 ; i++ )
-            temp_output[i].resize(size);
-    }       
+        if (use_fast_approximations)
+            for( int i=0 ; i&lt;size ; i++ )
+                mean_field_input[i] = fastsigmoid( bias_plus_input[i] );
+        else
+            for( int i=0 ; i&lt;size ; i++ )
+                mean_field_input[i] = sigmoid( bias_plus_input[i] );
+        
+        product(pre_sigmoid_mean_field_output, mean_field_output_weights, mean_field_input);
+        pre_sigmoid_mean_field_output += mean_field_output_bias;
 
-    temp_output.last() = output;
-    current_temp_output = temp_output[0];
-
-    if (use_fast_approximations)
-        for( int i=0 ; i&lt;size ; i++ )
-            current_temp_output[i] = fastsigmoid( bias_plus_input[i] );
+        if (use_fast_approximations)
+            for( int i=0 ; i&lt;size ; i++ )
+                output[i] = fastsigmoid( pre_sigmoid_mean_field_output[i] );
+        else
+            for( int i=0 ; i&lt;size ; i++ )
+                output[i] = sigmoid( pre_sigmoid_mean_field_output[i] );
+    }
     else
-        for( int i=0 ; i&lt;size ; i++ )
-            current_temp_output[i] = sigmoid( bias_plus_input[i] );
+    {        
 
-    for( int t=0; t&lt;n_lateral_connections_passes; t++ )
-    {
-        previous_temp_output = current_temp_output;
-        current_temp_output = temp_output[t+1];
-        if( topographic_lateral_weights.length() == 0 )
-            product(dampening_expectation, lateral_weights, previous_temp_output);
+        if( temp_output.length() != n_lateral_connections_passes+1 )
+        {
+            temp_output.resize(n_lateral_connections_passes+1);
+            for( int i=0 ; i&lt;n_lateral_connections_passes+1 ; i++ )
+                temp_output[i].resize(size);
+        }       
+
+        temp_output.last() = output;
+        current_temp_output = temp_output[0];
+
+        if (use_fast_approximations)
+            for( int i=0 ; i&lt;size ; i++ )
+                current_temp_output[i] = fastsigmoid( bias_plus_input[i] );
         else
-            productTopoLateralWeights( dampening_expectation, previous_temp_output );
-        dampening_expectation += bias_plus_input;
-        if (use_fast_approximations)
+            for( int i=0 ; i&lt;size ; i++ )
+                current_temp_output[i] = sigmoid( bias_plus_input[i] );
+
+        for( int t=0; t&lt;n_lateral_connections_passes; t++ )
         {
-            if( fast_exact_is_equal( dampening_factor, 0) )
-            {
-                for( int i=0 ; i&lt;size ; i++ )
-                    current_temp_output[i] = fastsigmoid( dampening_expectation[i] );
-            }
+            previous_temp_output = current_temp_output;
+            current_temp_output = temp_output[t+1];
+            if( topographic_lateral_weights.length() == 0 )
+                product(dampening_expectation, lateral_weights, previous_temp_output);
             else
+                productTopoLateralWeights( dampening_expectation, previous_temp_output );
+            dampening_expectation += bias_plus_input;
+            if (use_fast_approximations)
             {
-                for( int i=0 ; i&lt;size ; i++ )
-                    current_temp_output[i] = 
-                        (1-dampening_factor) * fastsigmoid( dampening_expectation[i] ) 
-                        + dampening_factor * previous_temp_output[i];
+                if( fast_exact_is_equal( dampening_factor, 0) )
+                {
+                    for( int i=0 ; i&lt;size ; i++ )
+                        current_temp_output[i] = fastsigmoid( dampening_expectation[i] );
+                }
+                else
+                {
+                    for( int i=0 ; i&lt;size ; i++ )
+                        current_temp_output[i] = 
+                            (1-dampening_factor) * fastsigmoid( dampening_expectation[i] ) 
+                            + dampening_factor * previous_temp_output[i];
+                }
             }
-        }
-        else
-        {
-            if( fast_exact_is_equal( dampening_factor, 0) )
-            {
-                for( int i=0 ; i&lt;size ; i++ )
-                    current_temp_output[i] = sigmoid( dampening_expectation[i] );
-            }
             else
             {
-                for( int i=0 ; i&lt;size ; i++ )
-                    current_temp_output[i] = 
-                        (1-dampening_factor) * sigmoid( dampening_expectation[i] ) 
-                        + dampening_factor * previous_temp_output[i];
+                if( fast_exact_is_equal( dampening_factor, 0) )
+                {
+                    for( int i=0 ; i&lt;size ; i++ )
+                        current_temp_output[i] = sigmoid( dampening_expectation[i] );
+                }
+                else
+                {
+                    for( int i=0 ; i&lt;size ; i++ )
+                        current_temp_output[i] = 
+                            (1-dampening_factor) * sigmoid( dampening_expectation[i] ) 
+                            + dampening_factor * previous_temp_output[i];
+                }
             }
         }
     }
@@ -374,80 +455,89 @@
     int mbatch_size = inputs.length();
     PLASSERT( inputs.width() == size );
     outputs.resize( mbatch_size, size );
+
     dampening_expectations.resize( mbatch_size, size );
 
-    if(bias_plus_inputs.length() != inputs.length() ||
-       bias_plus_inputs.width() != inputs.width())
-        bias_plus_inputs.resize(inputs.length(), inputs.width());
-    bias_plus_inputs &lt;&lt; inputs;
-    bias_plus_inputs += bias;
-
-    if( temp_outputs.length() != n_lateral_connections_passes+1 )
+    if( use_parametric_mean_field )
     {
-        temp_outputs.resize(n_lateral_connections_passes+1);
-        for( int i=0 ; i&lt;n_lateral_connections_passes+1 ; i++ )
-            temp_outputs[i].resize(mbatch_size,size);
-    }       
+        PLERROR(&quot;RBMLateralBinomialLayer::fprop: use_parametric_mean_field = true &quot;
+            &quot;not implemented yet for batch mode.&quot;);
+    }
+    else
+    {
+        if(bias_plus_inputs.length() != inputs.length() ||
+           bias_plus_inputs.width() != inputs.width())
+            bias_plus_inputs.resize(inputs.length(), inputs.width());
+        bias_plus_inputs &lt;&lt; inputs;
+        bias_plus_inputs += bias;
 
-    temp_outputs.last() = outputs;
-    current_temp_outputs = temp_outputs[0];
+        if( temp_outputs.length() != n_lateral_connections_passes+1 )
+        {
+            temp_outputs.resize(n_lateral_connections_passes+1);
+            for( int i=0 ; i&lt;n_lateral_connections_passes+1 ; i++ )
+                temp_outputs[i].resize(mbatch_size,size);
+        }       
 
-    if (use_fast_approximations)
-        for( int k = 0; k &lt; mbatch_size; k++ )
-            for( int i = 0; i &lt; size; i++ )
-                current_temp_outputs(k,i) = fastsigmoid( bias_plus_inputs(k,i) );
-    else
-        for( int k = 0; k &lt; mbatch_size; k++ )
-            for( int i = 0; i &lt; size; i++ )
-                current_temp_outputs(k,i) = sigmoid( bias_plus_inputs(k,i) );
+        temp_outputs.last() = outputs;
+        current_temp_outputs = temp_outputs[0];
 
-    for( int t=0; t&lt;n_lateral_connections_passes; t++ )
-    {
-        previous_temp_outputs = current_temp_outputs;
-        current_temp_outputs = temp_outputs[t+1];
-        if( topographic_lateral_weights.length() == 0 )
-            productTranspose(dampening_expectations, previous_temp_outputs, 
-                             lateral_weights);
+        if (use_fast_approximations)
+            for( int k = 0; k &lt; mbatch_size; k++ )
+                for( int i = 0; i &lt; size; i++ )
+                    current_temp_outputs(k,i) = fastsigmoid( bias_plus_inputs(k,i) );
         else
-            for( int b = 0; b&lt;dampening_expectations.length(); b++)
-                productTopoLateralWeights( dampening_expectations(b), 
-                                           previous_temp_outputs(b) );
+            for( int k = 0; k &lt; mbatch_size; k++ )
+                for( int i = 0; i &lt; size; i++ )
+                    current_temp_outputs(k,i) = sigmoid( bias_plus_inputs(k,i) );
 
-        dampening_expectations += bias_plus_inputs;
-        if (use_fast_approximations)
+        for( int t=0; t&lt;n_lateral_connections_passes; t++ )
         {
-            if( fast_exact_is_equal( dampening_factor, 0) )
-            {
-                for(int k = 0; k &lt; batch_size; k++)
-                    for( int i=0 ; i&lt;size ; i++ )
-                        current_temp_outputs(k, i) = 
-                            fastsigmoid( dampening_expectations(k, i) );
-            }
+            previous_temp_outputs = current_temp_outputs;
+            current_temp_outputs = temp_outputs[t+1];
+            if( topographic_lateral_weights.length() == 0 )
+                productTranspose(dampening_expectations, previous_temp_outputs, 
+                                 lateral_weights);
             else
+                for( int b = 0; b&lt;dampening_expectations.length(); b++)
+                    productTopoLateralWeights( dampening_expectations(b), 
+                                               previous_temp_outputs(b) );
+
+            dampening_expectations += bias_plus_inputs;
+            if (use_fast_approximations)
             {
-                for(int k = 0; k &lt; batch_size; k++)
-                    for( int i=0 ; i&lt;size ; i++ )
-                        current_temp_outputs(k, i) = (1-dampening_factor)
-                            * fastsigmoid( dampening_expectations(k, i) ) 
-                            + dampening_factor * previous_temp_outputs(k, i);
+                if( fast_exact_is_equal( dampening_factor, 0) )
+                {
+                    for(int k = 0; k &lt; batch_size; k++)
+                        for( int i=0 ; i&lt;size ; i++ )
+                            current_temp_outputs(k, i) = 
+                                fastsigmoid( dampening_expectations(k, i) );
+                }
+                else
+                {
+                    for(int k = 0; k &lt; batch_size; k++)
+                        for( int i=0 ; i&lt;size ; i++ )
+                            current_temp_outputs(k, i) = (1-dampening_factor)
+                                * fastsigmoid( dampening_expectations(k, i) ) 
+                                + dampening_factor * previous_temp_outputs(k, i);
+                }
             }
-        }
-        else
-        {
-            if( fast_exact_is_equal( dampening_factor, 0) )
-            {
-                for(int k = 0; k &lt; batch_size; k++)
-                    for( int i=0 ; i&lt;size ; i++ )
-                        current_temp_outputs(k, i) = 
-                            sigmoid( dampening_expectations(k, i) );
-            }
             else
             {
-                for(int k = 0; k &lt; batch_size; k++)
-                    for( int i=0 ; i&lt;size ; i++ )
-                        current_temp_outputs(k, i) = (1-dampening_factor)
-                            * sigmoid( dampening_expectations(k, i) ) 
-                            + dampening_factor * previous_temp_outputs(k, i);
+                if( fast_exact_is_equal( dampening_factor, 0) )
+                {
+                    for(int k = 0; k &lt; batch_size; k++)
+                        for( int i=0 ; i&lt;size ; i++ )
+                            current_temp_outputs(k, i) = 
+                                sigmoid( dampening_expectations(k, i) );
+                }
+                else
+                {
+                    for(int k = 0; k &lt; batch_size; k++)
+                        for( int i=0 ; i&lt;size ; i++ )
+                            current_temp_outputs(k, i) = (1-dampening_factor)
+                                * sigmoid( dampening_expectations(k, i) ) 
+                                + dampening_factor * previous_temp_outputs(k, i);
+                }
             }
         }
     }
@@ -462,60 +552,69 @@
 
     add(rbm_bias, input, bias_plus_input);
 
-        if( temp_output.length() != n_lateral_connections_passes+1 )
+    if( use_parametric_mean_field )
     {
-        temp_output.resize(n_lateral_connections_passes+1);
-        for( int i=0 ; i&lt;n_lateral_connections_passes+1 ; i++ )
-            temp_output[i].resize(size);
-    }       
+        PLERROR(&quot;RBMLateralBinomialLayer::fprop: use_parametric_mean_field = true &quot;
+            &quot;not implemented yet for rbm_bias input.&quot;);
+    }
+    else
+    {
 
-    temp_output.last() = output;
-    current_temp_output = temp_output[0];
+        if( temp_output.length() != n_lateral_connections_passes+1 )
+        {
+            temp_output.resize(n_lateral_connections_passes+1);
+            for( int i=0 ; i&lt;n_lateral_connections_passes+1 ; i++ )
+                temp_output[i].resize(size);
+        }       
 
-    if (use_fast_approximations)
-        for( int i=0 ; i&lt;size ; i++ )
-            current_temp_output[i] = fastsigmoid( bias_plus_input[i] );
-    else
-        for( int i=0 ; i&lt;size ; i++ )
-            current_temp_output[i] = sigmoid( bias_plus_input[i] );
+        temp_output.last() = output;
+        current_temp_output = temp_output[0];
 
-    for( int t=0; t&lt;n_lateral_connections_passes; t++ )
-    {
-        previous_temp_output = current_temp_output;
-        current_temp_output = temp_output[t+1];
-        if( topographic_lateral_weights.length() == 0 )
-            product(dampening_expectation, lateral_weights, previous_temp_output);
+        if (use_fast_approximations)
+            for( int i=0 ; i&lt;size ; i++ )
+                current_temp_output[i] = fastsigmoid( bias_plus_input[i] );
         else
-            productTopoLateralWeights( dampening_expectation, previous_temp_output );
-        dampening_expectation += bias_plus_input;
-        if (use_fast_approximations)
+            for( int i=0 ; i&lt;size ; i++ )
+                current_temp_output[i] = sigmoid( bias_plus_input[i] );
+
+        for( int t=0; t&lt;n_lateral_connections_passes; t++ )
         {
-            if( fast_exact_is_equal( dampening_factor, 0) )
-            {
-                for( int i=0 ; i&lt;size ; i++ )
-                    current_temp_output[i] = fastsigmoid( dampening_expectation[i] );
-            }
+            previous_temp_output = current_temp_output;
+            current_temp_output = temp_output[t+1];
+            if( topographic_lateral_weights.length() == 0 )
+                product(dampening_expectation, lateral_weights, previous_temp_output);
             else
+                productTopoLateralWeights( dampening_expectation, previous_temp_output );
+            dampening_expectation += bias_plus_input;
+            if (use_fast_approximations)
             {
-                for( int i=0 ; i&lt;size ; i++ )
-                    current_temp_output[i] = 
-                        (1-dampening_factor) * fastsigmoid( dampening_expectation[i] ) 
-                        + dampening_factor * previous_temp_output[i];
+                if( fast_exact_is_equal( dampening_factor, 0) )
+                {
+                    for( int i=0 ; i&lt;size ; i++ )
+                        current_temp_output[i] = fastsigmoid( dampening_expectation[i] );
+                }
+                else
+                {
+                    for( int i=0 ; i&lt;size ; i++ )
+                        current_temp_output[i] = 
+                            (1-dampening_factor) * fastsigmoid( dampening_expectation[i] ) 
+                            + dampening_factor * previous_temp_output[i];
+                }
             }
-        }
-        else
-        {
-            if( fast_exact_is_equal( dampening_factor, 0) )
-            {
-                for( int i=0 ; i&lt;size ; i++ )
-                    current_temp_output[i] = sigmoid( dampening_expectation[i] );
-            }
             else
             {
-                for( int i=0 ; i&lt;size ; i++ )
-                    current_temp_output[i] = 
-                        (1-dampening_factor) * sigmoid( dampening_expectation[i] ) 
-                        + dampening_factor * previous_temp_output[i];
+                if( fast_exact_is_equal( dampening_factor, 0) )
+                {
+                    for( int i=0 ; i&lt;size ; i++ )
+                        current_temp_output[i] = sigmoid( dampening_expectation[i] );
+                }
+                else
+                {
+                    for( int i=0 ; i&lt;size ; i++ )
+                        current_temp_output[i] = 
+                            (1-dampening_factor) * sigmoid( dampening_expectation[i] ) 
+                            + dampening_factor * previous_temp_output[i];
+                }
             }
         }
     }
@@ -763,120 +862,145 @@
     //if( momentum != 0. )
     //    bias_inc.resize( size );
 
-    temp_input_gradient.clear();
-    temp_mean_field_gradient &lt;&lt; output_gradient;
-    current_temp_output = output;
-    lateral_weights_gradient.clear();
-    for( int i=0; i&lt;topographic_lateral_weights_gradient.length(); i++)
-        topographic_lateral_weights_gradient[i].clear();
-
-    real output_i;
-    for( int t=n_lateral_connections_passes-1 ; t&gt;=0 ; t-- )
+    if( use_parametric_mean_field )
     {
+        real mean_field_i;
         for( int i=0 ; i&lt;size ; i++ )
         {
-            output_i = current_temp_output[i];
-
-            // Contribution from the mean field approximation
-            temp_mean_field_gradient2[i] =  (1-dampening_factor)*
-                output_i * (1-output_i) * temp_mean_field_gradient[i];
-            
-            // Contribution from the dampening
-            temp_mean_field_gradient[i] *= dampening_factor;
+            mean_field_i = output[i];
+            temp_mean_field_gradient[i] = output_gradient[i] * mean_field_i * (1 - mean_field_i);
         }
 
-        // Input gradient contribution
-        temp_input_gradient += temp_mean_field_gradient2;
+        transposeProductAcc( input_gradient, mean_field_output_weights, temp_mean_field_gradient );
 
-        // Lateral weights gradient contribution
-        if( topographic_lateral_weights.length() == 0)
+        externalProductScaleAcc( mean_field_output_weights, temp_mean_field_gradient, 
+                                 mean_field_input, -learning_rate );
+        multiplyScaledAdd( temp_mean_field_gradient, 1.0, -learning_rate, mean_field_output_bias);
+
+        real input_mean_field_i;
+        for( int i=0 ; i&lt;size ; i++ )
         {
-            externalSymetricProductAcc( lateral_weights_gradient, 
-                                        temp_mean_field_gradient2,
-                                        temp_output[t] );
-            
-            transposeProductAcc(temp_mean_field_gradient, lateral_weights, 
-                                temp_mean_field_gradient2);
+            input_mean_field_i = mean_field_input[i];
+            input_gradient[i] = input_gradient[i] * input_mean_field_i * (1 - input_mean_field_i);
         }
-        else
-        {
-            productTopoLateralWeightsGradients( 
-                temp_output[t],
-                temp_mean_field_gradient,
-                temp_mean_field_gradient2,
-                topographic_lateral_weights_gradient);
-        }
-
-        current_temp_output = temp_output[t];
     }
-    
-    for( int i=0 ; i&lt;size ; i++ )
+    else
     {
-        output_i = current_temp_output[i];
-        temp_mean_field_gradient[i] *= output_i * (1-output_i);
-    }
+        temp_input_gradient.clear();
+        temp_mean_field_gradient &lt;&lt; output_gradient;
+        current_temp_output = output;
+        lateral_weights_gradient.clear();
+        for( int i=0; i&lt;topographic_lateral_weights_gradient.length(); i++)
+            topographic_lateral_weights_gradient[i].clear();
 
-    temp_input_gradient += temp_mean_field_gradient;
+        real output_i;
+        for( int t=n_lateral_connections_passes-1 ; t&gt;=0 ; t-- )
+        {
+            for( int i=0 ; i&lt;size ; i++ )
+            {
+                output_i = current_temp_output[i];
 
-    input_gradient += temp_input_gradient;
+                // Contribution from the mean field approximation
+                temp_mean_field_gradient2[i] =  (1-dampening_factor)*
+                    output_i * (1-output_i) * temp_mean_field_gradient[i];
+            
+                // Contribution from the dampening
+                temp_mean_field_gradient[i] *= dampening_factor;
+            }
 
-    // Update bias
-    real in_grad_i;
-    for( int i=0 ; i&lt;size ; i++ )
-    {
-        in_grad_i = temp_input_gradient[i];
-        if( momentum == 0. )
+            // Input gradient contribution
+            temp_input_gradient += temp_mean_field_gradient2;
+
+            // Lateral weights gradient contribution
+            if( topographic_lateral_weights.length() == 0)
+            {
+                externalSymetricProductAcc( lateral_weights_gradient, 
+                                            temp_mean_field_gradient2,
+                                            temp_output[t] );
+            
+                transposeProductAcc(temp_mean_field_gradient, lateral_weights, 
+                                    temp_mean_field_gradient2);
+            }
+            else
+            {
+                productTopoLateralWeightsGradients( 
+                    temp_output[t],
+                    temp_mean_field_gradient,
+                    temp_mean_field_gradient2,
+                    topographic_lateral_weights_gradient);
+            }
+
+            current_temp_output = temp_output[t];
+        }
+    
+        for( int i=0 ; i&lt;size ; i++ )
         {
-            // update the bias: bias -= learning_rate * input_gradient
-            bias[i] -= learning_rate * in_grad_i;
+            output_i = current_temp_output[i];
+            temp_mean_field_gradient[i] *= output_i * (1-output_i);
         }
-        else
+
+        temp_input_gradient += temp_mean_field_gradient;
+
+        input_gradient += temp_input_gradient;
+
+        // Update bias
+        real in_grad_i;
+        for( int i=0 ; i&lt;size ; i++ )
         {
-            // The update rule becomes:
-            // bias_inc = momentum * bias_inc - learning_rate * input_gradient
-            // bias += bias_inc
-            bias_inc[i] = momentum * bias_inc[i] - learning_rate * in_grad_i;
-            bias[i] += bias_inc[i];
+            in_grad_i = temp_input_gradient[i];
+            if( momentum == 0. )
+            {
+                // update the bias: bias -= learning_rate * input_gradient
+                bias[i] -= learning_rate * in_grad_i;
+            }
+            else
+            {
+                // The update rule becomes:
+                // bias_inc = momentum * bias_inc - learning_rate * input_gradient
+                // bias += bias_inc
+                bias_inc[i] = momentum * bias_inc[i] - learning_rate * in_grad_i;
+                bias[i] += bias_inc[i];
+            }
         }
-    }
 
-    if( topographic_lateral_weights.length() == 0)
-    {
-        if( momentum == 0. )
+        if( topographic_lateral_weights.length() == 0)
         {
-            multiplyScaledAdd( lateral_weights_gradient, 1.0, -learning_rate,
-                               lateral_weights);
+            if( momentum == 0. )
+            {
+                multiplyScaledAdd( lateral_weights_gradient, 1.0, -learning_rate,
+                                   lateral_weights);
+            }
+            else
+            {
+                multiplyScaledAdd( lateral_weights_gradient, momentum, -learning_rate,
+                                   lateral_weights_inc);
+                lateral_weights += lateral_weights_inc;
+            }
         }
         else
         {
-            multiplyScaledAdd( lateral_weights_gradient, momentum, -learning_rate,
-                               lateral_weights_inc);
-            lateral_weights += lateral_weights_inc;
+            if( !do_not_learn_topographic_lateral_weights )
+            {
+                if( momentum == 0. )
+                    for( int i=0; i&lt;topographic_lateral_weights.length(); i++ )
+                        multiplyScaledAdd( topographic_lateral_weights_gradient[i], 1.0, 
+                                           -learning_rate,
+                                           topographic_lateral_weights[i]);
+            
+                else
+                    PLERROR(&quot;In RBMLateralBinomialLayer:bpropUpdate - Not implemented for &quot;
+                            &quot;topographic weights&quot;);
+            }
         }
-    }
-    else
-    {
-        if( !do_not_learn_topographic_lateral_weights )
+
+        // Set diagonal to 0
+        if( lateral_weights.length() != 0 )
         {
-            if( momentum == 0. )
-                for( int i=0; i&lt;topographic_lateral_weights.length(); i++ )
-                    multiplyScaledAdd( topographic_lateral_weights_gradient[i], 1.0, 
-                                       -learning_rate,
-                                       topographic_lateral_weights[i]);
-            
-            else
-                PLERROR(&quot;In RBMLateralBinomialLayer:bpropUpdate - Not implemented for &quot;
-                        &quot;topographic weights&quot;);
+            real *d = lateral_weights.data();        
+            for (int i=0; i&lt;lateral_weights.length(); i++,d+=lateral_weights.mod()+1) 
+                *d = 0;
         }
     }
-
-    // Set diagonal to 0
-    if( lateral_weights.length() != 0 )
-    {
-        real *d = lateral_weights.data();        
-        for (int i=0; i&lt;lateral_weights.length(); i++,d+=lateral_weights.mod()+1) 
-            *d = 0;
-    }
 }
 
 void RBMLateralBinomialLayer::bpropUpdate(const Mat&amp; inputs, const Mat&amp; outputs,
@@ -911,114 +1035,123 @@
 
     // We use the average gradient over the mini-batch.
     real avg_lr = learning_rate / inputs.length();
-    lateral_weights_gradient.clear();
-    real output_i;
-    for (int j = 0; j &lt; mbatch_size; j++)
+
+    if( use_parametric_mean_field )
     {
-        temp_input_gradient.clear();
-        temp_mean_field_gradient &lt;&lt; output_gradients(j);
-        current_temp_output = outputs(j);
-
-        for( int t=n_lateral_connections_passes-1 ; t&gt;=0 ; t-- )
+        PLERROR(&quot;RBMLateralBinomialLayer::bpropUpdate: use_parametric_mean_field=true &quot;
+            &quot;not implemented yet for batch mode.&quot;);
+    }
+    else
+    {
+        lateral_weights_gradient.clear();
+        real output_i;
+        for (int j = 0; j &lt; mbatch_size; j++)
         {
+            temp_input_gradient.clear();
+            temp_mean_field_gradient &lt;&lt; output_gradients(j);
+            current_temp_output = outputs(j);
 
-            for( int i=0 ; i&lt;size ; i++ )
+            for( int t=n_lateral_connections_passes-1 ; t&gt;=0 ; t-- )
             {
-                output_i = current_temp_output[i];
+
+                for( int i=0 ; i&lt;size ; i++ )
+                {
+                    output_i = current_temp_output[i];
                 
-                // Contribution from the mean field approximation
-                temp_mean_field_gradient2[i] =  (1-dampening_factor)*
-                    output_i * (1-output_i) * temp_mean_field_gradient[i];
+                    // Contribution from the mean field approximation
+                    temp_mean_field_gradient2[i] =  (1-dampening_factor)*
+                        output_i * (1-output_i) * temp_mean_field_gradient[i];
                 
-                // Contribution from the dampening
-                temp_mean_field_gradient[i] *= dampening_factor;
-            }
+                    // Contribution from the dampening
+                    temp_mean_field_gradient[i] *= dampening_factor;
+                }
             
-            // Input gradient contribution
-            temp_input_gradient += temp_mean_field_gradient2;
+                // Input gradient contribution
+                temp_input_gradient += temp_mean_field_gradient2;
             
-            // Lateral weights gradient contribution
-            if( topographic_lateral_weights.length() == 0)
-            {
+                // Lateral weights gradient contribution
+                if( topographic_lateral_weights.length() == 0)
+                {
                 
-                externalSymetricProductAcc( lateral_weights_gradient, 
-                                            temp_mean_field_gradient2,
-                                            temp_outputs[t](j) );
+                    externalSymetricProductAcc( lateral_weights_gradient, 
+                                                temp_mean_field_gradient2,
+                                                temp_outputs[t](j) );
                 
-                transposeProductAcc(temp_mean_field_gradient, lateral_weights, 
-                                    temp_mean_field_gradient2);
+                    transposeProductAcc(temp_mean_field_gradient, lateral_weights, 
+                                        temp_mean_field_gradient2);
+                }
+                else
+                {
+                    productTopoLateralWeightsGradients( 
+                        temp_outputs[t](j),
+                        temp_mean_field_gradient,
+                        temp_mean_field_gradient2,
+                        topographic_lateral_weights_gradient);
+                }
+
+                current_temp_output = temp_outputs[t](j);
             }
-            else
+    
+            for( int i=0 ; i&lt;size ; i++ )
             {
-                productTopoLateralWeightsGradients( 
-                    temp_outputs[t](j),
-                    temp_mean_field_gradient,
-                    temp_mean_field_gradient2,
-                    topographic_lateral_weights_gradient);
+                output_i = current_temp_output[i];
+                temp_mean_field_gradient[i] *= output_i * (1-output_i);
             }
 
-            current_temp_output = temp_outputs[t](j);
+            temp_input_gradient += temp_mean_field_gradient;
+        
+            input_gradients(j) += temp_input_gradient;
+
+            // Update bias
+            real in_grad_i;
+            for( int i=0 ; i&lt;size ; i++ )
+            {
+                in_grad_i = temp_input_gradient[i];
+                if( momentum == 0. )
+                {
+                    // update the bias: bias -= learning_rate * input_gradient
+                    bias[i] -= avg_lr * in_grad_i;
+                }
+                else
+                    PLERROR(&quot;In RBMLateralBinomialLayer:bpropUpdate - Not implemented for &quot;
+                            &quot;momentum with mini-batches&quot;);
+            }        
         }
-    
-        for( int i=0 ; i&lt;size ; i++ )
-        {
-            output_i = current_temp_output[i];
-            temp_mean_field_gradient[i] *= output_i * (1-output_i);
-        }
 
-        temp_input_gradient += temp_mean_field_gradient;
-        
-        input_gradients(j) += temp_input_gradient;
-
-        // Update bias
-        real in_grad_i;
-        for( int i=0 ; i&lt;size ; i++ )
+        if( topographic_lateral_weights.length() == 0)
         {
-            in_grad_i = temp_input_gradient[i];
             if( momentum == 0. )
-            {
-                // update the bias: bias -= learning_rate * input_gradient
-                bias[i] -= avg_lr * in_grad_i;
-            }
+                multiplyScaledAdd( lateral_weights_gradient, 1.0, -learning_rate,
+                                   lateral_weights);
             else
                 PLERROR(&quot;In RBMLateralBinomialLayer:bpropUpdate - Not implemented for &quot;
                         &quot;momentum with mini-batches&quot;);
-        }        
-    }
-
-    if( topographic_lateral_weights.length() == 0)
-    {
-        if( momentum == 0. )
-            multiplyScaledAdd( lateral_weights_gradient, 1.0, -learning_rate,
-                               lateral_weights);
+        }
         else
-            PLERROR(&quot;In RBMLateralBinomialLayer:bpropUpdate - Not implemented for &quot;
-                    &quot;momentum with mini-batches&quot;);
-    }
-    else
-    {
-        if( !do_not_learn_topographic_lateral_weights )
         {
-            if( momentum == 0. )
-                for( int i=0; i&lt;topographic_lateral_weights.length(); i++ )
-                    multiplyScaledAdd( topographic_lateral_weights_gradient[i], 1.0, 
-                                       -learning_rate,
-                                       topographic_lateral_weights[i]);
+            if( !do_not_learn_topographic_lateral_weights )
+            {
+                if( momentum == 0. )
+                    for( int i=0; i&lt;topographic_lateral_weights.length(); i++ )
+                        multiplyScaledAdd( topographic_lateral_weights_gradient[i], 1.0, 
+                                           -learning_rate,
+                                           topographic_lateral_weights[i]);
             
-            else
-                PLERROR(&quot;In RBMLateralBinomialLayer:bpropUpdate - Not implemented for &quot;
-                        &quot;topographic weights&quot;);
+                else
+                    PLERROR(&quot;In RBMLateralBinomialLayer:bpropUpdate - Not implemented for &quot;
+                            &quot;topographic weights&quot;);
+            }
+
         }
 
+        // Set diagonal to 0
+        if( lateral_weights.length() != 0 )
+        {
+            real *d = lateral_weights.data();
+            for (int i=0; i&lt;lateral_weights.length(); i++,d+=lateral_weights.mod()+1) 
+                *d = 0;
+        }
     }
-
-    // Set diagonal to 0
-    if( lateral_weights.length() != 0 )
-    {
-        real *d = lateral_weights.data();
-        for (int i=0; i&lt;lateral_weights.length(); i++,d+=lateral_weights.mod()+1) 
-            *d = 0;
-    }
 }
 
 
@@ -1035,101 +1168,109 @@
     input_gradient.resize( size );
     rbm_bias_gradient.resize( size );
 
-    temp_input_gradient.clear();
-    temp_mean_field_gradient &lt;&lt; output_gradient;
-    current_temp_output = output;
-    lateral_weights_gradient.clear();
-
-    real output_i;
-    for( int t=n_lateral_connections_passes-1 ; t&gt;=0 ; t-- )
+    if( use_parametric_mean_field )
     {
+        PLERROR(&quot;RBMLateralBinomialLayer::bpropUpdate: use_parametric_mean_field=true &quot;
+                &quot;not implemented yet for bias input.&quot;);
+    }
+    else
+    {
+        temp_input_gradient.clear();
+        temp_mean_field_gradient &lt;&lt; output_gradient;
+        current_temp_output = output;
+        lateral_weights_gradient.clear();
 
-        for( int i=0 ; i&lt;size ; i++ )
+        real output_i;
+        for( int t=n_lateral_connections_passes-1 ; t&gt;=0 ; t-- )
         {
-            output_i = current_temp_output[i];
 
-            // Contribution from the mean field approximation
-            temp_mean_field_gradient2[i] =  (1-dampening_factor)*
-                output_i * (1-output_i) * temp_mean_field_gradient[i];
+            for( int i=0 ; i&lt;size ; i++ )
+            {
+                output_i = current_temp_output[i];
+
+                // Contribution from the mean field approximation
+                temp_mean_field_gradient2[i] =  (1-dampening_factor)*
+                    output_i * (1-output_i) * temp_mean_field_gradient[i];
             
-            // Contribution from the dampening
-            temp_mean_field_gradient[i] *= dampening_factor;
-        }
+                // Contribution from the dampening
+                temp_mean_field_gradient[i] *= dampening_factor;
+            }
 
-        // Input gradient contribution
-        temp_input_gradient += temp_mean_field_gradient2;
+            // Input gradient contribution
+            temp_input_gradient += temp_mean_field_gradient2;
 
-        // Lateral weights gradient contribution
-        if( topographic_lateral_weights.length() == 0)
-        {
+            // Lateral weights gradient contribution
+            if( topographic_lateral_weights.length() == 0)
+            {
 
-            externalSymetricProductAcc( lateral_weights_gradient, 
-                                        temp_mean_field_gradient2,
-                                        temp_output[t] );
+                externalSymetricProductAcc( lateral_weights_gradient, 
+                                            temp_mean_field_gradient2,
+                                            temp_output[t] );
             
-            transposeProductAcc(temp_mean_field_gradient, lateral_weights, 
-                                temp_mean_field_gradient2);
+                transposeProductAcc(temp_mean_field_gradient, lateral_weights, 
+                                    temp_mean_field_gradient2);
+            }
+            else
+            {
+                productTopoLateralWeightsGradients( 
+                    temp_output[t],
+                    temp_mean_field_gradient,
+                    temp_mean_field_gradient2,
+                    topographic_lateral_weights_gradient);
+            }
+
+            current_temp_output = temp_output[t];
         }
-        else
+    
+        for( int i=0 ; i&lt;size ; i++ )
         {
-            productTopoLateralWeightsGradients( 
-                temp_output[t],
-                temp_mean_field_gradient,
-                temp_mean_field_gradient2,
-                topographic_lateral_weights_gradient);
+            output_i = current_temp_output[i];
+            temp_mean_field_gradient[i] *= output_i * (1-output_i);
         }
 
-        current_temp_output = temp_output[t];
-    }
-    
-    for( int i=0 ; i&lt;size ; i++ )
-    {
-        output_i = current_temp_output[i];
-        temp_mean_field_gradient[i] *= output_i * (1-output_i);
-    }
+        temp_input_gradient += temp_mean_field_gradient;
 
-    temp_input_gradient += temp_mean_field_gradient;
+        input_gradient &lt;&lt; temp_input_gradient;
+        rbm_bias_gradient &lt;&lt; temp_input_gradient;
 
-    input_gradient &lt;&lt; temp_input_gradient;
-    rbm_bias_gradient &lt;&lt; temp_input_gradient;
-
-    if( topographic_lateral_weights.length() == 0)
-    {
-        if( momentum == 0. )
+        if( topographic_lateral_weights.length() == 0)
         {
-            multiplyScaledAdd( lateral_weights_gradient, 1.0, -learning_rate,
-                               lateral_weights);
+            if( momentum == 0. )
+            {
+                multiplyScaledAdd( lateral_weights_gradient, 1.0, -learning_rate,
+                                   lateral_weights);
+            }
+            else
+            {
+                multiplyScaledAdd( lateral_weights_gradient, momentum, -learning_rate,
+                                   lateral_weights_inc);
+                lateral_weights += lateral_weights_inc;
+            }
         }
         else
         {
-            multiplyScaledAdd( lateral_weights_gradient, momentum, -learning_rate,
-                               lateral_weights_inc);
-            lateral_weights += lateral_weights_inc;
+            if( !do_not_learn_topographic_lateral_weights )
+            {
+                if( momentum == 0. )
+                    for( int i=0; i&lt;topographic_lateral_weights.length(); i++ )
+                        multiplyScaledAdd( topographic_lateral_weights_gradient[i], 1.0, 
+                                           -learning_rate,
+                                           topographic_lateral_weights[i]);
+            
+                else
+                    PLERROR(&quot;In RBMLateralBinomialLayer:bpropUpdate - Not implemented for &quot;
+                            &quot;topographic weights&quot;);
+            }
         }
-    }
-    else
-    {
-        if( !do_not_learn_topographic_lateral_weights )
+        
+        // Set diagonal to 0
+        if( lateral_weights.length() != 0 )
         {
-            if( momentum == 0. )
-                for( int i=0; i&lt;topographic_lateral_weights.length(); i++ )
-                    multiplyScaledAdd( topographic_lateral_weights_gradient[i], 1.0, 
-                                       -learning_rate,
-                                       topographic_lateral_weights[i]);
-            
-            else
-                PLERROR(&quot;In RBMLateralBinomialLayer:bpropUpdate - Not implemented for &quot;
-                        &quot;topographic weights&quot;);
+            real *d = lateral_weights.data();
+            for (int i=0; i&lt;lateral_weights.length(); i++,d+=lateral_weights.mod()+1) 
+                *d = 0;
         }
     }
-        
-    // Set diagonal to 0
-    if( lateral_weights.length() != 0 )
-    {
-        real *d = lateral_weights.data();
-        for (int i=0; i&lt;lateral_weights.length(); i++,d+=lateral_weights.mod()+1) 
-            *d = 0;
-    }
 }
 
 real RBMLateralBinomialLayer::fpropNLL(const Vec&amp; target)
@@ -1186,97 +1327,105 @@
     bias_gradient.resize( size );
     bias_gradient.clear();
 
-    // bias_gradient = expectation - target
-    substract(expectation, target, temp_mean_field_gradient);
+    if( use_parametric_mean_field )
+    {
+        PLERROR(&quot;RBMLateralBinomialLayer::bpropNLL: use_parametric_mean_field=true &quot;
+                &quot;not implemented yet.&quot;);
+    }
+    else
+    {
+        // bias_gradient = expectation - target
+        substract(expectation, target, temp_mean_field_gradient);
 
-    current_temp_output = expectation;
-    lateral_weights_gradient.clear();
+        current_temp_output = expectation;
+        lateral_weights_gradient.clear();
 
-    real output_i;
-    for( int t=n_lateral_connections_passes-1 ; t&gt;=0 ; t-- )
-    {
-        for( int i=0 ; i&lt;size ; i++ )
+        real output_i;
+        for( int t=n_lateral_connections_passes-1 ; t&gt;=0 ; t-- )
         {
-            output_i = current_temp_output[i];
+            for( int i=0 ; i&lt;size ; i++ )
+            {
+                output_i = current_temp_output[i];
 
-            // Contribution from the mean field approximation
-            temp_mean_field_gradient2[i] =  (1-dampening_factor)*
-                output_i * (1-output_i) * temp_mean_field_gradient[i];
+                // Contribution from the mean field approximation
+                temp_mean_field_gradient2[i] =  (1-dampening_factor)*
+                    output_i * (1-output_i) * temp_mean_field_gradient[i];
             
-            // Contribution from the dampening
-            temp_mean_field_gradient[i] *= dampening_factor;
-        }
+                // Contribution from the dampening
+                temp_mean_field_gradient[i] *= dampening_factor;
+            }
 
-        // Input gradient contribution
-        bias_gradient += temp_mean_field_gradient2;
+            // Input gradient contribution
+            bias_gradient += temp_mean_field_gradient2;
 
-        // Lateral weights gradient contribution
-        if( topographic_lateral_weights.length() == 0)
-        {
-            externalSymetricProductAcc( lateral_weights_gradient, 
-                                        temp_mean_field_gradient2,
-                                        temp_output[t] );
+            // Lateral weights gradient contribution
+            if( topographic_lateral_weights.length() == 0)
+            {
+                externalSymetricProductAcc( lateral_weights_gradient, 
+                                            temp_mean_field_gradient2,
+                                            temp_output[t] );
             
-            transposeProductAcc(temp_mean_field_gradient, lateral_weights, 
-                                temp_mean_field_gradient2);
+                transposeProductAcc(temp_mean_field_gradient, lateral_weights, 
+                                    temp_mean_field_gradient2);
+            }
+            else
+            {
+                productTopoLateralWeightsGradients( 
+                    temp_output[t],
+                    temp_mean_field_gradient,
+                    temp_mean_field_gradient2,
+                    topographic_lateral_weights_gradient);
+            }
+
+            current_temp_output = temp_output[t];
         }
-        else
+    
+        for( int i=0 ; i&lt;size ; i++ )
         {
-            productTopoLateralWeightsGradients( 
-                temp_output[t],
-                temp_mean_field_gradient,
-                temp_mean_field_gradient2,
-                topographic_lateral_weights_gradient);
+            output_i = current_temp_output[i];
+            temp_mean_field_gradient[i] *= output_i * (1-output_i);
         }
 
-        current_temp_output = temp_output[t];
-    }
-    
-    for( int i=0 ; i&lt;size ; i++ )
-    {
-        output_i = current_temp_output[i];
-        temp_mean_field_gradient[i] *= output_i * (1-output_i);
-    }
+        bias_gradient += temp_mean_field_gradient;
 
-    bias_gradient += temp_mean_field_gradient;
-
-    if( topographic_lateral_weights.length() == 0)
-    {
-        // Update lateral connections
-        if( momentum == 0. )
+        if( topographic_lateral_weights.length() == 0)
         {
-            multiplyScaledAdd( lateral_weights_gradient, 1.0, -learning_rate,
-                               lateral_weights);
+            // Update lateral connections
+            if( momentum == 0. )
+            {
+                multiplyScaledAdd( lateral_weights_gradient, 1.0, -learning_rate,
+                                   lateral_weights);
+            }
+            else
+            {
+                multiplyScaledAdd( lateral_weights_gradient, momentum, -learning_rate,
+                                   lateral_weights_inc);
+                lateral_weights += lateral_weights_inc;
+            }
         }
         else
         {
-            multiplyScaledAdd( lateral_weights_gradient, momentum, -learning_rate,
-                               lateral_weights_inc);
-            lateral_weights += lateral_weights_inc;
+            if( !do_not_learn_topographic_lateral_weights )
+            {
+                if( momentum == 0. )
+                    for( int i=0; i&lt;topographic_lateral_weights.length(); i++ )
+                        multiplyScaledAdd( topographic_lateral_weights_gradient[i], 1.0, 
+                                           -learning_rate,
+                                           topographic_lateral_weights[i]);
+            
+                else
+                    PLERROR(&quot;In RBMLateralBinomialLayer:bpropNLL - Not implemented for &quot;
+                            &quot;topographic weights&quot;);
+            }
         }
-    }
-    else
-    {
-        if( !do_not_learn_topographic_lateral_weights )
+        // Set diagonal to 0
+        if( lateral_weights.length() != 0 )
         {
-            if( momentum == 0. )
-                for( int i=0; i&lt;topographic_lateral_weights.length(); i++ )
-                    multiplyScaledAdd( topographic_lateral_weights_gradient[i], 1.0, 
-                                       -learning_rate,
-                                       topographic_lateral_weights[i]);
-            
-            else
-                PLERROR(&quot;In RBMLateralBinomialLayer:bpropNLL - Not implemented for &quot;
-                        &quot;topographic weights&quot;);
+            real *d = lateral_weights.data();
+            for (int i=0; i&lt;lateral_weights.length(); i++,d+=lateral_weights.mod()+1) 
+                *d = 0;
         }
     }
-    // Set diagonal to 0
-    if( lateral_weights.length() != 0 )
-    {
-        real *d = lateral_weights.data();
-        for (int i=0; i&lt;lateral_weights.length(); i++,d+=lateral_weights.mod()+1) 
-            *d = 0;
-    }
 }
 
 void RBMLateralBinomialLayer::bpropNLL(const Mat&amp; targets, const Mat&amp; costs_column,
@@ -1294,95 +1443,104 @@
 
     // TODO Can we do this more efficiently? (using BLAS)
 
-    // We use the average gradient over the mini-batch.
-    lateral_weights_gradient.clear();
-    real output_i;
-    for (int j = 0; j &lt; batch_size; j++)
+    if( use_parametric_mean_field )
     {
-        // top_gradient = expectations(j) - targets(j)
-        substract(expectations(j), targets(j), temp_mean_field_gradient);
-        current_temp_output = expectations(j);
+        PLERROR(&quot;RBMLateralBinomialLayer::bpropNLL: use_parametric_mean_field=true &quot;
+                &quot;not implemented yet.&quot;);
+    }
+    else
+    {
 
-        for( int t=n_lateral_connections_passes-1 ; t&gt;=0 ; t-- )
+        // We use the average gradient over the mini-batch.
+        lateral_weights_gradient.clear();
+        real output_i;
+        for (int j = 0; j &lt; batch_size; j++)
         {
-            for( int i=0 ; i&lt;size ; i++ )
+            // top_gradient = expectations(j) - targets(j)
+            substract(expectations(j), targets(j), temp_mean_field_gradient);
+            current_temp_output = expectations(j);
+
+            for( int t=n_lateral_connections_passes-1 ; t&gt;=0 ; t-- )
             {
-                output_i = current_temp_output[i];
+                for( int i=0 ; i&lt;size ; i++ )
+                {
+                    output_i = current_temp_output[i];
                 
-                // Contribution from the mean field approximation
-                temp_mean_field_gradient2[i] =  (1-dampening_factor)*
-                    output_i * (1-output_i) * temp_mean_field_gradient[i];
+                    // Contribution from the mean field approximation
+                    temp_mean_field_gradient2[i] =  (1-dampening_factor)*
+                        output_i * (1-output_i) * temp_mean_field_gradient[i];
                 
-                // Contribution from the dampening
-                temp_mean_field_gradient[i] *= dampening_factor;
-            }
+                    // Contribution from the dampening
+                    temp_mean_field_gradient[i] *= dampening_factor;
+                }
             
-            // Input gradient contribution
-            bias_gradients(j) += temp_mean_field_gradient2;
+                // Input gradient contribution
+                bias_gradients(j) += temp_mean_field_gradient2;
             
-            // Lateral weights gradient contribution
-            if( topographic_lateral_weights.length() == 0)
-            {
+                // Lateral weights gradient contribution
+                if( topographic_lateral_weights.length() == 0)
+                {
 
-                externalSymetricProductAcc( lateral_weights_gradient, 
-                                            temp_mean_field_gradient2,
-                                            temp_outputs[t](j) );
+                    externalSymetricProductAcc( lateral_weights_gradient, 
+                                                temp_mean_field_gradient2,
+                                                temp_outputs[t](j) );
                 
-                transposeProductAcc(temp_mean_field_gradient, lateral_weights, 
-                                    temp_mean_field_gradient2);
+                    transposeProductAcc(temp_mean_field_gradient, lateral_weights, 
+                                        temp_mean_field_gradient2);
+                }
+                else
+                {
+                    productTopoLateralWeightsGradients( 
+                        temp_outputs[t](j),
+                        temp_mean_field_gradient,
+                        temp_mean_field_gradient2,
+                        topographic_lateral_weights_gradient);
+                }
+                current_temp_output = temp_outputs[t](j);
             }
-            else
+    
+            for( int i=0 ; i&lt;size ; i++ )
             {
-                productTopoLateralWeightsGradients( 
-                    temp_outputs[t](j),
-                    temp_mean_field_gradient,
-                    temp_mean_field_gradient2,
-                    topographic_lateral_weights_gradient);
+                output_i = current_temp_output[i];
+                temp_mean_field_gradient[i] *= output_i * (1-output_i);
             }
-            current_temp_output = temp_outputs[t](j);
+
+            bias_gradients(j) += temp_mean_field_gradient;
         }
-    
-        for( int i=0 ; i&lt;size ; i++ )
+
+        // Update lateral connections
+        if( topographic_lateral_weights.length() == 0 )
         {
-            output_i = current_temp_output[i];
-            temp_mean_field_gradient[i] *= output_i * (1-output_i);
+            if( momentum == 0. )
+                multiplyScaledAdd( lateral_weights_gradient, 1.0, -learning_rate,
+                                   lateral_weights);
+            else
+                PLERROR(&quot;In RBMLateralBinomialLayer:bpropUpdate - Not implemented for &quot;
+                        &quot;momentum with mini-batches&quot;);
         }
-
-        bias_gradients(j) += temp_mean_field_gradient;
-    }
-
-    // Update lateral connections
-    if( topographic_lateral_weights.length() == 0 )
-    {
-        if( momentum == 0. )
-            multiplyScaledAdd( lateral_weights_gradient, 1.0, -learning_rate,
-                               lateral_weights);
         else
-            PLERROR(&quot;In RBMLateralBinomialLayer:bpropUpdate - Not implemented for &quot;
-                    &quot;momentum with mini-batches&quot;);
-    }
-    else
-    {
-        if( !do_not_learn_topographic_lateral_weights )
         {
-            if( momentum == 0. )
-                for( int i=0; i&lt;topographic_lateral_weights.length(); i++ )
-                    multiplyScaledAdd( topographic_lateral_weights_gradient[i], 1.0, 
-                                       -learning_rate,
-                                       topographic_lateral_weights[i]);
+            if( !do_not_learn_topographic_lateral_weights )
+            {
+                if( momentum == 0. )
+                    for( int i=0; i&lt;topographic_lateral_weights.length(); i++ )
+                        multiplyScaledAdd( topographic_lateral_weights_gradient[i], 1.0, 
+                                           -learning_rate,
+                                           topographic_lateral_weights[i]);
             
-            else
-                PLERROR(&quot;In RBMLateralBinomialLayer:bpropNLL - Not implemented for &quot;
-                        &quot;topographic weights&quot;);
+                else
+                    PLERROR(&quot;In RBMLateralBinomialLayer:bpropNLL - Not implemented for &quot;
+                            &quot;topographic weights&quot;);
+            }
         }
-    }
 
-    // Set diagonal to 0
-    if( lateral_weights.length() != 0 )
-    {
-        real *d = lateral_weights.data();
-        for (int i=0; i&lt;lateral_weights.length(); i++,d+=lateral_weights.mod()+1) 
-            *d = 0;
+        // Set diagonal to 0
+        if( lateral_weights.length() != 0 )
+        {
+            real *d = lateral_weights.data();
+            for (int i=0; i&lt;lateral_weights.length(); i++,d+=lateral_weights.mod()+1) 
+                *d = 0;
+        }
     }
 }
 
@@ -1635,6 +1793,22 @@
                   OptionBase::learntoption,
                   &quot;Local topographic lateral connections.\n&quot;);
 
+    declareOption(ol, &quot;use_parametric_mean_field&quot;, 
+                  &amp;RBMLateralBinomialLayer::use_parametric_mean_field,
+                  OptionBase::buildoption,
+                  &quot;Indication that a parametric predictor of the mean-field\n&quot;
+                  &quot;approximation of the hidden layer conditional distribution.\n&quot;);
+
+    declareOption(ol, &quot;mean_field_output_weights&quot;, 
+                  &amp;RBMLateralBinomialLayer::mean_field_output_weights,
+                  OptionBase::learntoption,
+                  &quot;Output weights of the mean field predictor.\n&quot;);
+
+    declareOption(ol, &quot;mean_field_output_bias&quot;, 
+                  &amp;RBMLateralBinomialLayer::mean_field_output_bias,
+                  OptionBase::learntoption,
+                  &quot;Output bias of the mean field predictor.\n&quot;);
+
     // Now call the parent class' declareOptions
     inherited::declareOptions(ol);
 }
@@ -1653,7 +1827,19 @@
     if( n_lateral_connections_passes &lt; 0 )
         PLERROR(&quot;In RBMLateralBinomialLayer::build_(): n_lateral_connections_passes\n&quot;
                 &quot; should be &gt;= 0.&quot;);
+ 
+    if( use_parametric_mean_field &amp;&amp; topographic_length &gt; 0 &amp;&amp; topographic_width &gt; 0 )
+        PLERROR(&quot;RBMLateralBinomialLayer::build_(): can't use parametric mean field &quot;
+            &quot;and topographic lateral connections.&quot;);
     
+    if( use_parametric_mean_field )
+    {
+        mean_field_output_weights.resize(size,size);
+        mean_field_output_bias.resize(size);
+        mean_field_input.resize(size);
+        pre_sigmoid_mean_field_output.resize(size);
+    }
+
     if( topographic_length &lt;= 0 || topographic_width &lt;= 0)
     {
         lateral_weights.resize(size,size);
@@ -1719,6 +1905,8 @@
     deepCopyField(lateral_weights_neg_stats,copies);
     deepCopyField(dampening_expectation,copies);
     deepCopyField(dampening_expectations,copies);
+    deepCopyField(mean_field_input,copies);
+    deepCopyField(pre_sigmoid_mean_field_output,copies);
     deepCopyField(temp_output,copies);
     deepCopyField(temp_outputs,copies);
     deepCopyField(current_temp_output,copies);
@@ -1733,6 +1921,8 @@
     deepCopyField(lateral_weights_gradient,copies);
     deepCopyField(lateral_weights_inc,copies);
     deepCopyField(topographic_lateral_weights_gradient,copies);
+    deepCopyField(mean_field_output_weights,copies);
+    deepCopyField(mean_field_output_bias,copies);
 }
 
 real RBMLateralBinomialLayer::energy(const Vec&amp; unit_values) const

Modified: trunk/plearn_learners/online/RBMLateralBinomialLayer.h
===================================================================
--- trunk/plearn_learners/online/RBMLateralBinomialLayer.h	2008-02-28 19:37:18 UTC (rev 8600)
+++ trunk/plearn_learners/online/RBMLateralBinomialLayer.h	2008-02-28 22:14:04 UTC (rev 8601)
@@ -100,6 +100,16 @@
     //! Accumulates negative contribution to the gradient of lateral weights
     Mat lateral_weights_neg_stats;
 
+    //! Indication that a parametric predictor of the mean-field 
+    //! approximation of the hidden layer conditional distribution.
+    bool use_parametric_mean_field;
+
+    //! Output weights of the mean field predictor
+    Mat mean_field_output_weights;
+
+    //! Output bias of the mean field predictor
+    Vec mean_field_output_bias;
+
 public:
     //#####  Public Member Functions  #########################################
 
@@ -237,6 +247,9 @@
     mutable Vec dampening_expectation;
     mutable Mat dampening_expectations;
 
+    mutable Vec mean_field_input;
+    mutable Vec pre_sigmoid_mean_field_output;
+
     mutable TVec&lt;Vec&gt; temp_output;
     mutable TVec&lt;Mat&gt; temp_outputs;
 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002048.html">[Plearn-commits] r8600 - trunk/plearn/var
</A></li>
	<LI>Next message: <A HREF="002050.html">[Plearn-commits] r8602 - trunk/plearn_learners_experimental
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2049">[ date ]</a>
              <a href="thread.html#2049">[ thread ]</a>
              <a href="subject.html#2049">[ subject ]</a>
              <a href="author.html#2049">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/plearn-commits">More information about the Plearn-commits
mailing list</a><br>
</body></html>
