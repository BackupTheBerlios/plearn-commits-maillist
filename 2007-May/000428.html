<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Plearn-commits] r6979 - trunk/plearn/math
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/plearn-commits/2007-May/index.html" >
   <LINK REL="made" HREF="mailto:plearn-commits%40lists.berlios.de?Subject=Re%3A%20%5BPlearn-commits%5D%20r6979%20-%20trunk/plearn/math&In-Reply-To=%3C200705030107.l4317KD5000780%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000427.html">
   <LINK REL="Next"  HREF="000429.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Plearn-commits] r6979 - trunk/plearn/math</H1>
    <B>lamblin at BerliOS</B> 
    <A HREF="mailto:plearn-commits%40lists.berlios.de?Subject=Re%3A%20%5BPlearn-commits%5D%20r6979%20-%20trunk/plearn/math&In-Reply-To=%3C200705030107.l4317KD5000780%40sheep.berlios.de%3E"
       TITLE="[Plearn-commits] r6979 - trunk/plearn/math">lamblin at mail.berlios.de
       </A><BR>
    <I>Thu May  3 03:07:20 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000427.html">[Plearn-commits] r6978 - trunk/plearn/math
</A></li>
        <LI>Next message: <A HREF="000429.html">[Plearn-commits] r6980 - trunk/plearn_learners/online
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#428">[ date ]</a>
              <a href="thread.html#428">[ thread ]</a>
              <a href="subject.html#428">[ subject ]</a>
              <a href="author.html#428">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: lamblin
Date: 2007-05-03 03:07:17 +0200 (Thu, 03 May 2007)
New Revision: 6979

Modified:
   trunk/plearn/math/TMat_maths_specialisation.h
Log:
Cosmetic changes


Modified: trunk/plearn/math/TMat_maths_specialisation.h
===================================================================
--- trunk/plearn/math/TMat_maths_specialisation.h	2007-05-03 00:55:32 UTC (rev 6978)
+++ trunk/plearn/math/TMat_maths_specialisation.h	2007-05-03 01:07:17 UTC (rev 6979)
@@ -5,18 +5,18 @@
 
 // Redistribution and use in source and binary forms, with or without
 // modification, are permitted provided that the following conditions are met:
-// 
+//
 //  1. Redistributions of source code must retain the above copyright
 //     notice, this list of conditions and the following disclaimer.
-// 
+//
 //  2. Redistributions in binary form must reproduce the above copyright
 //     notice, this list of conditions and the following disclaimer in the
 //     documentation and/or other materials provided with the distribution.
-// 
+//
 //  3. The name of the authors may not be used to endorse or promote
 //     products derived from this software without specific prior written
 //     permission.
-// 
+//
 // THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
 // IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 // OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
@@ -27,14 +27,14 @@
 // LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-// 
+//
 // This file is part of the PLearn library. For more information on the PLearn
 // library, go to the PLearn Web site at www.plearn.org
 
 
- 
 
-/* *******************************************************      
+
+/* *******************************************************
  * $Id$
  * AUTHORS: Pascal Vincent &amp; Yoshua Bengio &amp; Rejean Ducharme
  * This file is part of the PLearn library.
@@ -73,18 +73,18 @@
 // copy //
 //////////
 inline real* copy(real* first, real* last, real* dest)
-{ 
-    int n = last - first; 
+{
+    int n = last - first;
     int one = 1;
     BLAS_COPY(&amp;n, first, &amp;one, dest, &amp;one);
-    return dest + n; 
+    return dest + n;
 }
 */
 
 /////////////////
 // multiplyAcc //
 /////////////////
-// vec += x * scale
+//! vec += x * scale
 inline void multiplyAcc(const Vec&amp; vec, const Vec&amp; x, real scale)
 {
     int n = vec.length();
@@ -185,9 +185,13 @@
 /////////////////////
 // productScaleAcc //
 /////////////////////
-//  C = alpha A.B + beta C
-// ( Will use the transpose of A and/or B instead, if you set the corresponding flags to true)
-inline void productScaleAcc(const TMat&lt;double&gt;&amp; C, const TMat&lt;double&gt;&amp; A, bool transposeA, const TMat&lt;double&gt;&amp; B, bool transposeB, double alpha, double beta)
+//! C = alpha A.B + beta C
+// (Will use the transpose of A and/or B instead, if you set the corresponding
+// flags to true)
+inline void productScaleAcc(const TMat&lt;double&gt;&amp; C,
+                            const TMat&lt;double&gt;&amp; A, bool transposeA,
+                            const TMat&lt;double&gt;&amp; B, bool transposeB,
+                            double alpha, double beta)
 {
 #ifdef BOUNDCHECK
     int l2;
@@ -225,9 +229,10 @@
 
 #ifdef BOUNDCHECK
     if (w1!=l2 || C.length()!=l1 || C.width()!=w2)
-        PLERROR(&quot;productScaleAcc, incompatible arguments (%dx%d) &lt;- %s(%dx%d) . %s(%dx%d)&quot;,
-                C.length(), C.width(), 
-                transposeA?&quot;transpose&quot;:&quot;&quot;, A.length(), A.width(), 
+        PLERROR(&quot;productScaleAcc, incompatible arguments:\n&quot;
+                &quot;(%dx%d) &lt;- %s(%dx%d) . %s(%dx%d)&quot;,
+                C.length(), C.width(),
+                transposeA?&quot;transpose&quot;:&quot;&quot;, A.length(), A.width(),
                 transposeB?&quot;transpose&quot;:&quot;&quot;, B.length(), B.width());
 #endif
 
@@ -244,22 +249,30 @@
         return;
     }
 
-    dgemm_(&amp;transb, &amp;transa, &amp;w2, &amp;l1, &amp;w1, &amp;alpha, B.data(), &amp;ldb, A.data(), &amp;lda, &amp;beta, C.data(), &amp;ldc);
+    dgemm_(&amp;transb, &amp;transa, &amp;w2, &amp;l1, &amp;w1, &amp;alpha, B.data(), &amp;ldb, A.data(),
+           &amp;lda, &amp;beta, C.data(), &amp;ldc);
 }
 
-//! y &lt;- alpha A.x + beta y   (will use the transposed of A instead if tranposeA is true)
-inline void productScaleAcc(const TVec&lt;double&gt;&amp; y, const TMat&lt;double&gt;&amp; A, bool transposeA, const TVec&lt;double&gt;&amp; x, double alpha, double beta)
+//! y &lt;- alpha A.x + beta y 
+// (will use the transposed of A instead if tranposeA is true)
+inline void productScaleAcc(const TVec&lt;double&gt;&amp; y,
+                            const TMat&lt;double&gt;&amp; A, bool transposeA,
+                            const TVec&lt;double&gt;&amp; x, double alpha, double beta)
 {
 #ifdef BOUNDCHECK
     if(!transposeA)
     {
         if(A.length()!=y.length() || A.width()!=x.length())
-            PLERROR(&quot;productScaleAcc, incompatible arguments Vec(%d) &lt;- Mat(%d,%d) . Vec(%d)&quot;, y.length(), A.length(), A.width(), x.length());
+            PLERROR(&quot;productScaleAcc, incompatible arguments:\n&quot;
+                    &quot;Vec(%d) &lt;- Mat(%d,%d) . Vec(%d)&quot;,
+                    y.length(), A.length(), A.width(), x.length());
     }
     else
     {
         if(A.length()!=x.length() || A.width()!=y.length())
-            PLERROR(&quot;productScaleAcc, incompatible arguments Vec(%d) &lt;- Mat(%d,%d)' . Vec(%d)&quot;, y.length(), A.length(), A.width(), x.length());
+            PLERROR(&quot;productScaleAcc, incompatible arguments:\n&quot;
+                    &quot;Vec(%d) &lt;- Mat(%d,%d)' . Vec(%d)&quot;,
+                    y.length(), A.length(), A.width(), x.length());
     }
 #endif
 
@@ -278,15 +291,20 @@
         return;
     }
 
-    dgemv_(&amp;trans, &amp;m, &amp;n, &amp;alpha, A.data(), &amp;lda, x.data(), &amp;one, &amp;beta, y.data(), &amp;one);
+    dgemv_(&amp;trans, &amp;m, &amp;n, &amp;alpha, A.data(), &amp;lda, x.data(), &amp;one, &amp;beta,
+           y.data(), &amp;one);
 }
 
 //! A &lt;- A + alpha x.y'
-inline void externalProductScaleAcc(const TMat&lt;double&gt;&amp; A, const TVec&lt;double&gt;&amp; x, const TVec&lt;double&gt;&amp; y, double alpha)
+inline void externalProductScaleAcc(const TMat&lt;double&gt;&amp; A,
+                                    const TVec&lt;double&gt;&amp; x,
+                                    const TVec&lt;double&gt;&amp; y, double alpha)
 {
 #ifdef BOUNDCHECK
     if(A.length()!=x.length() || A.width()!=y.length())
-        PLERROR(&quot;In externalProductScaleAcc, incompatible dimensions: Mat(%d,%d) &lt;- Vec(%d).Vec(%d)'&quot;,A.length(), A.width(), x.length(), y.length());
+        PLERROR(&quot;In externalProductScaleAcc, incompatible dimensions:\n&quot;
+                &quot;Mat(%d,%d) &lt;- Vec(%d).Vec(%d)'&quot;,
+                A.length(), A.width(), x.length(), y.length());
 #endif
     int one = 1;
     int lda = A.mod();
@@ -299,23 +317,29 @@
     dger_(&amp;m, &amp;n, &amp;alpha, y.data(), &amp;one, x.data(), &amp;one, A.data(), &amp;lda);
 }
 
-inline void externalProductAcc(const TMat&lt;double&gt;&amp; A, const TVec&lt;double&gt;&amp; x, const TVec&lt;double&gt;&amp; y)
+inline void externalProductAcc(const TMat&lt;double&gt;&amp; A,
+                               const TVec&lt;double&gt;&amp; x,
+                               const TVec&lt;double&gt;&amp; y)
 { externalProductScaleAcc(A, x, y, 1.); }
 
-inline void product(const TVec&lt;double&gt;&amp; vec, const TMat&lt;double&gt;&amp; m, const TVec&lt;double&gt;&amp; v)
+inline void product(const TVec&lt;double&gt;&amp; vec, const TMat&lt;double&gt;&amp; m,
+                    const TVec&lt;double&gt;&amp; v)
 { productScaleAcc(vec, m, false, v, 1., 0.); }
 
-inline void productAcc(const TVec&lt;double&gt;&amp; vec, const TMat&lt;double&gt;&amp; m, const TVec&lt;double&gt;&amp; v)
+inline void productAcc(const TVec&lt;double&gt;&amp; vec, const TMat&lt;double&gt;&amp; m,
+                       const TVec&lt;double&gt;&amp; v)
 { productScaleAcc(vec, m, false, v, 1., 1.); }
 
 inline void productScaleAcc(const TVec&lt;double&gt;&amp; vec, const TMat&lt;double&gt;&amp; m,
                             const TVec&lt;double&gt;&amp; v, double alpha, double beta)
 { productScaleAcc(vec, m, false, v, alpha, beta); }
 
-inline void transposeProduct(const TVec&lt;double&gt;&amp; vec, const TMat&lt;double&gt;&amp; m, const TVec&lt;double&gt;&amp; v)
+inline void transposeProduct(const TVec&lt;double&gt;&amp; vec, const TMat&lt;double&gt;&amp; m,
+                             const TVec&lt;double&gt;&amp; v)
 { productScaleAcc(vec, m, true, v, 1., 0.); }
 
-inline void transposeProductAcc(const TVec&lt;double&gt;&amp; vec, const TMat&lt;double&gt;&amp; m, const TVec&lt;double&gt;&amp; v)
+inline void transposeProductAcc(const TVec&lt;double&gt;&amp; vec, const TMat&lt;double&gt;&amp; m,
+                                const TVec&lt;double&gt;&amp; v)
 { productScaleAcc(vec, m, true, v, 1., 1.); }
 
 inline void transposeProductScaleAcc(const TVec&lt;double&gt;&amp; vec,
@@ -324,19 +348,25 @@
                                      double alpha, double beta)
 { productScaleAcc(vec, m, true, v, alpha, beta); }
 
-inline void product(const TMat&lt;double&gt;&amp; mat, const TMat&lt;double&gt;&amp; m1, const TMat&lt;double&gt;&amp; m2)
+inline void product(const TMat&lt;double&gt;&amp; mat, const TMat&lt;double&gt;&amp; m1,
+                    const TMat&lt;double&gt;&amp; m2)
 { productScaleAcc(mat, m1, false, m2, false, 1., 0.); }
 
-inline void transposeTransposeProduct(const TMat&lt;double&gt;&amp; mat, const TMat&lt;double&gt;&amp; m1, const TMat&lt;double&gt;&amp; m2)
+inline void transposeTransposeProduct(const TMat&lt;double&gt;&amp; mat,
+                                      const TMat&lt;double&gt;&amp; m1,
+                                      const TMat&lt;double&gt;&amp; m2)
 { productScaleAcc(mat, m1, true, m2, true, 1., 0.); }
 
-inline void transposeProduct(const TMat&lt;double&gt;&amp; mat, const TMat&lt;double&gt;&amp; m1, const TMat&lt;double&gt;&amp; m2)
+inline void transposeProduct(const TMat&lt;double&gt;&amp; mat, const TMat&lt;double&gt;&amp; m1,
+                             const TMat&lt;double&gt;&amp; m2)
 { productScaleAcc(mat, m1, true, m2, false, 1., 0.); }
 
-inline void productTranspose(const TMat&lt;double&gt;&amp; mat, const TMat&lt;double&gt;&amp; m1, const TMat&lt;double&gt;&amp; m2)
+inline void productTranspose(const TMat&lt;double&gt;&amp; mat, const TMat&lt;double&gt;&amp; m1,
+                             const TMat&lt;double&gt;&amp; m2)
 { productScaleAcc(mat, m1, false, m2, true, 1., 0.); }
 
-inline void productAcc(const TMat&lt;double&gt;&amp; mat, const TMat&lt;double&gt;&amp; m1, const TMat&lt;double&gt;&amp; m2)
+inline void productAcc(const TMat&lt;double&gt;&amp; mat, const TMat&lt;double&gt;&amp; m1,
+                       const TMat&lt;double&gt;&amp; m2)
 { productScaleAcc(mat, m1, false, m2, false, 1., 1.); }
 
 inline void productScaleAcc(const TMat&lt;double&gt;&amp; mat,
@@ -344,7 +374,9 @@
                             double alpha, double beta)
 { productScaleAcc(mat, m1, false, m2, false, alpha, beta); }
 
-inline void transposeTransposeProductAcc(const TMat&lt;double&gt;&amp; mat, const TMat&lt;double&gt;&amp; m1, const TMat&lt;double&gt;&amp; m2)
+inline void transposeTransposeProductAcc(const TMat&lt;double&gt;&amp; mat,
+                                         const TMat&lt;double&gt;&amp; m1,
+                                         const TMat&lt;double&gt;&amp; m2)
 { productScaleAcc(mat, m1, true, m2, true, 1., 1.); }
 
 inline void transposeTransposeProductScaleAcc(const TMat&lt;double&gt;&amp; mat,
@@ -353,7 +385,9 @@
                                               double alpha, double beta)
 { productScaleAcc(mat, m1, true, m2, true, alpha, beta); }
 
-inline void transposeProductAcc(const TMat&lt;double&gt;&amp; mat, const TMat&lt;double&gt;&amp; m1, const TMat&lt;double&gt;&amp; m2)
+inline void transposeProductAcc(const TMat&lt;double&gt;&amp; mat,
+                                const TMat&lt;double&gt;&amp; m1,
+                                const TMat&lt;double&gt;&amp; m2)
 { productScaleAcc(mat, m1, true, m2, false, 1., 1.); }
 
 inline void transposeProductScaleAcc(const TMat&lt;double&gt;&amp; mat,
@@ -362,7 +396,9 @@
                                      double alpha, double beta)
 { productScaleAcc(mat, m1, true, m2, false, alpha, beta); }
 
-inline void productTransposeAcc(const TMat&lt;double&gt;&amp; mat, const TMat&lt;double&gt;&amp; m1, const TMat&lt;double&gt;&amp; m2)
+inline void productTransposeAcc(const TMat&lt;double&gt;&amp; mat,
+                                const TMat&lt;double&gt;&amp; m1,
+                                const TMat&lt;double&gt;&amp; m2)
 { productScaleAcc(mat, m1, false, m2, true, 1., 1.); }
 
 inline void productTransposeScaleAcc(const TMat&lt;double&gt;&amp; mat,
@@ -376,9 +412,13 @@
 // float
 
 
-//  C = alpha A.B + beta C
-// ( Will use the transpose of A and/or B instead, if you set the corresponding flags to true)
-inline void productScaleAcc(const TMat&lt;float&gt;&amp; C, const TMat&lt;float&gt;&amp; A, bool transposeA, const TMat&lt;float&gt;&amp; B, bool transposeB, float alpha, float beta)
+//! C = alpha A.B + beta C
+// (Will use the transpose of A and/or B instead, if you set the corresponding
+// flags to true)
+inline void productScaleAcc(const TMat&lt;float&gt;&amp; C,
+                            const TMat&lt;float&gt;&amp; A, bool transposeA,
+                            const TMat&lt;float&gt;&amp; B, bool transposeB,
+                            float alpha, float beta)
 {
 #ifdef BOUNDCHECK
     int l2;
@@ -416,9 +456,10 @@
 
 #ifdef BOUNDCHECK
     if (w1!=l2 || C.length()!=l1 || C.width()!=w2)
-        PLERROR(&quot;productScaleAcc, incompatible arguments (%dx%d) &lt;- %s(%dx%d) . %s(%dx%d)&quot;,
-                C.length(), C.width(), 
-                transposeA?&quot;transpose&quot;:&quot;&quot;, A.length(), A.width(), 
+        PLERROR(&quot;productScaleAcc, incompatible arguments:\n&quot;
+                &quot;(%dx%d) &lt;- %s(%dx%d) . %s(%dx%d)&quot;,
+                C.length(), C.width(),
+                transposeA?&quot;transpose&quot;:&quot;&quot;, A.length(), A.width(),
                 transposeB?&quot;transpose&quot;:&quot;&quot;, B.length(), B.width());
 #endif
 
@@ -429,22 +470,30 @@
     if (A.isNull() || B.isNull() || C.isNull()) // Size zero ; don't bother
         return;                                 // with actual calculation
 
-    sgemm_(&amp;transb, &amp;transa, &amp;w2, &amp;l1, &amp;w1, &amp;alpha, B.data(), &amp;ldb, A.data(), &amp;lda, &amp;beta, C.data(), &amp;ldc);
+    sgemm_(&amp;transb, &amp;transa, &amp;w2, &amp;l1, &amp;w1, &amp;alpha, B.data(), &amp;ldb, A.data(),
+           &amp;lda, &amp;beta, C.data(), &amp;ldc);
 }
 
-//! y &lt;- alpha A.x + beta y   (will use the transposed of A instead if tranposeA is true)
-inline void productScaleAcc(const TVec&lt;float&gt;&amp; y, const TMat&lt;float&gt;&amp; A, bool transposeA, const TVec&lt;float&gt;&amp; x, float alpha, float beta)
+//! y &lt;- alpha A.x + beta y
+// (will use the transposed of A instead if tranposeA is true)
+inline void productScaleAcc(const TVec&lt;float&gt;&amp; y,
+                            const TMat&lt;float&gt;&amp; A, bool transposeA,
+                            const TVec&lt;float&gt;&amp; x, float alpha, float beta)
 {
 #ifdef BOUNDCHECK
     if(!transposeA)
     {
         if(A.length()!=y.length() || A.width()!=x.length())
-            PLERROR(&quot;productScaleAcc, incompatible arguments Vec(%d) &lt;- Mat(%d,%d) . Vec(%d)&quot;, y.length(), A.length(), A.width(), x.length());
+            PLERROR(&quot;productScaleAcc, incompatible arguments:\n&quot;
+                    &quot;Vec(%d) &lt;- Mat(%d,%d) . Vec(%d)&quot;,
+                    y.length(), A.length(), A.width(), x.length());
     }
     else
     {
         if(A.length()!=x.length() || A.width()!=y.length())
-            PLERROR(&quot;productScaleAcc, incompatible arguments Vec(%d) &lt;- Mat(%d,%d)' . Vec(%d)&quot;, y.length(), A.length(), A.width(), x.length());
+            PLERROR(&quot;productScaleAcc, incompatible arguments:\n&quot;
+                    &quot;Vec(%d) &lt;- Mat(%d,%d)' . Vec(%d)&quot;,
+                    y.length(), A.length(), A.width(), x.length());
     }
 #endif
 
@@ -454,15 +503,19 @@
       int m = A.width();
       int n = A.length();
 
-      sgemv_(&amp;trans, &amp;m, &amp;n, &amp;alpha, A.data(), &amp;lda, x.data(), &amp;one, &amp;beta, y.data(), &amp;one);
+      sgemv_(&amp;trans, &amp;m, &amp;n, &amp;alpha, A.data(), &amp;lda, x.data(), &amp;one, &amp;beta,
+             y.data(), &amp;one);
 }
 
 //! A &lt;- A + alpha x.y'
-inline void externalProductScaleAcc(const TMat&lt;float&gt;&amp; A, const TVec&lt;float&gt;&amp; x, const TVec&lt;float&gt;&amp; y, float alpha)
+inline void externalProductScaleAcc(const TMat&lt;float&gt;&amp; A, const TVec&lt;float&gt;&amp; x,
+                                    const TVec&lt;float&gt;&amp; y, float alpha)
 {
 #ifdef BOUNDCHECK
     if(A.length()!=x.length() || A.width()!=y.length())
-        PLERROR(&quot;In externalProductScaleAcc, incompatible dimensions: Mat(%d,%d) &lt;- Vec(%d).Vec(%d)'&quot;,A.length(), A.width(), x.length(), y.length());
+        PLERROR(&quot;In externalProductScaleAcc, incompatible dimensions:\n&quot;
+                &quot;Mat(%d,%d) &lt;- Vec(%d).Vec(%d)'&quot;,
+                A.length(), A.width(), x.length(), y.length());
 #endif
     int one = 1;
     int lda = A.mod();
@@ -475,23 +528,28 @@
     sger_(&amp;m, &amp;n, &amp;alpha, y.data(), &amp;one, x.data(), &amp;one, A.data(), &amp;lda);
 }
 
-inline void externalProductAcc(const TMat&lt;float&gt;&amp; A, const TVec&lt;float&gt;&amp; x, const TVec&lt;float&gt;&amp; y)
+inline void externalProductAcc(const TMat&lt;float&gt;&amp; A, const TVec&lt;float&gt;&amp; x,
+                               const TVec&lt;float&gt;&amp; y)
 { externalProductScaleAcc(A, x, y, 1.); }
 
-inline void product(const TVec&lt;float&gt;&amp; vec, const TMat&lt;float&gt;&amp; m, const TVec&lt;float&gt;&amp; v)
+inline void product(const TVec&lt;float&gt;&amp; vec, const TMat&lt;float&gt;&amp; m,
+                    const TVec&lt;float&gt;&amp; v)
 { productScaleAcc(vec, m, false, v, 1., 0.); }
 
-inline void productAcc(const TVec&lt;float&gt;&amp; vec, const TMat&lt;float&gt;&amp; m, const TVec&lt;float&gt;&amp; v)
+inline void productAcc(const TVec&lt;float&gt;&amp; vec, const TMat&lt;float&gt;&amp; m,
+                       const TVec&lt;float&gt;&amp; v)
 { productScaleAcc(vec, m, false, v, 1., 1.); }
 
 inline void productScaleAcc(const TVec&lt;float&gt;&amp; vec, const TMat&lt;float&gt;&amp; m,
                             const TVec&lt;float&gt;&amp; v, float alpha, float beta)
 { productScaleAcc(vec, m, false, v, alpha, beta); }
 
-inline void transposeProduct(const TVec&lt;float&gt;&amp; vec, const TMat&lt;float&gt;&amp; m, const TVec&lt;float&gt;&amp; v)
+inline void transposeProduct(const TVec&lt;float&gt;&amp; vec, const TMat&lt;float&gt;&amp; m,
+                             const TVec&lt;float&gt;&amp; v)
 { productScaleAcc(vec, m, true, v, 1., 0.); }
 
-inline void transposeProductAcc(const TVec&lt;float&gt;&amp; vec, const TMat&lt;float&gt;&amp; m, const TVec&lt;float&gt;&amp; v)
+inline void transposeProductAcc(const TVec&lt;float&gt;&amp; vec, const TMat&lt;float&gt;&amp; m,
+                                const TVec&lt;float&gt;&amp; v)
 { productScaleAcc(vec, m, true, v, 1., 1.); }
 
 inline void transposeProductScaleAcc(const TVec&lt;float&gt;&amp; vec,
@@ -500,19 +558,25 @@
                                      float alpha, float beta)
 { productScaleAcc(vec, m, true, v, alpha, beta); }
 
-inline void product(const TMat&lt;float&gt;&amp; mat, const TMat&lt;float&gt;&amp; m1, const TMat&lt;float&gt;&amp; m2)
+inline void product(const TMat&lt;float&gt;&amp; mat, const TMat&lt;float&gt;&amp; m1,
+                    const TMat&lt;float&gt;&amp; m2)
 { productScaleAcc(mat, m1, false, m2, false, 1., 0.); }
 
-inline void transposeTransposeProduct(const TMat&lt;float&gt;&amp; mat, const TMat&lt;float&gt;&amp; m1, const TMat&lt;float&gt;&amp; m2)
+inline void transposeTransposeProduct(const TMat&lt;float&gt;&amp; mat,
+                                      const TMat&lt;float&gt;&amp; m1,
+                                      const TMat&lt;float&gt;&amp; m2)
 { productScaleAcc(mat, m1, true, m2, true, 1., 0.); }
 
-inline void transposeProduct(const TMat&lt;float&gt;&amp; mat, const TMat&lt;float&gt;&amp; m1, const TMat&lt;float&gt;&amp; m2)
+inline void transposeProduct(const TMat&lt;float&gt;&amp; mat, const TMat&lt;float&gt;&amp; m1,
+                             const TMat&lt;float&gt;&amp; m2)
 { productScaleAcc(mat, m1, true, m2, false, 1., 0.); }
 
-inline void productTranspose(const TMat&lt;float&gt;&amp; mat, const TMat&lt;float&gt;&amp; m1, const TMat&lt;float&gt;&amp; m2)
+inline void productTranspose(const TMat&lt;float&gt;&amp; mat, const TMat&lt;float&gt;&amp; m1,
+                             const TMat&lt;float&gt;&amp; m2)
 { productScaleAcc(mat, m1, false, m2, true, 1., 0.); }
 
-inline void productAcc(const TMat&lt;float&gt;&amp; mat, const TMat&lt;float&gt;&amp; m1, const TMat&lt;float&gt;&amp; m2)
+inline void productAcc(const TMat&lt;float&gt;&amp; mat, const TMat&lt;float&gt;&amp; m1,
+                       const TMat&lt;float&gt;&amp; m2)
 { productScaleAcc(mat, m1, false, m2, false, 1., 1.); }
 
 inline void productScaleAcc(const TMat&lt;float&gt;&amp; mat,
@@ -520,7 +584,9 @@
                             float alpha, float beta)
 { productScaleAcc(mat, m1, false, m2, false, alpha, beta); }
 
-inline void transposeTransposeProductAcc(const TMat&lt;float&gt;&amp; mat, const TMat&lt;float&gt;&amp; m1, const TMat&lt;float&gt;&amp; m2)
+inline void transposeTransposeProductAcc(const TMat&lt;float&gt;&amp; mat,
+                                         const TMat&lt;float&gt;&amp; m1,
+                                         const TMat&lt;float&gt;&amp; m2)
 { productScaleAcc(mat, m1, true, m2, true, 1., 1.); }
 
 inline void transposeTransposeProductScaleAcc(const TMat&lt;float&gt;&amp; mat,
@@ -529,7 +595,8 @@
                                               float alpha, float beta)
 { productScaleAcc(mat, m1, true, m2, true, alpha, beta); }
 
-inline void transposeProductAcc(const TMat&lt;float&gt;&amp; mat, const TMat&lt;float&gt;&amp; m1, const TMat&lt;float&gt;&amp; m2)
+inline void transposeProductAcc(const TMat&lt;float&gt;&amp; mat, const TMat&lt;float&gt;&amp; m1,
+                                const TMat&lt;float&gt;&amp; m2)
 { productScaleAcc(mat, m1, true, m2, false, 1., 1.); }
 
 inline void transposeProductScaleAcc(const TMat&lt;float&gt;&amp; mat,
@@ -538,7 +605,8 @@
                                      float alpha, float beta)
 { productScaleAcc(mat, m1, true, m2, false, alpha, beta); }
 
-inline void productTransposeAcc(const TMat&lt;float&gt;&amp; mat, const TMat&lt;float&gt;&amp; m1, const TMat&lt;float&gt;&amp; m2)
+inline void productTransposeAcc(const TMat&lt;float&gt;&amp; mat, const TMat&lt;float&gt;&amp; m1,
+                                const TMat&lt;float&gt;&amp; m2)
 { productScaleAcc(mat, m1, false, m2, true, 1., 1.); }
 
 inline void productTransposeScaleAcc(const TMat&lt;float&gt;&amp; mat,
@@ -686,7 +754,7 @@
 #endif
 #endif
 }
-	
+
 } // end of namespace PLearn
 
 #endif


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000427.html">[Plearn-commits] r6978 - trunk/plearn/math
</A></li>
	<LI>Next message: <A HREF="000429.html">[Plearn-commits] r6980 - trunk/plearn_learners/online
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#428">[ date ]</a>
              <a href="thread.html#428">[ thread ]</a>
              <a href="subject.html#428">[ subject ]</a>
              <a href="author.html#428">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/plearn-commits">More information about the Plearn-commits
mailing list</a><br>
</body></html>
