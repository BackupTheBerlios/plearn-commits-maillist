<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Plearn-commits] r6985 - trunk/plearn/math
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/plearn-commits/2007-May/index.html" >
   <LINK REL="made" HREF="mailto:plearn-commits%40lists.berlios.de?Subject=Re%3A%20%5BPlearn-commits%5D%20r6985%20-%20trunk/plearn/math&In-Reply-To=%3C200705030517.l435HpCe019322%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000433.html">
   <LINK REL="Next"  HREF="000435.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Plearn-commits] r6985 - trunk/plearn/math</H1>
    <B>lamblin at BerliOS</B> 
    <A HREF="mailto:plearn-commits%40lists.berlios.de?Subject=Re%3A%20%5BPlearn-commits%5D%20r6985%20-%20trunk/plearn/math&In-Reply-To=%3C200705030517.l435HpCe019322%40sheep.berlios.de%3E"
       TITLE="[Plearn-commits] r6985 - trunk/plearn/math">lamblin at mail.berlios.de
       </A><BR>
    <I>Thu May  3 07:17:51 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000433.html">[Plearn-commits] r6984 - in	trunk/plearn_learners/online/test/DeepBeliefNet/.pytest/PL_DBN_SimpleRBM/expected_results/expdir:	. Split0 Split0/LearnerExpdir
</A></li>
        <LI>Next message: <A HREF="000435.html">[Plearn-commits] r6986 - trunk/plearn_learners/online
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#434">[ date ]</a>
              <a href="thread.html#434">[ thread ]</a>
              <a href="subject.html#434">[ subject ]</a>
              <a href="author.html#434">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: lamblin
Date: 2007-05-03 07:17:49 +0200 (Thu, 03 May 2007)
New Revision: 6985

Modified:
   trunk/plearn/math/TMat_maths_impl.h
Log:
* Fix a bug in transposeTransposeProductAcc and
transposeTransposeProductScaleAcc
* Fixed some functions when sizes were 0
* More accurate and explicit error messages
* Code reformatting
* Removed tabs and trailing spaces



Modified: trunk/plearn/math/TMat_maths_impl.h
===================================================================
--- trunk/plearn/math/TMat_maths_impl.h	2007-05-03 04:10:52 UTC (rev 6984)
+++ trunk/plearn/math/TMat_maths_impl.h	2007-05-03 05:17:49 UTC (rev 6985)
@@ -7,18 +7,18 @@
 
 // Redistribution and use in source and binary forms, with or without
 // modification, are permitted provided that the following conditions are met:
-// 
+//
 //  1. Redistributions of source code must retain the above copyright
 //     notice, this list of conditions and the following disclaimer.
-// 
+//
 //  2. Redistributions in binary form must reproduce the above copyright
 //     notice, this list of conditions and the following disclaimer in the
 //     documentation and/or other materials provided with the distribution.
-// 
+//
 //  3. The name of the authors may not be used to endorse or promote
 //     products derived from this software without specific prior written
 //     permission.
-// 
+//
 // THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
 // IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 // OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
@@ -29,14 +29,14 @@
 // LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-// 
+//
 // This file is part of the PLearn library. For more information on the PLearn
 // library, go to the PLearn Web site at www.plearn.org
 
 
- 
 
-/* *******************************************************      
+
+/* *******************************************************
  * $Id$
  * AUTHORS: Pascal Vincent &amp; Yoshua Bengio &amp; Rejean Ducharme &amp; Mantas Lukosevicius
  * This file is part of the PLearn library.
@@ -53,7 +53,7 @@
 namespace PLearn {
 using namespace std;
 
-template &lt;class T&gt; 
+template &lt;class T&gt;
 TVec&lt;T&gt; sign(const TVec&lt;T&gt;&amp; vec)
 {
     int len = vec.length();
@@ -62,17 +62,17 @@
     if (len &gt; 0) {
         T*  v   = vec.data();
         T*  s   = sign_.data();
-        
+
         while(--len &gt;= 0)
         {
             *s = sign( *v );
-            v++; s++; 
+            v++; s++;
         }
     }
     return sign_;
 }
 
-template &lt;class T&gt; 
+template &lt;class T&gt;
 void compute_sign(const TVec&lt;T&gt;&amp; vec, const TVec&lt;T&gt;&amp; dest)
 {
     int len = vec.length();
@@ -82,7 +82,7 @@
         while(--len &gt;= 0)
         {
             *s = sign( *v );
-            v++; s++; 
+            v++; s++;
         }
     }
 }
@@ -107,10 +107,10 @@
 }
 
 // target is an integer between 0 and N-1
-// output is a vector of N discriminant functions 
+// output is a vector of N discriminant functions
 // (each of which tries to separate class i from the others)
-template &lt;class T&gt; 
-real one_against_all_hinge_loss(const TVec&lt;T&gt;&amp; output, 
+template &lt;class T&gt;
+real one_against_all_hinge_loss(const TVec&lt;T&gt;&amp; output,
                                 const int target)
 {
     int N = output.length();
@@ -130,11 +130,11 @@
 }
 
 // target is an integer between 0 and N-1
-// output is a vector of N discriminant functions 
+// output is a vector of N discriminant functions
 // (each of which tries to separate class i from the others)
 // compute derivative of hinge loss wrt each output, in d_output
-template &lt;class T&gt; 
-void one_against_all_hinge_loss_bprop(const TVec&lt;T&gt;&amp; output, 
+template &lt;class T&gt;
+void one_against_all_hinge_loss_bprop(const TVec&lt;T&gt;&amp; output,
                                       const int target,
                                       TVec&lt;T&gt; d_output)
 {
@@ -216,7 +216,7 @@
 }
 
 //! computes y &lt;- exp(x)
-template &lt;class T&gt; 
+template &lt;class T&gt;
 void exp(const TVec&lt;T&gt;&amp; x, TVec&lt;T&gt;&amp; y)
 {
     y.resize(x.length());
@@ -230,7 +230,7 @@
 }
 
 //! returns the sum of squared elements
-template&lt;class T&gt; 
+template&lt;class T&gt;
 T sumsquare(const TVec&lt;T&gt;&amp; x)
 {
     if (x.length() == 0)
@@ -244,7 +244,7 @@
 }
 
 //! returns the sum of absolute values of elements
-template&lt;class T&gt; 
+template&lt;class T&gt;
 T sumabs(const TVec&lt;T&gt;&amp; x)
 {
     if (x.length() == 0)
@@ -292,9 +292,9 @@
 }
 
 //! returns the sum of squared elements
-template&lt;class T&gt; 
+template&lt;class T&gt;
 T sumsquare(const TMat&lt;T&gt;&amp; m)
-{  
+{
     if (m.size()==0)
         return T(0);
     if(m.isCompact())
@@ -321,9 +321,9 @@
 
 
 //! returns the sum of absolute value of the elements
-template&lt;class T&gt; 
+template&lt;class T&gt;
 T sumabs(const TMat&lt;T&gt;&amp; m)
-{  
+{
     if (m.size()==0)
         return T(0);
     if(m.isCompact())
@@ -349,7 +349,7 @@
 }
 
 // res[i,j] = scale*(mat[i,j] - avg[i] - avg[j] + mean(avg))
-template&lt;class T&gt; 
+template&lt;class T&gt;
 void doubleCentering(const TMat&lt;T&gt;&amp; mat, TVec&lt;T&gt;&amp; avg, TMat&lt;T&gt;&amp; res, T scale=T(1))
 {
     T moy = mean(avg);
@@ -646,11 +646,11 @@
         }
         else if (!ignore_missing)
             return MISSING_VALUE;
-    }  
+    }
     if (n == 0)
         return MISSING_VALUE;
     else
-    	return T(res/n);
+        return T(res/n);
 }
 
 template&lt;class T&gt;
@@ -714,7 +714,7 @@
 }
 
 
-template &lt;class T&gt; 
+template &lt;class T&gt;
 T max(const TVec&lt;T&gt;&amp; vec)
 {
 #ifdef BOUNDCHECK
@@ -792,7 +792,7 @@
             minval = a;
         }
     }
-  
+
     return minval;
 }
 
@@ -836,7 +836,7 @@
                          &quot;at index %d and ignore_missing is false.&quot;, i);
         }
 
-        if( indexmax == -1 || 
+        if( indexmax == -1 ||
             v[i] &gt; maxval   )
         {
             maxval = v[i];
@@ -886,7 +886,7 @@
                          &quot;at index %d and ignore_missing is false.&quot;, i);
         }
 
-        if( indexmin == -1 || 
+        if( indexmin == -1 ||
             v[i] &lt; minval   )
         {
             minval = v[i];
@@ -952,7 +952,7 @@
 inline T norm(const TVec&lt;T&gt;&amp; vec) { return norm(vec,T(2.0)); }
 
 template&lt;class T&gt;
-void normalize(const TVec&lt;T&gt;&amp; vec, double n=2) 
+void normalize(const TVec&lt;T&gt;&amp; vec, double n=2)
 { vec /= norm(vec,n); }
 
 //! Compute ||vec1 - vec2||_n^n.
@@ -1022,11 +1022,11 @@
 }
 
 template&lt;class T&gt;
-inline T L2distance(const TVec&lt;T&gt;&amp; vec1, const TVec&lt;T&gt;&amp; vec2) 
+inline T L2distance(const TVec&lt;T&gt;&amp; vec1, const TVec&lt;T&gt;&amp; vec2)
 { return dist(vec1, vec2, 2.0); }
 
 template&lt;class T&gt;
-inline T L1distance(const TVec&lt;T&gt;&amp; vec1, const TVec&lt;T&gt;&amp; vec2) 
+inline T L1distance(const TVec&lt;T&gt;&amp; vec1, const TVec&lt;T&gt;&amp; vec2)
 { return dist(vec1, vec2, 1.0); }
 
 
@@ -1169,7 +1169,7 @@
     if (vec.size() &gt; 0) {
         T* p = vec.data();
         int l = vec.length();
-        for (int i=0;i&lt;l;i++) 
+        for (int i=0;i&lt;l;i++)
             *p++ *= factor;
     }
 }
@@ -1190,7 +1190,7 @@
 }
 
 template&lt;class T&gt;
-inline void operator/=(const TVec&lt;T&gt;&amp; vec, T scalar) 
+inline void operator/=(const TVec&lt;T&gt;&amp; vec, T scalar)
 { vec *= T(1.0)/scalar; }
 
 template&lt;class T&gt;
@@ -1632,7 +1632,7 @@
 //{ return v1/T(scalar); }
 
 template&lt;class T&gt;
-T logadd(const TVec&lt;T&gt;&amp; vec) 
+T logadd(const TVec&lt;T&gt;&amp; vec)
 {
     int l = vec.length();
     if(l==0)
@@ -1808,7 +1808,7 @@
 
 // destination[i] = source1[i] + source2[i]*source3
 template&lt;class T&gt;
-void multiplyAdd(const TVec&lt;T&gt;&amp; source1, const TVec&lt;T&gt;&amp; source2, 
+void multiplyAdd(const TVec&lt;T&gt;&amp; source1, const TVec&lt;T&gt;&amp; source2,
                  T source3, TVec&lt;T&gt;&amp; destination)
 {
     int n=source1.length();
@@ -2067,10 +2067,10 @@
     }
 }
 
-template&lt;class T&gt; 
-TVec&lt;T&gt; 
-exp(const TVec&lt;T&gt;&amp; vec) 
-{ 
+template&lt;class T&gt;
+TVec&lt;T&gt;
+exp(const TVec&lt;T&gt;&amp; vec)
+{
     TVec&lt;T&gt; res( vec.length() );
     exp( vec, res );
     return res;
@@ -2093,7 +2093,7 @@
     indices.resize(ni);
     return indices;
 }
-        
+
 // return indices of non-zero elements
 template&lt;class T&gt;
 TVec&lt;T&gt; nonZeroIndices(TVec&lt;bool&gt; v)
@@ -2115,7 +2115,7 @@
 // Set the complement indices, i.e. if 0&lt;=i&lt;n is not an element
 // of the indices vector it is put in the complement_indices vector.
 template&lt;class T&gt;
-void complement_indices(TVec&lt;T&gt;&amp; indices, int n, 
+void complement_indices(TVec&lt;T&gt;&amp; indices, int n,
                         TVec&lt;T&gt;&amp; complement_indices,
                         TVec&lt;T&gt;&amp; buffer)
 {
@@ -2156,7 +2156,7 @@
 {
     int n=first.length();
     if(n!=second.length() || n!=dest.length())
-        PLERROR(&quot;isLargerThan(TVec&lt;T&gt;(%d), TVec&lt;T&gt;(%d), TVec&lt;T&gt;(%d)) args of unequal length&quot;, 
+        PLERROR(&quot;isLargerThan(TVec&lt;T&gt;(%d), TVec&lt;T&gt;(%d), TVec&lt;T&gt;(%d)) args of unequal length&quot;,
                 n, second.length(), dest.length());
     if (n &gt; 0) {
         T* f=first.data();
@@ -2173,7 +2173,7 @@
 {
     int n=first.length();
     if(n!=second.length() || n!=dest.length())
-        PLERROR(&quot;isLargerThan(TVec&lt;T&gt;(%d), TVec&lt;T&gt;(%d), TVec&lt;T&gt;(%d)) args of unequal length&quot;, 
+        PLERROR(&quot;isLargerThan(TVec&lt;T&gt;(%d), TVec&lt;T&gt;(%d), TVec&lt;T&gt;(%d)) args of unequal length&quot;,
                 n, second.length(), dest.length());
     if (n &gt; 0) {
         T* f=first.data();
@@ -2190,7 +2190,7 @@
 {
     int n=first.length();
     if(n!=second.length() || n!=dest.length())
-        PLERROR(&quot;isLargerThan(TVec&lt;T&gt;(%d), TVec&lt;T&gt;(%d), TVec&lt;T&gt;(%d)) args of unequal length&quot;, 
+        PLERROR(&quot;isLargerThan(TVec&lt;T&gt;(%d), TVec&lt;T&gt;(%d), TVec&lt;T&gt;(%d)) args of unequal length&quot;,
                 n, second.length(), dest.length());
     if (n &gt; 0) {
         T* f=first.data();
@@ -2200,14 +2200,14 @@
             d[i] = f[i] &lt; s[i];
     }
 }
-  
+
 // dest[i] = 1 if first[i] &lt;= second[i], 0 otherwise
 template&lt;class T&gt;
 void isSmallerThanOrEqualTo(const TVec&lt;T&gt;&amp; first, const TVec&lt;T&gt;&amp; second, TVec&lt;T&gt;&amp; dest)
 {
     int n=first.length();
     if(n!=second.length() || n!=dest.length())
-        PLERROR(&quot;isLargerThan(TVec&lt;T&gt;(%d), TVec&lt;T&gt;(%d), TVec&lt;T&gt;(%d)) args of unequal length&quot;, 
+        PLERROR(&quot;isLargerThan(TVec&lt;T&gt;(%d), TVec&lt;T&gt;(%d), TVec&lt;T&gt;(%d)) args of unequal length&quot;,
                 n, second.length(), dest.length());
     if (n &gt; 0) {
         T* f=first.data();
@@ -2223,15 +2223,15 @@
 void ifThenElse(const TVec&lt;T&gt;&amp; if_vec, const TVec&lt;T&gt;&amp; then_vec,
                 const TVec&lt;T&gt;&amp; else_vec, TVec&lt;T&gt;&amp; dest)
 {
-    int n=if_vec.length(); 
+    int n=if_vec.length();
     if (n!=then_vec.length() || n!=else_vec.length() || n!=dest.length())
-        PLERROR(&quot;ifThenElse(TVec&lt;T&gt;(%d), TVec&lt;T&gt;(%d), TVec&lt;T&gt;(%d), TVec&lt;T&gt;(%d)) args of unequal lengths&quot;, 
+        PLERROR(&quot;ifThenElse(TVec&lt;T&gt;(%d), TVec&lt;T&gt;(%d), TVec&lt;T&gt;(%d), TVec&lt;T&gt;(%d)) args of unequal lengths&quot;,
                 n, then_vec.length(), else_vec.length(), dest.length());
     if (n &gt; 0) {
         T* i_=if_vec.data();
         T* t_=then_vec.data();
         T* e_=else_vec.data();
-        T* d_=dest.data();  
+        T* d_=dest.data();
         for (int i=0;i&lt;n;i++)
             d_[i] = i_[i] ? t_[i] : e_[i];
     }
@@ -2296,7 +2296,7 @@
     if(k&lt;0 || k&gt;=vec.length())
         PLERROR(&quot;In positionOfkthOrderedElement, k out of bounds&quot;);
 #endif
-  
+
     T* v = vec.data();
 
     T minval = -FLT_MAX;
@@ -2331,13 +2331,13 @@
 //!  returns the value of the kth ordered element of v
 //!  k can take values 0 to vec.length()-1
 template&lt;class T&gt;
-inline T kthOrderedElement(const TVec&lt;T&gt;&amp; vec, int k) 
+inline T kthOrderedElement(const TVec&lt;T&gt;&amp; vec, int k)
 { return vec[positionOfkthOrderedElement(vec,k)]; }
 
 //!  returns the median value of vec
 template&lt;class T&gt;
 inline T median(const TVec&lt;T&gt;&amp; vec)
-{ return kthOrderedElement(vec, (vec.length()-1)/2); } 
+{ return kthOrderedElement(vec, (vec.length()-1)/2); }
 
 
 //-------------- These were previouslty methods of TVec ----------------------------------
@@ -2349,17 +2349,17 @@
 T selectAndOrder(const TVec&lt;T&gt;&amp; vec, int pos)
 {
     if (pos&lt;0 || pos&gt;=vec.length()) PLERROR(&quot;Bad position (%d)&quot;, pos);
- 
+
     int l=0;
     int h=vec.length()-1;
     T* v = vec.data();
- 
+
     while (l&lt;h)
     {
         T p = v[(l+h)/2];
         int x = l;
         int y = h;
- 
+
         do
         {
             while (v[x]&lt;p) x++;
@@ -2371,11 +2371,11 @@
                 y--;
             }
         } while (x&lt;=y);
- 
+
         if (pos&gt;=x) l=x;
         else h=x-1;
     }
- 
+
     return v[l];
 }
 
@@ -2422,7 +2422,7 @@
     for(int i=0;i&lt;vec.length(); i++) if (v[i]&gt;0) w[j++]=v[i];
     return(w);
 }
- 
+
 /*!  returns the position of the element in the vector that is closest to value
   If is_sorted_vec is true the procedure assumes the vector's elements
   are sorted in ascending order and uses a dichotomy search.
@@ -2460,7 +2460,7 @@
 
 
 /*!  project the Vec x on the linear subspace ORTHOGONAL to the
-  subspace defined by the rows of the orthonormal_subspace matrix, 
+  subspace defined by the rows of the orthonormal_subspace matrix,
   which are ASSUMED to be ORTHORNORMAL. The method is
   based on substracting for each row v of the matrix
   the quantity v * x . v.
@@ -2647,17 +2647,32 @@
 template &lt;class T&gt;
 void product(const TVec&lt;T&gt;&amp; result, const TMat&lt;T&gt;&amp; m, const TVec&lt;T&gt;&amp; v)
 {
-    int l=m.width();
-    if (l!=v.length() || m.length()!=result.length())
-        PLERROR(&quot;product(TVec, TMat,TVec), incompatible arguments %dx%d times %d -&gt; %d&quot;,
-                m.length(),m.width(), v.length(),result.length());
+    int l = m.length();
+    int w = m.width();
+#ifdef BOUNDCHECK
+    if (l!=result.length() || w!=v.length())
+        PLERROR(&quot;product(TVec, TMat, TVec), incompatible arguments:\n&quot;
+                &quot;%d &lt;- %dx%d times %d&quot;,
+                result.length(), l, w, v.length());
+#endif
+
+    if (m.isEmpty() || v.isEmpty() || result.isEmpty())
+    {
+        // Size zero: no need to bother computing anything.
+        // In such a case, the result of the matrix-vector multiplication, if
+        // not empty, is necessarily zero, since R^0 = {0}.
+        if (!result.isEmpty())
+            result.clear();
+        return;
+    }
+
     T *rp = result.data();
     T *vp = v.data();
-    for (int i=0;i&lt;result.length();i++)
+    for (int i=0;i&lt;l;i++)
     {
         const T* mi = m[i];
         T s = 0;
-        for (int j=0;j&lt;l;j++)
+        for (int j=0;j&lt;w;j++)
             s += mi[j] * vp[j];
         rp[i] = s;
     }
@@ -2665,16 +2680,26 @@
 
 //!  result[i] += sum_j m[i,j] * v[j]
 template &lt;class T&gt;
-void productAcc(const TVec&lt;T&gt;&amp; vec, const TMat&lt;T&gt;&amp; m, const TVec&lt;T&gt;&amp; v)
+void productAcc(const TVec&lt;T&gt;&amp; result, const TMat&lt;T&gt;&amp; m, const TVec&lt;T&gt;&amp; v)
 {
     int l = m.length();
     int w = m.width();
 #ifdef BOUNDCHECK
-    if (w!=v.length() || l!=vec.length())
-        PLERROR(&quot;TVec::productAcc(TMat,TVec), incompatible arguments %dx%d times %d -&gt; %d&quot;,
-                m.length(),m.width(), v.length(),vec.length());
+    if (l!=result.length() || w!=v.length())
+        PLERROR(&quot;productAcc(TVec, TMat, TVec), incompatible arguments:\n&quot;
+                &quot;%d &lt;- %dx%d times %d&quot;,
+                result.length(), l, w, v.length());
 #endif
-    T* rp = vec.data();
+
+    if (m.isEmpty() || v.isEmpty() || result.isEmpty())
+    {
+        // Size zero: no need to bother computing anything.
+        // In such a case, the result of the matrix-vector multiplication, if
+        // not empty, is necessarily zero, since R^0 = {0}.
+        return;
+    }
+
+    T* rp = result.data();
     T* mp = m.data();
     T* vdata = v.data();
     int deltam = m.mod()-m.width();
@@ -2689,31 +2714,43 @@
     }
 }
 
-//!  vec[i] = alpha * sum_j m[i,j] * v[j] + beta * v[i]
+//!  result[i] = alpha * sum_j m[i,j] * v[j] + beta * v[i]
 //! (Will use the transpose of m if transpose_m is true)
 template &lt;class T&gt;
-void productScaleAcc(const TVec&lt;T&gt;&amp; vec, const TMat&lt;T&gt;&amp; m, bool transpose_m,
+void productScaleAcc(const TVec&lt;T&gt;&amp; result, const TMat&lt;T&gt;&amp; m, bool transpose_m,
                      const TVec&lt;T&gt;&amp; v, T alpha, T beta)
 {
     if (transpose_m)
-        transposeProductScaleAcc(vec, m, v, alpha, beta);
+        transposeProductScaleAcc(result, m, v, alpha, beta);
     else
-        productScaleAcc(vec, m, v, alpha, beta);
+        productScaleAcc(result, m, v, alpha, beta);
 }
 
-//!  vec[i] = alpha * sum_j m[i,j] * v[j] + beta * v[i]
+//!  result[i] = alpha * sum_j m[i,j] * v[j] + beta * v[i]
 template &lt;class T&gt;
-void productScaleAcc(const TVec&lt;T&gt;&amp; vec, const TMat&lt;T&gt;&amp; m, const TVec&lt;T&gt;&amp; v,
+void productScaleAcc(const TVec&lt;T&gt;&amp; result, const TMat&lt;T&gt;&amp; m, const TVec&lt;T&gt;&amp; v,
                      T alpha, T beta)
 {
     int l = m.length();
     int w = m.width();
 #ifdef BOUNDCHECK
-    if (w!=v.length() || l!=vec.length())
-        PLERROR(&quot;productScaleAcc(TVec,TMat,TVec), incompatible arguments %dx%d times %d -&gt; %d&quot;,
-                m.length(),m.width(), v.length(),vec.length());
+    if (l!=result.length() || w!=v.length())
+        PLERROR(&quot;productScaleAcc(TVec, TMat, TVec), incompatible arguments:\n&quot;
+                &quot;%d &lt;- %dx%d times %d&quot;,
+                result.length(), l, w, v.length());
 #endif
-    T* rp = vec.data();
+
+    if (m.isEmpty() || v.isEmpty() || result.isEmpty())
+    {
+        // Size zero: no need to bother computing anything.
+        // In such a case, the result of the matrix-vector multiplication, if
+        // not empty, is necessarily zero, since R^0 = {0}.
+        if (!result.isEmpty())
+            result *= beta;
+        return;
+    }
+
+    T* rp = result.data();
     T* mp = m.data();
     T* vdata = v.data();
     int deltam = m.mod()-m.width();
@@ -2736,9 +2773,24 @@
 void transposeProduct(const TVec&lt;T&gt;&amp; result, const TMat&lt;T&gt;&amp; m, const TVec&lt;T&gt;&amp; v)
 {
     int l=m.length();
-    if (l!=v.length() || m.width()!=result.length())
-        PLERROR(&quot;TVec::transposeProduct(TMat,TVec), incompatible arguments %dx%d' times %d -&gt; %d&quot;,
-                m.length(),m.width(), v.length(),result.length());
+    int w=m.width();
+#ifdef BOUNDCHECK
+    if (l!=v.length() || w!=result.length())
+        PLERROR(&quot;transposeProduct(TVec, TMat, TVec), incompatible arguments:\n&quot;
+                &quot;%d &lt;- %dx%d' times %d&quot;,
+                result.length(), l, w, v.length());
+#endif
+
+    if (m.isEmpty() || v.isEmpty() || result.isEmpty())
+    {
+        // Size zero: no need to bother computing anything.
+        // In such a case, the result of the matrix-vector multiplication, if
+        // not empty, is necessarily zero, since R^0 = {0}.
+        if (!result.isEmpty())
+            result.clear();
+        return;
+    }
+
     T *rp = result.data();
     T *vp = v.data();
     result.clear();
@@ -2753,40 +2805,54 @@
 
 //!  result[i] += sum_j m[j,i] * v[j]
 template &lt;class T&gt;
-void transposeProductAcc(const TVec&lt;T&gt;&amp; result, const TMat&lt;T&gt;&amp; m, const TVec&lt;T&gt;&amp; v)
+void transposeProductAcc(const TVec&lt;T&gt;&amp; result, const TMat&lt;T&gt;&amp; m,
+                         const TVec&lt;T&gt;&amp; v)
 {
     int l=m.length();
     int w=m.width();
+#ifdef BOUNDCHECK
     if (l!=v.length() || w!=result.length())
-        PLERROR(&quot;TVec::transposeProductAcc(TMat,TVec), incompatible arguments %dx%d' times %d -&gt; %d&quot;,
-                m.length(),m.width(), v.length(),result.length());
-    T* vecdata = result.data();
+        PLERROR(&quot;transposeProductAcc(TVec, TMat, TVec), incompatible arguments&quot;
+                &quot;:\n&quot;
+                &quot;%dx%d' times %d -&gt; %d&quot;,
+                result.length(), l, w, v.length());
+#endif
+
+    if (m.isEmpty() || v.isEmpty() || result.isEmpty())
+    {
+        // Size zero: no need to bother computing anything.
+        // In such a case, the result of the matrix-vector multiplication, if
+        // not empty, is necessarily zero, since R^0 = {0}.
+        return;
+    }
+
+    T* rdata = result.data();
     T* vp = v.data();
     T* mp = m.data();
     int deltam = m.mod()-m.width();
     for (int j=0;j&lt;l;j++)
     {
         T vj = *vp++;
-    
+
         /*
-          T* rp = vecdata;
+          T* rp = rdata;
           for (int i=0;i&lt;w;i++)
           *rp++ += vj * *mp++;
           mp += deltam;
         */
-    
+
         if(vj!=0)
         {
             if(vj==1)
             {
-                T* rp = vecdata;
+                T* rp = rdata;
                 for (int i=0;i&lt;w;i++)
                     *rp++ += *mp++;
                 mp += deltam;
             }
             else
             {
-                T* rp = vecdata;
+                T* rp = rdata;
                 for (int i=0;i&lt;w;i++)
                     *rp++ += vj * *mp++;
                 mp += deltam;
@@ -2803,15 +2869,30 @@
 {
     int l=m.length();
     int w=m.width();
+#ifdef BOUNDCHECK
     if (l!=v.length() || w!=result.length())
-        PLERROR(&quot;transposeProductScaleAcc(TVec,TMat,TVec), incompatible arguments %dx%d' times %d -&gt; %d&quot;,
-                m.length(),m.width(), v.length(),result.length());
-    T* vecdata = result.data();
+        PLERROR(&quot;transposeProductScaleAcc(TVec, TMat, TVec), incompatible&quot;
+                &quot; arguments:\n&quot;
+                &quot;%d &lt;- %dx%d' times %d&quot;,
+                result.length(), l, w, v.length());
+#endif
+
+    if (m.isEmpty() || v.isEmpty() || result.isEmpty())
+    {
+        // Size zero: no need to bother computing anything.
+        // In such a case, the result of the matrix-vector multiplication, if
+        // not empty, is necessarily zero, since R^0 = {0}.
+        if (!result.isEmpty())
+            result *= beta;
+        return;
+    }
+
+    T* rdata = result.data();
     T* vp = v.data();
     T* mp = m.data();
     int deltam = m.mod()-m.width();
 
-    T* rp = vecdata;
+    T* rp = rdata;
     // initial scaling
     for (int i=0;i&lt;w;i++)
         *rp++ *= beta;
@@ -2819,7 +2900,7 @@
     for (int j=0;j&lt;l;j++)
     {
         T vj = *vp++;
-        rp = vecdata;
+        rp = rdata;
         for (int i=0;i&lt;w;i++)
             *rp++ += alpha * vj * *mp++;
         mp += deltam;
@@ -2856,8 +2937,8 @@
             cout&lt;&lt;&quot;0x&quot;&lt;&lt;n&lt;&lt;&quot; &quot;;
             l-=n;
             if(mode==1)
-            {         
-                --l; 
+            {
+                --l;
                 result+=m(idx++); // !!!!!!
                 cout&lt;&lt;&quot;1 &quot;;
             }
@@ -2883,7 +2964,7 @@
                 --l;
             }
         }
-        else 
+        else
             PLERROR(&quot;BUG IN binread_compressed: mode is only 2 bits, so how can it be other than 0,1,2,3 ?&quot;);
     }
 
@@ -2937,14 +3018,14 @@
 //! gradients on dC/dU, dC/dd and dC/dV:
 //! dC/dU[i,k] += sum_j dC/dres[i,j] d_k V[k,j]
 //! dC/dd[k] += sum_{ij} dC/dres[i,j] U[i,k] V[k,j]
-//! dC/dV[k,j] += d_k * sum_i U[i,k] dC/dres[i,j] 
+//! dC/dV[k,j] += d_k * sum_i U[i,k] dC/dres[i,j]
 template&lt;class T&gt;
-void diagonalizedFactorsProductBprop(const TMat&lt;T&gt;&amp; dCdresult, const TMat&lt;T&gt;&amp; U, const TVec&lt;T&gt; d, 
+void diagonalizedFactorsProductBprop(const TMat&lt;T&gt;&amp; dCdresult, const TMat&lt;T&gt;&amp; U, const TVec&lt;T&gt; d,
                                      const TMat&lt;T&gt; V, TMat&lt;T&gt;&amp; dCdU, TVec&lt;T&gt;&amp; dCdd, TMat&lt;T&gt;&amp; dCdV)
 {
 #ifdef BOUNDCHECK
-    if (dCdU.length()!=U.length() || dCdU.width()!=U.width() || dCdd.length()!=d.length() 
-        || dCdV.length()!=V.length() || dCdV.width()!=V.width() || 
+    if (dCdU.length()!=U.length() || dCdU.width()!=U.width() || dCdd.length()!=d.length()
+        || dCdV.length()!=V.length() || dCdV.width()!=V.width() ||
         U.width()!=d.length() || V.length()!=d.length())
         PLERROR(&quot;diagonalizedFactorsProductBprop: incompatible arguments&quot;);
 #endif
@@ -3011,13 +3092,13 @@
 // dC/dd[k] = sum_{ij} dC/dres[i,j] U[i,k] V[j,k]
 // dC/dV[j,k] = sum_i dC/dres[i,j] d_k U[i,k]
 template&lt;class T&gt;
-void diagonalizedFactorsProductTransposeBprop(const TMat&lt;T&gt;&amp; dCdresult, const TMat&lt;T&gt;&amp; U, 
-                                              const TVec&lt;T&gt; d, const TMat&lt;T&gt; V, TMat&lt;T&gt;&amp; dCdU, 
+void diagonalizedFactorsProductTransposeBprop(const TMat&lt;T&gt;&amp; dCdresult, const TMat&lt;T&gt;&amp; U,
+                                              const TVec&lt;T&gt; d, const TMat&lt;T&gt; V, TMat&lt;T&gt;&amp; dCdU,
                                               TVec&lt;T&gt;&amp; dCdd, TMat&lt;T&gt;&amp; dCdV)
 {
 #ifdef BOUNDCHECK
-    if (dCdU.length()!=U.length() || dCdU.width()!=U.width() || dCdd.length()!=d.length() 
-        || dCdV.length()!=V.length() || dCdV.width()!=V.width() || 
+    if (dCdU.length()!=U.length() || dCdU.width()!=U.width() || dCdd.length()!=d.length()
+        || dCdV.length()!=V.length() || dCdV.width()!=V.width() ||
         U.width()!=d.length() || V.width()!=d.length())
         PLERROR(&quot;diagonalizedFactorsProductTransposeBprop: incompatible arguments&quot;);
 #endif
@@ -3084,13 +3165,13 @@
 // dC/dd[k] = sum_{ij} dC/dres[i,j] U[k,i] V[k,j]
 // dC/dV[k,j] = d_k sum_i dC/dres[i,j] U[k,i]
 template&lt;class T&gt;
-void diagonalizedFactorsTransposeProductBprop(const TMat&lt;T&gt;&amp; dCdresult, const TMat&lt;T&gt;&amp; U, 
-                                              const TVec&lt;T&gt; d, const TMat&lt;T&gt; V, TMat&lt;T&gt;&amp; dCdU, 
+void diagonalizedFactorsTransposeProductBprop(const TMat&lt;T&gt;&amp; dCdresult, const TMat&lt;T&gt;&amp; U,
+                                              const TVec&lt;T&gt; d, const TMat&lt;T&gt; V, TMat&lt;T&gt;&amp; dCdU,
                                               TVec&lt;T&gt;&amp; dCdd, TMat&lt;T&gt;&amp; dCdV)
 {
 #ifdef BOUNDCHECK
-    if (dCdU.length()!=U.length() || dCdU.width()!=U.width() || dCdd.length()!=d.length() 
-        || dCdV.length()!=V.length() || dCdV.width()!=V.width() || 
+    if (dCdU.length()!=U.length() || dCdU.width()!=U.width() || dCdd.length()!=d.length()
+        || dCdV.length()!=V.length() || dCdV.width()!=V.width() ||
         U.length()!=d.length() || V.length()!=d.length())
         PLERROR(&quot;diagonalizedFactorsTransposeProductBprop: incompatible arguments&quot;);
 #endif
@@ -3157,13 +3238,13 @@
 // dC/dd[k] = sum_{ij} dC/dres[i,j] U[k,i] V[j,k]
 // dC/dV[j,k] = d_k * sum_i dC/dres[i,j] U[k,i]
 template&lt;class T&gt;
-void diagonalizedFactorsTransposeProductTransposeBprop(const TMat&lt;T&gt;&amp; dCdresult, const TMat&lt;T&gt;&amp; U, 
-                                                       const TVec&lt;T&gt; d, const TMat&lt;T&gt; V, TMat&lt;T&gt;&amp; dCdU, 
+void diagonalizedFactorsTransposeProductTransposeBprop(const TMat&lt;T&gt;&amp; dCdresult, const TMat&lt;T&gt;&amp; U,
+                                                       const TVec&lt;T&gt; d, const TMat&lt;T&gt; V, TMat&lt;T&gt;&amp; dCdU,
                                                        TVec&lt;T&gt;&amp; dCdd, TMat&lt;T&gt;&amp; dCdV)
 {
 #ifdef BOUNDCHECK
-    if (dCdU.length()!=U.length() || dCdU.width()!=U.width() || dCdd.length()!=d.length() 
-        || dCdV.length()!=V.length() || dCdV.width()!=V.width() || 
+    if (dCdU.length()!=U.length() || dCdU.width()!=U.width() || dCdd.length()!=d.length()
+        || dCdV.length()!=V.length() || dCdV.width()!=V.width() ||
         U.length()!=d.length() || V.width()!=d.length())
         PLERROR(&quot;diagonalizedFactorsTransposeProductTransposeBprop: incompatible arguments&quot;);
 #endif
@@ -3321,12 +3402,13 @@
                 warning_flag = true;
             }
             value = (mat[i][j] + mat[j][i])/2;
-            mat[i][j] = value; mat[j][i] = value; 
+            mat[i][j] = value; mat[j][i] = value;
         }
     if (warning_flag)
         PLWARNING(&quot;At void makeItSymmetric, the maximum difference %f is not affordable\n&quot;, max_dif);
 }
 
+
 /* DEPRECATED, use product(TVec, TMat, TVec) instead
 // y[i] = sum_j A[i,j] x[j]
 
@@ -3351,18 +3433,30 @@
 }
 */
 
-// result[i,j] = sum_k m1[i,k] * m2[k,j]
+//! mat[i,j] = sum_k m1[i,k] * m2[k,j]
 template&lt;class T&gt;
 void product(const TMat&lt;T&gt;&amp; mat, const TMat&lt;T&gt;&amp; m1, const TMat&lt;T&gt;&amp; m2)
 {
-#ifdef BOUNDCHECK
-    if (m1.width()!=m2.length() || mat.length()!=m1.length() || mat.width()!=m2.width())
-        PLERROR(&quot;product(Mat,Mat), incompatible arguments %dx%d= %dx%d times %dx%d&quot;,
-                mat.length(),mat.width(),m1.length(),m1.width(), m2.length(),m2.width());
-#endif
     int n=m1.length();
     int m=m1.width();
     int l=m2.width();
+#ifdef BOUNDCHECK
+    if (n!=mat.length() || m!=m2.length() || l!=mat.width())
+        PLERROR(&quot;product(TMat, TMat, TMat), incompatible arguments:\n&quot;
+                &quot;%dx%d &lt;- %dx%d times %dx%d&quot;,
+                mat.length(), mat.width(), n, m, m2.length(), l);
+#endif
+
+    if (m1.isEmpty() || m2.isEmpty() || mat.isEmpty())
+    {
+        // Size zero: no need to bother computing anything.
+        // In such a case, the result of the matrix-matrix multiplication, if
+        // not empty, is necessarily zero, since R^0 = {0}.
+        if (!mat.isEmpty())
+            mat.clear();
+        return;
+    }
+
     for (int i=0;i&lt;n;i++)
     {
         const T* m1i = m1[i];
@@ -3378,18 +3472,28 @@
     }
 }
 
-// result[i,j] += sum_k m1[i,k] * m2[k,j]
+//! mat[i,j] += sum_k m1[i,k] * m2[k,j]
 template&lt;class T&gt;
 void productAcc(const TMat&lt;T&gt;&amp; mat, const TMat&lt;T&gt;&amp; m1, const TMat&lt;T&gt;&amp; m2)
 {
-#ifdef BOUNDCHECK
-    if (m1.width()!=m2.length() || mat.length()!=m1.length() || mat.width()!=m2.width())
-        PLERROR(&quot;productAcc(Mat,Mat), incompatible arguments %dx%d= %dx%d times %dx%d&quot;,
-                mat.length(),mat.width(),m1.length(),m1.width(), m2.length(),m2.width());
-#endif
     int n=m1.length();
     int m=m1.width();
     int l=m2.width();
+#ifdef BOUNDCHECK
+    if (n!=mat.length() || m!=m2.length() || l!=mat.width())
+        PLERROR(&quot;productAcc(TMat, TMat, TMat), incompatible arguments:\n&quot;
+                &quot;%dx%d &lt;- %dx%d times %dx%d&quot;,
+                mat.length(), mat.width(), n, m, m2.length(), l);
+#endif
+
+    if (m1.isEmpty() || m2.isEmpty() || mat.isEmpty())
+    {
+        // Size zero: no need to bother computing anything.
+        // In such a case, the result of the matrix-matrix multiplication, if
+        // not empty, is necessarily zero, since R^0 = {0}.
+        return;
+    }
+
     for (int i=0;i&lt;n;i++)
     {
         const T* m1i = m1[i];
@@ -3405,8 +3509,8 @@
     }
 }
 
-// mat[i,j] = alpha sum_k m1[i,k] * m2[k,j] + beta mat[i,j]
-// ( Will use the transpose of m1 and/or m2 instead,
+//! mat[i,j] = alpha sum_k m1[i,k] * m2[k,j] + beta mat[i,j]
+// (Will use the transpose of m1 and/or m2 instead,
 // if you set the corresponding flags to true)
 template&lt;class T&gt;
 void productScaleAcc(const TMat&lt;T&gt;&amp; mat,
@@ -3414,6 +3518,7 @@
                      const TMat&lt;T&gt;&amp; m2, bool transpose_m2,
                      T alpha, T beta)
 {
+    // Boundary checking is done in called functions
     if (transpose_m1)
         if (transpose_m2) // transpose_m1 &amp;&amp; transpose_m2
            transposeTransposeProductScaleAcc(mat, m1, m2, alpha, beta);
@@ -3426,19 +3531,31 @@
             productScaleAcc(mat, m1, m2, alpha, beta);
 }
 
-// mat[i,j] = alpha * sum_k m1[i,k] * m2[k,j] + beta * mat[i,j]
+//! mat[i,j] = alpha * sum_k m1[i,k] * m2[k,j] + beta * mat[i,j]
 template&lt;class T&gt;
 void productScaleAcc(const TMat&lt;T&gt;&amp; mat, const TMat&lt;T&gt;&amp; m1, const TMat&lt;T&gt;&amp; m2,
                      T alpha, T beta)
 {
-#ifdef BOUNDCHECK
-    if (m1.width()!=m2.length() || mat.length()!=m1.length() || mat.width()!=m2.width())
-        PLERROR(&quot;productScaleAcc(Mat,Mat,Mat), incompatible arguments %dx%d= %dx%d times %dx%d&quot;,
-                mat.length(),mat.width(),m1.length(),m1.width(), m2.length(),m2.width());
-#endif
     int n=m1.length();
     int m=m1.width();
     int l=m2.width();
+#ifdef BOUNDCHECK
+    if (n!=mat.length() || m!=m2.length() || l!=mat.width())
+        PLERROR(&quot;productScaleAcc(TMat, TMat, TMat), incompatible arguments:\n&quot;
+                &quot;%dx%d &lt;- %dx%d times %dx%d&quot;,
+                mat.length(), mat.width(), n, m, m2.length(), l);
+#endif
+
+    if (m1.isEmpty() || m2.isEmpty() || mat.isEmpty())
+    {
+        // Size zero: no need to bother computing anything.
+        // In such a case, the result of the matrix-matrix multiplication, if
+        // not empty, is necessarily zero, since R^0 = {0}.
+        if (!mat.isEmpty())
+            mat *= beta;
+        return;
+    }
+
     for (int i=0;i&lt;n;i++)
     {
         const T* m1i = m1[i];
@@ -3592,7 +3709,7 @@
     }
 }
 
-// mat[i][j] = alpha * mat[i][j] + gamma * v1[i] * v2[j] 
+// mat[i][j] = alpha * mat[i][j] + gamma * v1[i] * v2[j]
 template&lt;class T&gt;
 void externalProductScaleAcc(const TMat&lt;T&gt;&amp; mat, const TVec&lt;T&gt;&amp; v1, const TVec&lt;T&gt;&amp; v2, T gamma, T alpha)
 {
@@ -3656,18 +3773,30 @@
 }
 
 
-// result[i,j] = sum_k m1[i,k] * m2[j,k]
+//! mat[i,j] = sum_k m1[i,k] * m2[j,k]
 template&lt;class T&gt;
 void productTranspose(const TMat&lt;T&gt;&amp; mat, const TMat&lt;T&gt;&amp; m1, const TMat&lt;T&gt;&amp; m2)
 {
-#ifdef BOUNDCHECK
-    if (m1.width()!=m2.width() || mat.length()!=m1.length() || mat.width()!=m2.length())
-        PLERROR(&quot;productTranspose(Mat,Mat), incompatible arguments %dx%d= %dx%d times %dx%d'&quot;,
-                mat.length(),mat.width(),m1.length(),m1.width(), m2.length(),m2.width());
-#endif
     int n=m1.length();
     int m=m1.width();
     int l=m2.length();
+#ifdef BOUNDCHECK
+    if (n!=mat.length() || m!=m2.width() || l!=mat.width())
+        PLERROR(&quot;productTranspose(TMat, TMat, TMat), incompatible arguments:\n&quot;
+                &quot;%dx%d &lt;- %dx%d times %dx%d'&quot;,
+                mat.length(), mat.width(), n, m, l, m2.width());
+#endif
+
+    if (m1.isEmpty() || m2.isEmpty() || mat.isEmpty())
+    {
+        // Size zero: no need to bother computing anything.
+        // In such a case, the result of the matrix-matrix multiplication, if
+        // not empty, is necessarily zero, since R^0 = {0}.
+        if (!mat.isEmpty())
+            mat.clear();
+        return;
+    }
+
     for (int i=0;i&lt;n;i++)
     {
         const T* m1i = m1[i];
@@ -3712,7 +3841,7 @@
         }
     }
 }
-  
+
 // result[i,j] = sum_k m1[i,k] * m2[j,k]^2
 template&lt;class T&gt;
 void product2Transpose(const TMat&lt;T&gt;&amp; mat, const TMat&lt;T&gt;&amp; m1, const TMat&lt;T&gt;&amp; m2)
@@ -3743,18 +3872,30 @@
     }
 }
 
-// result[i,j] += sum_k m1[i,k] * m2[j,k]
+//! mat[i,j] += sum_k m1[i,k] * m2[j,k]
 template&lt;class T&gt;
-void productTransposeAcc(const TMat&lt;T&gt;&amp; mat, const TMat&lt;T&gt;&amp; m1, const TMat&lt;T&gt;&amp; m2)
+void productTransposeAcc(const TMat&lt;T&gt;&amp; mat, const TMat&lt;T&gt;&amp; m1,
+                         const TMat&lt;T&gt;&amp; m2)
 {
-#ifdef BOUNDCHECK
-    if (m1.width()!=m2.width() || mat.length()!=m1.length() || mat.width()!=m2.length())
-        PLERROR(&quot;productTransposeAcc(Mat,Mat), incompatible arguments %dx%d= %dx%d times %dx%d'&quot;,
-                mat.length(),mat.width(),m1.length(),m1.width(), m2.length(),m2.width());
-#endif
     int n=m1.length();
     int m=m1.width();
     int l=m2.length();
+#ifdef BOUNDCHECK
+    if (n!=mat.length() || m!=m2.width() || l!=mat.width())
+        PLERROR(&quot;productTransposeAcc(TMat, TMat, TMat), incompatible arguments&quot;
+                &quot;:\n&quot;
+                &quot;%dx%d &lt;- %dx%d times %dx%d'&quot;,
+                mat.length(), mat.width(), n, m, l, m2.width());
+#endif
+
+    if (m1.isEmpty() || m2.isEmpty() || mat.isEmpty())
+    {
+        // Size zero: no need to bother computing anything.
+        // In such a case, the result of the matrix-matrix multiplication, if
+        // not empty, is necessarily zero, since R^0 = {0}.
+        return;
+    }
+
     for (int i=0;i&lt;n;i++)
     {
         const T* m1i = m1[i];
@@ -3770,19 +3911,32 @@
     }
 }
 
-// mat[i,j] = alpha * sum_k m1[i,k] * m2[j,k] + beta * mat[i,j]
+//! mat[i,j] = alpha * sum_k m1[i,k] * m2[j,k] + beta * mat[i,j]
 template&lt;class T&gt;
 void productTransposeScaleAcc(const TMat&lt;T&gt;&amp; mat, const TMat&lt;T&gt;&amp; m1,
                               const TMat&lt;T&gt;&amp; m2, T alpha, T beta)
 {
-#ifdef BOUNDCHECK
-    if (m1.width()!=m2.width() || mat.length()!=m1.length() || mat.width()!=m2.length())
-        PLERROR(&quot;productTransposeScaleAcc(Mat,Mat,Mat), incompatible arguments %dx%d= %dx%d times %dx%d'&quot;,
-                mat.length(),mat.width(),m1.length(),m1.width(), m2.length(),m2.width());
-#endif
     int n=m1.length();
     int m=m1.width();
     int l=m2.length();
+#ifdef BOUNDCHECK
+    if (n!=mat.length() || m!=m2.width() || l!=mat.width())
+        PLERROR(&quot;productTransposeScaleAcc(TMat, TMat, TMat), incompatible&quot;
+                &quot; arguments:\n&quot;
+                &quot;%dx%d &lt;- %dx%d times %dx%d'&quot;,
+                mat.length(), mat.width(), n, m, l, m2.width());
+#endif
+
+    if (m1.isEmpty() || m2.isEmpty() || mat.isEmpty())
+    {
+        // Size zero: no need to bother computing anything.
+        // In such a case, the result of the matrix-matrix multiplication, if
+        // not empty, is necessarily zero, since R^0 = {0}.
+        if (!mat.isEmpty())
+            mat *= beta;
+        return;
+    }
+
     for (int i=0;i&lt;n;i++)
     {
         const T* m1i = m1[i];
@@ -3858,7 +4012,7 @@
     }
 }
 
-// result[i,j] = sum_k m1[k,i] * m2[k,j]
+//! mat[i,j] = sum_k m1[k,i] * m2[k,j]
 template&lt;class T&gt;
 void transposeProduct(const TMat&lt;T&gt;&amp; mat, const TMat&lt;T&gt;&amp; m1, const TMat&lt;T&gt;&amp; m2)
 {
@@ -3867,10 +4021,21 @@
     int l=m2.width();
 #ifdef BOUNDCHECK
     if (m!=m2.length() || mat.length()!=n || mat.width()!=l)
-        PLERROR(&quot;transposeProduct(Mat,Mat), incompatible arguments &quot;
-                &quot;%dx%d' times %dx%d into %dx%d&quot;,
-                m1.length(),m1.width(), m2.length(),m2.width(), mat.length(), mat.width());
+        PLERROR(&quot;transposeProduct(TMat, TMat, TMat), incompatible arguments:\n&quot;
+                &quot;%dx%d &lt;- %dx%d' times %dx%d&quot;,
+                mat.length(), mat.width(), m, n, m2.length(), l);
 #endif
+
+    if (m1.isEmpty() || m2.isEmpty() || mat.isEmpty())
+    {
+        // Size zero: no need to bother computing anything.
+        // In such a case, the result of the matrix-matrix multiplication, if
+        // not empty, is necessarily zero, since R^0 = {0}.
+        if (!mat.isEmpty())
+            mat.clear();
+        return;
+    }
+
     mat.clear();
     for (int i=0;i&lt;n;i++)
     {
@@ -3917,19 +4082,30 @@
     }
 }
 
-// result[i,j] += sum_k m1[k,i] * m2[k,j]
+//! mat[i,j] += sum_k m1[k,i] * m2[k,j]
 template&lt;class T&gt;
-void transposeProductAcc(const TMat&lt;T&gt;&amp; mat, const TMat&lt;T&gt;&amp; m1, const TMat&lt;T&gt;&amp; m2)
+void transposeProductAcc(const TMat&lt;T&gt;&amp; mat, const TMat&lt;T&gt;&amp; m1,
+                         const TMat&lt;T&gt;&amp; m2)
 {
     int n=m1.width();
     int m=m1.length();
     int l=m2.width();
 #ifdef BOUNDCHECK
     if (m!=m2.length() || mat.length()!=n || mat.width()!=l)
-        PLERROR(&quot;transposeProductAcc(Mat,Mat), incompatible arguments &quot;
-                &quot;%dx%d' times %dx%d into %dx%d&quot;,
-                m1.length(),m1.width(), m2.length(),m2.width(), mat.length(), mat.width());
+        PLERROR(&quot;transposeProductAcc(TMat, TMat, TMat), incompatible&quot;
+                &quot; arguments:\n&quot;
+                &quot;%dx%d &lt;- %dx%d' times %dx%d&quot;,
+                mat.length(), mat.width(), m, n, m2.length(), l);
 #endif
+
+    if (m1.isEmpty() || m2.isEmpty() || mat.isEmpty())
+    {
+        // Size zero: no need to bother computing anything.
+        // In such a case, the result of the matrix-matrix multiplication, if
+        // not empty, is necessarily zero, since R^0 = {0}.
+        return;
+    }
+
     for (int i=0;i&lt;n;i++)
     {
         T* m1ki = m1.data()+i;
@@ -3954,10 +4130,22 @@
     int l=m2.width();
 #ifdef BOUNDCHECK
     if (m!=m2.length() || mat.length()!=n || mat.width()!=l)
-        PLERROR(&quot;transposeProductScaleAcc(Mat,Mat,Mat), incompatible arguments &quot;
-                &quot;%dx%d' times %dx%d into %dx%d&quot;,
-                m1.length(),m1.width(), m2.length(),m2.width(), mat.length(), mat.width());
+        PLERROR(&quot;transposeProductScaleAcc(TMat, TMat, TMat), incompatible&quot;
+                &quot; arguments:\n&quot;
+                &quot;%dx%d &lt;- %dx%d' times %dx%d&quot;,
+                mat.length(), mat.width(), m, n, m2.length(), l);
 #endif
+
+    if (m1.isEmpty() || m2.isEmpty() || mat.isEmpty())
+    {
+        // Size zero: no need to bother computing anything.
+        // In such a case, the result of the matrix-matrix multiplication, if
+        // not empty, is necessarily zero, since R^0 = {0}.
+        if (!mat.isEmpty())
+            mat *= beta;
+        return;
+    }
+
     for (int i=0;i&lt;n;i++)
     {
         T* m1ki = m1.data()+i;
@@ -4007,18 +4195,32 @@
     }
 }
 
-// result[i,j] = sum_k m1[k,i] * m2[j,k]
+//! mat[i,j] = sum_k m1[k,i] * m2[j,k]
 template&lt;class T&gt;
-void transposeTransposeProduct(const TMat&lt;T&gt;&amp; mat, const TMat&lt;T&gt;&amp; m1, const TMat&lt;T&gt;&amp; m2)
+void transposeTransposeProduct(const TMat&lt;T&gt;&amp; mat, const TMat&lt;T&gt;&amp; m1,
+                               const TMat&lt;T&gt;&amp; m2)
 {
-#ifdef BOUNDCHECK
-    if (m1.length()!=m2.width())
-        PLERROR(&quot;transposeTransposeProduct(Mat,Mat), incompatible arguments %dx%d' times %dx%d'&quot;,
-                m1.length(),m1.width(), m2.length(),m2.width());
-#endif
     int n=m1.width();
     int m=m1.length();
     int l=m2.length();
+#ifdef BOUNDCHECK
+    if (n!=mat.length() || m!=m2.width() || l!=mat.width())
+        PLERROR(&quot;transposeTransposeProduct(TMat, TMat, TMat), incompatible&quot;
+                &quot; arguments:\n&quot;
+                &quot;%dx%d &lt;- %dx%d' times %dx%d'&quot;,
+                mat.length(), mat.width(), m, n, l, m2.width());
+#endif
+
+    if (m1.isEmpty() || m2.isEmpty() || mat.isEmpty())
+    {
+        // Size zero: no need to bother computing anything.
+        // In such a case, the result of the matrix-matrix multiplication, if
+        // not empty, is necessarily zero, since R^0 = {0}.
+        if (!mat.isEmpty())
+            mat.clear();
+        return;
+    }
+
     for (int i=0;i&lt;n;i++)
     {
         T* m1ki0 = m1.data()+i;
@@ -4035,16 +4237,30 @@
     }
 }
 
-// result[i,j] += sum_k m1[k,i] * m2[j,k]
+//! mat[i,j] += sum_k m1[k,i] * m2[j,k]
 template&lt;class T&gt;
-void transposeTransposeProductAcc(const TMat&lt;T&gt;&amp; mat, const TMat&lt;T&gt;&amp; m1, const TMat&lt;T&gt;&amp; m2)
+void transposeTransposeProductAcc(const TMat&lt;T&gt;&amp; mat, const TMat&lt;T&gt;&amp; m1,
+                                  const TMat&lt;T&gt;&amp; m2)
 {
-    if (m1.length()!=m2.width())
-        PLERROR(&quot;transposeTransposeProductAcc(Mat,Mat), incompatible arguments %dx%d' times %dx%d&quot;,
-                m1.length(),m1.width(), m2.length(),m2.width());
     int n=m1.width();
     int m=m1.length();
-    int l=m2.width();
+    int l=m2.length();
+#ifdef BOUNDCHECK
+    if (n!=mat.length() || m!=m2.width() || l!=mat.width())
+        PLERROR(&quot;transposeTransposeProductAcc(TMat, TMat, TMat), incompatible&quot;
+                &quot; arguments:\n&quot;
+                &quot;%dx%d &lt;-  %dx%d' times %dx%d'&quot;,
+                mat.length(), mat.width(), m, n, l, m2.width());
+#endif
+
+    if (m1.isEmpty() || m2.isEmpty() || mat.isEmpty())
+    {
+        // Size zero: no need to bother computing anything.
+        // In such a case, the result of the matrix-matrix multiplication, if
+        // not empty, is necessarily zero, since R^0 = {0}.
+        return;
+    }
+
     for (int i=0;i&lt;n;i++)
     {
         T* m1ki0 = m1.data()+i;
@@ -4061,17 +4277,32 @@
     }
 }
 
-// mat[i,j] = alpha * sum_k m1[k,i] * m2[j,k] + beta * mat[i,j]
+//! mat[i,j] = alpha * sum_k m1[k,i] * m2[j,k] + beta * mat[i,j]
 template&lt;class T&gt;
 void transposeTransposeProductScaleAcc(const TMat&lt;T&gt;&amp; mat, const TMat&lt;T&gt;&amp; m1,
                                        const TMat&lt;T&gt;&amp; m2, T alpha, T beta)
 {
-    if (m1.length()!=m2.width())
-        PLERROR(&quot;transposeTransposeProductScaleAcc(Mat,Mat,Mat), incompatible arguments %dx%d' times %dx%d&quot;,
-                m1.length(),m1.width(), m2.length(),m2.width());
     int n=m1.width();
     int m=m1.length();
-    int l=m2.width();
+    int l=m2.length();
+#ifdef BOUNDCHECK
+    if (n!=mat.length() || m!=m2.width() || l!=mat.width())
+        PLERROR(&quot;transposeTransposeProductScaleAcc(TMat, TMat, TMat),&quot;
+                &quot; incompatible arguments:\n&quot;
+                &quot;%dx%d &lt;- %dx%d' times %dx%d'&quot;,
+                mat.length(), mat.width(), m, n, l, m2.width());
+#endif
+
+    if (m1.isEmpty() || m2.isEmpty() || mat.isEmpty())
+    {
+        // Size zero: no need to bother computing anything.
+        // In such a case, the result of the matrix-matrix multiplication, if
+        // not empty, is necessarily zero, since R^0 = {0}.
+        if (!mat.isEmpty())
+            mat *= beta;
+        return;
+    }
+
     for (int i=0;i&lt;n;i++)
     {
         T* m1ki0 = m1.data()+i;
@@ -4282,7 +4513,7 @@
         T p = v((l+h)/2,0);
         int x = l;
         int y = h;
- 
+
         do
         {
             while (v(x,0)&lt;p) x++;
@@ -4298,7 +4529,7 @@
         if (pos&gt;=x) l=x;
         else h=x-1;
     }
- 
+
     return mat(l);
 }
 
@@ -4903,11 +5134,11 @@
     if(result.length()!=mat.width()-1 || mat.length()&lt;=1)
         PLERROR(&quot;IN void columnWeightedMean(const TMat&lt;T&gt;&amp; mat, TVec&lt;T&gt;&amp; result) the length of result must equal the width - 1 of mat and mat must have at least 1 length&quot;);
 #endif
-    TVec&lt;T&gt; column_j_vec(mat.length()), weights_vec(mat.length()); 
-    TMat&lt;T&gt; column_j_mat(mat.length(), 1), weights_mat(mat.length(), 1); 
+    TVec&lt;T&gt; column_j_vec(mat.length()), weights_vec(mat.length());
+    TMat&lt;T&gt; column_j_mat(mat.length(), 1), weights_mat(mat.length(), 1);
     for(int j=0; j&lt;mat.width()-1; j++){
-        column_j_mat = mat.column(j); 
-        weights_mat = mat.column(mat.width()-1); 
+        column_j_mat = mat.column(j);
+        weights_mat = mat.column(mat.width()-1);
         column_j_vec = column_j_mat.toVecCopy();
         weights_vec = weights_mat.toVecCopy();
         result[j] = weighted_mean(column_j_vec, weights_vec);
@@ -4933,11 +5164,11 @@
         PLERROR(&quot;IN void columnWeightedVariance(const TMat&lt;T&gt;&amp; mat, TVec&lt;T&gt;&amp; result, const TVec&lt;T&gt;&amp; column_weighted_mean) the length of result and column_weighted_mean must equal the width - 1 of mat and mat must have at least 1 length&quot;);
 #endif
     T column_no_weighted_mean_j;
-    TVec&lt;T&gt; column_j_vec(mat.length()), weights_vec(mat.length()); 
-    TMat&lt;T&gt; column_j_mat(mat.length(), 1), weights_mat(mat.length(), 1); 
+    TVec&lt;T&gt; column_j_vec(mat.length()), weights_vec(mat.length());
+    TMat&lt;T&gt; column_j_mat(mat.length(), 1), weights_mat(mat.length(), 1);
     for(int j=0; j&lt;mat.width()-1; j++){
-        column_j_mat = mat.column(j); 
-        weights_mat = mat.column(mat.width()-1); 
+        column_j_mat = mat.column(j);
+        weights_mat = mat.column(mat.width()-1);
         column_j_vec = column_j_mat.toVecCopy();
         weights_vec = weights_mat.toVecCopy();
         column_no_weighted_mean_j = mean(mat.column(j));
@@ -5017,7 +5248,7 @@
     columnVariance(m,variancevec,meanvec);
 }
 
-//! inverse_standard_deviation[i,j] = 
+//! inverse_standard_deviation[i,j] =
 //!    1/sqrt(mean_of_squares[i,j] - means[i,j]^2)
 //! If 'min_stddev' is provided, any standard deviation less than this value
 //! will be set to 'default_stddev' without any warning being issued (even when
@@ -5068,7 +5299,7 @@
 
 template&lt;class T&gt;
 void computeCovar(const TMat&lt;T&gt;&amp; m, const TVec&lt;T&gt;&amp; meanvec, TMat&lt;T&gt;&amp; covarmat)
-{  
+{
     int n = m.width();
     covarmat.resize(n,n);
     transposeProduct(covarmat,m,m);
@@ -5078,7 +5309,7 @@
 
 template&lt;class T&gt;
 void computeMeanAndCovar(const TMat&lt;T&gt;&amp; m, TVec&lt;T&gt;&amp; meanvec, TMat&lt;T&gt;&amp; covarmat)
-{  
+{
     int n = m.width();
     meanvec.resize(n);
     covarmat.resize(n,n);
@@ -5091,7 +5322,7 @@
     /*
       Mat mm = m.copy();
       mm -= meanvec;
-      transposeProduct(covarmat,mm,mm);  
+      transposeProduct(covarmat,mm,mm);
       covarmat /= T(m.length());
     */
 }
@@ -5120,7 +5351,7 @@
 
 //! substract mean, and divide by stddev (these are estimated globally)
 template&lt;class T&gt;
-void normalize(TMat&lt;T&gt;&amp; m) 
+void normalize(TMat&lt;T&gt;&amp; m)
 {
     TVec&lt;T&gt; meanvec(m.width());
     TVec&lt;T&gt; stddevvec(m.width());
@@ -5153,9 +5384,9 @@
     }
 }
 
-//! divide each row by its n norm 
+//! divide each row by its n norm
 template&lt;class T&gt;
-void normalize(TMat&lt;T&gt;&amp; m, double n) 
+void normalize(TMat&lt;T&gt;&amp; m, double n)
 {
     for(int i=0; i&lt;m.length(); i++)
     {
@@ -5355,7 +5586,7 @@
     int m2_mod = m2.mod();
     int d_mod = destination.mod();
     int w = m1.width();
-    for (int i=0;i&lt;m1.length();i++,m1_i+=m1_mod,m2_i+=m2_mod,d_i+=d_mod) 
+    for (int i=0;i&lt;m1.length();i++,m1_i+=m1_mod,m2_i+=m2_mod,d_i+=d_mod)
         for (int j=0;j&lt;w;j++)
             d_i[j] = m1_i[j] - m2_i[j];
 }
@@ -5377,7 +5608,7 @@
     int m2_mod = m2.mod();
     int d_mod = destination.mod();
     int w = m1.width();
-    for (int i=0;i&lt;m1.length();i++,m1_i+=m1_mod,m2_i+=m2_mod,d_i+=d_mod) 
+    for (int i=0;i&lt;m1.length();i++,m1_i+=m1_mod,m2_i+=m2_mod,d_i+=d_mod)
         for (int j=0;j&lt;w;j++)
             d_i[j] = m1_i[j] + m2_i[j];
 }
@@ -5414,7 +5645,7 @@
         for(int j=0; j&lt;m.width(); j++)
             m_i[j] = 1.0/m_i[j];
 }
-  
+
 // result * m = identity
 // (works only if m.length()&gt;=m.width())
 template&lt;class T&gt;
@@ -5546,8 +5777,8 @@
 /*  Perform a Cholesky decomposition of nxn symmetric positive definite
     matrix A, i.e., decompose it into
     A = L L'
-    where L is a lower diagonal matrix (with zeros above the diagonal). 
-    L be used to solve a linear system A x = b, i.e., LL'x=b, with choleskySolve(L,b,x). 
+    where L is a lower diagonal matrix (with zeros above the diagonal).
+    L be used to solve a linear system A x = b, i.e., LL'x=b, with choleskySolve(L,b,x).
     See choleskySolve(TMat&lt;T&gt;*,TVec&lt;T&gt;*) for an example of use.
 
     From the above equation, one obtains
@@ -5568,7 +5799,7 @@
     int i,j,k;
     T sum;
     bool restart=false;
-    do 
+    do
     {
         restart=false;
         for (i=0;i&lt;n;i++)
@@ -5603,7 +5834,7 @@
         }
     }
     while (restart);
-  
+
 }
 
 /*  Back-propagate through the call to choleskyDecomposition(A,L).
@@ -5628,7 +5859,7 @@
 
 */
 template&lt;class T&gt;
-void  bpropCholeskyDecomposition(const TMat&lt;T&gt;&amp; A, const TMat&lt;T&gt;&amp; L, 
+void  bpropCholeskyDecomposition(const TMat&lt;T&gt;&amp; A, const TMat&lt;T&gt;&amp; L,
                                  TMat&lt;T&gt;&amp; dC_dA, TMat&lt;T&gt;&amp; dC_dL)
 {
     int n = A.length();
@@ -5732,7 +5963,7 @@
 /*  Solve the linear system A x = L L' x = b using a Cholesky decomposition
     of A into L L' performed with a prior call to choleskyDecomposition(A,L)
     (which on return has the matrix L, that is lower diagonal, and A = L L').
-    The solution of the linear system L L' x = b will be in x. 
+    The solution of the linear system L L' x = b will be in x.
     See choleskySolve(TMat&lt;T&gt;*,TVec&lt;T&gt;*) for an example of use.
     The algorithm is first to solve L y = b, and then L' x = y.
     The argument y is optional and can be used to hold the intermediate
@@ -5746,14 +5977,14 @@
 
     * Solve L' x = y by iterating once (backwards) through the rows of L.
     x[i] = (y[i] - sum_{k&gt;i} L[k][i] x[k])/L[i][i]
-   
+
 */
 template&lt;class T&gt;
 void  choleskySolve(const TMat&lt;T&gt;&amp; L, TVec&lt;T&gt; b, TVec&lt;T&gt; x, TVec&lt;T&gt;&amp; y)
 {
     // solve L y = b
     choleskyLeftSolve(L,b,y);
-    // solve L' x = y 
+    // solve L' x = y
     choleskyRightSolve(L,y,x);
 }
 
@@ -5794,12 +6025,12 @@
             for (sum = *bp,k=i-1;k&gt;=0;k--) sum -= Li[k] * yp[k];
             yp[i] = sum / Li[i];
         }
-        // solve L' x = y 
+        // solve L' x = y
         // for i=n-1..0
         //   x[i] = (y[i] - sum_{k&gt;i} L[k][i] x[k])/L[i][i]
         for (i=n-1;i&gt;=0;i--)
         {
-            sum=yp[i]; 
+            sum=yp[i];
             if (i+1&lt;n)
             {
                 T* xp = &amp;X(i+1,j);
@@ -5810,7 +6041,7 @@
     }
 }
 
-/* 
+/*
    Back-propagate through the CholeskySolve(L,b,x,y) operation
    (the optional argument y of this call must have been provided).
 
@@ -5934,7 +6165,7 @@
             Linv_xj[i] = sum * Li[i]; // * not / because inverse already done above
         }
     }
-    // recall: now Linv above and on diagonal of L, L below it, 
+    // recall: now Linv above and on diagonal of L, L below it,
 
     // compute A's inverse
     for (j=0;j&lt;n;j++)
@@ -5944,7 +6175,7 @@
         {
             T sum = Linv_xj[i]; // this is Linv[i][j]
             int k;
-            for (k=i+1;k&lt;n;k++) 
+            for (k=i+1;k&lt;n;k++)
                 sum -= L[k][i] * Ainv[k][j];
             Ainv[i][j] = sum * L[i][i];
         }
@@ -5968,7 +6199,7 @@
     return x;
 }
 
-/*  return inverse of positive definite matrix A 
+/*  return inverse of positive definite matrix A
     using Cholesky decomposition. No side-effect on A.  */
 template&lt;class T&gt;
 TMat&lt;T&gt; choleskyInvert(const TMat&lt;T&gt;&amp; A)
@@ -6044,7 +6275,7 @@
     }
     if (p == 0) delete pivot;
 }
-   
+
 //! Return the determinant of A, using LU decomposition.
 //! If 'log_det' is set to true, the log determinant is returned.
 template&lt;class T&gt;
@@ -6196,7 +6427,7 @@
 }
 
 template&lt;class T&gt;
-void apply(T (*func)(const TVec&lt;T&gt;&amp;,const TVec&lt;T&gt;&amp;), const TMat&lt;T&gt;&amp; m1, const TMat&lt;T&gt;&amp; m2, 
+void apply(T (*func)(const TVec&lt;T&gt;&amp;,const TVec&lt;T&gt;&amp;), const TMat&lt;T&gt;&amp; m1, const TMat&lt;T&gt;&amp; m2,
            TMat&lt;T&gt;&amp; dest)
 {
     if (dest.length()!=m1.length() || m1.length()!=m2.length())
@@ -6211,7 +6442,7 @@
 //
 //   norm(weights*inputs - outputs) + weight_decay*norm(weights)
 //
-// is minimized, 
+// is minimized,
 //
 // This is achieved by solving the following linear system:
 //
@@ -6275,10 +6506,10 @@
     static TMat&lt;T&gt; XtY;
     XtY.resize(n,n_outputs);
     XtY.clear();
-    // compute X' X and X'Y: 
+    // compute X' X and X'Y:
     // XtX(i,j) = sum_t X[t,i]*X[t,j] (with X[t,0]=1, X[t,i+1]=inputs[t,i])
     // YtY(i,j) = sum_t X[t,i]*Y[t,j]
-    // 
+    //
     int xmod=inputs.mod();
     int ymod=outputs.mod();
     T *xt = inputs.data();
@@ -6354,7 +6585,7 @@
     // m
     theta_t[1] = (sum_xy - (sum_x * sum_y) / npts) / (sum_x2 + weight_decay - sum2_x / npts);
     // b
-    theta_t[0] = (sum_y - theta_t[1] * sum_x) / npts; 
+    theta_t[0] = (sum_y - theta_t[1] * sum_x) / npts;
 }
 
 
@@ -6432,7 +6663,7 @@
 {
     TMat&lt;T&gt; result(data.length(),data.width());
     int length=0;
-    
+
     for(int i=0; i&lt;data.length(); i++)
     {
         bool contains = values.contains(data(i,col));
@@ -6513,7 +6744,7 @@
 //!  - its rows are of norm 1
 //! However, it may happen that the original rows of A were not linearly
 //! independent. In that case the, algorithm returns the number of rows
-//! that were successfully obtained (and the user should probably 
+//! that were successfully obtained (and the user should probably
 //! then do A = A.subMatRows(0,result) to obtain the basis).
 //! The tolerance argument is the minimum value of the norm
 //! of a row when projected orthogonal to the previous ones for this row
@@ -6651,7 +6882,7 @@
 // input_gradient[j] = sum_i weights[i,j]*output_gradient[i]
 // weights[i,j] -= learning_rate * output_gradient[i] * input[j]
 template&lt;class T&gt;
-void layerBpropUpdate(TVec&lt;T&gt; input_gradient, TMat&lt;T&gt; weights, const TVec&lt;T&gt;&amp; input, 
+void layerBpropUpdate(TVec&lt;T&gt; input_gradient, TMat&lt;T&gt; weights, const TVec&lt;T&gt;&amp; input,
                       const TVec&lt;T&gt;&amp; output_gradient, real learning_rate)
 {
     int n_inputs = input_gradient.length();
@@ -6660,7 +6891,7 @@
     if (weights.length() != n_outputs || weights.width() != n_inputs
         || input.length() != n_inputs)
         PLERROR(&quot;layerBpropUpdate: arguments have incompatible sizes&quot;);
-#endif 
+#endif
     input_gradient.clear();
     T* in_g = input_gradient.data();
     T* out_g = output_gradient.data();
@@ -6681,7 +6912,7 @@
 // input_gradient[j] = sum_i weights[i,j]*output_gradient[i]
 // weights[i,j] -= learning_rate * (output_gradient[i] * input[j] + weight_decay * weights[i,j])
 template&lt;class T&gt;
-void layerL2BpropUpdate(TVec&lt;T&gt; input_gradient, TMat&lt;T&gt; weights, const TVec&lt;T&gt;&amp; input, 
+void layerL2BpropUpdate(TVec&lt;T&gt; input_gradient, TMat&lt;T&gt; weights, const TVec&lt;T&gt;&amp; input,
                         const TVec&lt;T&gt;&amp; output_gradient, real learning_rate, T weight_decay)
 {
     int n_inputs = input_gradient.length();
@@ -6690,7 +6921,7 @@
     if (weights.length() != n_outputs || weights.width() != n_inputs
         || input.length() != n_inputs)
         PLERROR(&quot;layerL2BpropUpdate: arguments have incompatible sizes&quot;);
-#endif 
+#endif
     input_gradient.clear();
     T* in_g = input_gradient.data();
     T* out_g = output_gradient.data();
@@ -6712,7 +6943,7 @@
 // input_gradient[j] = sum_i weights[j,i]*output_gradient[i]
 // weights[i,j] -= learning_rate * (output_gradient[i] * input[j] + weight_decay * weights[i,j])
 template&lt;class T&gt;
-void transposedLayerL2BpropUpdate(TVec&lt;T&gt; input_gradient, TMat&lt;T&gt; weights, const TVec&lt;T&gt;&amp; input, 
+void transposedLayerL2BpropUpdate(TVec&lt;T&gt; input_gradient, TMat&lt;T&gt; weights, const TVec&lt;T&gt;&amp; input,
                                   const TVec&lt;T&gt;&amp; output_gradient, real learning_rate, T weight_decay)
 {
     int n_inputs = input_gradient.length();
@@ -6721,7 +6952,7 @@
     if (weights.width() != n_outputs || weights.length() != n_inputs
         || input.length() != n_inputs)
         PLERROR(&quot;layerL2BpropUpdate: arguments have incompatible sizes&quot;);
-#endif 
+#endif
     input_gradient.clear();
     T* in_g = input_gradient.data();
     T* out_g = output_gradient.data();
@@ -6743,7 +6974,7 @@
 // input_gradient[j] = sum_i weights[i,j]*output_gradient[i]
 // weights[i,j] -= learning_rate * (output_gradient[i] * input[j] + weight_decay * sign(weights[i,j]))
 template&lt;class T&gt;
-void layerL1BpropUpdate(TVec&lt;T&gt; input_gradient, TMat&lt;T&gt; weights, const TVec&lt;T&gt;&amp; input, 
+void layerL1BpropUpdate(TVec&lt;T&gt; input_gradient, TMat&lt;T&gt; weights, const TVec&lt;T&gt;&amp; input,
                         const TVec&lt;T&gt;&amp; output_gradient, real learning_rate, T weight_decay)
 {
     int n_inputs = input_gradient.length();
@@ -6752,7 +6983,7 @@
     if (weights.length() != n_outputs || weights.width() != n_inputs
         || input.length() != n_inputs)
         PLERROR(&quot;layerL1BpropUpdate: arguments have incompatible sizes&quot;);
-#endif 
+#endif
     input_gradient.clear();
     T* in_g = input_gradient.data();
     T* out_g = output_gradient.data();
@@ -6774,7 +7005,7 @@
 // input_gradient[j] = sum_i weights[j,i]*output_gradient[i]
 // weights[i,j] -= learning_rate * (output_gradient[i] * input[j] + weight_decay * sign(weights[i,j]))
 template&lt;class T&gt;
-void transposedLayerL1BpropUpdate(TVec&lt;T&gt; input_gradient, TMat&lt;T&gt; weights, const TVec&lt;T&gt;&amp; input, 
+void transposedLayerL1BpropUpdate(TVec&lt;T&gt; input_gradient, TMat&lt;T&gt; weights, const TVec&lt;T&gt;&amp; input,
                                   const TVec&lt;T&gt;&amp; output_gradient, real learning_rate, T weight_decay)
 {
     int n_inputs = input_gradient.length();
@@ -6783,7 +7014,7 @@
     if (weights.width() != n_outputs || weights.length() != n_inputs
         || input.length() != n_inputs)
         PLERROR(&quot;layerL1BpropUpdate: arguments have incompatible sizes&quot;);
-#endif 
+#endif
     input_gradient.clear();
     T* in_g = input_gradient.data();
     T* out_g = output_gradient.data();
@@ -6832,8 +7063,8 @@
 
 
 } // end of namespace PLearn
- 
 
+
 // Norman: replaced the code below with this wrapper
 SET_HASH_FUNCTION(PLearn::TVec&lt;T&gt;, T, v, sumsquare(v))
     SET_HASH_WITH_FUNCTION(PLearn::Vec, v, sumsquare(v))
@@ -6847,7 +7078,7 @@
 //template&lt;class T&gt;
 //struct hash&lt;PLearn::TVec&lt;T&gt; &gt;
 //{
-//	size_t operator()(PLearn::TVec&lt;T&gt; v) const { return hash&lt;T&gt;()(sumsquare(v));} 
+//    size_t operator()(PLearn::TVec&lt;T&gt; v) const { return hash&lt;T&gt;()(sumsquare(v));}
 //};
 
 //} // end of namespace std
@@ -6855,7 +7086,7 @@
 
 #endif // TMat_maths_impl_H
 
-    
+
 /*
   Local Variables:
   mode:c++


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000433.html">[Plearn-commits] r6984 - in	trunk/plearn_learners/online/test/DeepBeliefNet/.pytest/PL_DBN_SimpleRBM/expected_results/expdir:	. Split0 Split0/LearnerExpdir
</A></li>
	<LI>Next message: <A HREF="000435.html">[Plearn-commits] r6986 - trunk/plearn_learners/online
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#434">[ date ]</a>
              <a href="thread.html#434">[ thread ]</a>
              <a href="subject.html#434">[ subject ]</a>
              <a href="author.html#434">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/plearn-commits">More information about the Plearn-commits
mailing list</a><br>
</body></html>
