<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Plearn-commits] r7450 - in trunk: commands/PLearnCommands	plearn/base plearn/python plearn/vmat plearn_learners/generic	python_modules/plearn/pybridge python_modules/plearn/pyext
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/plearn-commits/2007-May/index.html" >
   <LINK REL="made" HREF="mailto:plearn-commits%40lists.berlios.de?Subject=Re%3A%20%5BPlearn-commits%5D%20r7450%20-%20in%20trunk%3A%20commands/PLearnCommands%0A%09plearn/base%20plearn/python%20plearn/vmat%20plearn_learners/generic%0A%09python_modules/plearn/pybridge%20python_modules/plearn/pyext&In-Reply-To=%3C200705302123.l4ULNjqW006855%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000898.html">
   <LINK REL="Next"  HREF="000900.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Plearn-commits] r7450 - in trunk: commands/PLearnCommands	plearn/base plearn/python plearn/vmat plearn_learners/generic	python_modules/plearn/pybridge python_modules/plearn/pyext</H1>
    <B>saintmlx at BerliOS</B> 
    <A HREF="mailto:plearn-commits%40lists.berlios.de?Subject=Re%3A%20%5BPlearn-commits%5D%20r7450%20-%20in%20trunk%3A%20commands/PLearnCommands%0A%09plearn/base%20plearn/python%20plearn/vmat%20plearn_learners/generic%0A%09python_modules/plearn/pybridge%20python_modules/plearn/pyext&In-Reply-To=%3C200705302123.l4ULNjqW006855%40sheep.berlios.de%3E"
       TITLE="[Plearn-commits] r7450 - in trunk: commands/PLearnCommands	plearn/base plearn/python plearn/vmat plearn_learners/generic	python_modules/plearn/pybridge python_modules/plearn/pyext">saintmlx at mail.berlios.de
       </A><BR>
    <I>Wed May 30 23:23:45 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000898.html">[Plearn-commits] r7449 - trunk/plearn/io
</A></li>
        <LI>Next message: <A HREF="000900.html">[Plearn-commits] r7451 - trunk/python_modules/plearn/learners/autolr
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#899">[ date ]</a>
              <a href="thread.html#899">[ thread ]</a>
              <a href="subject.html#899">[ subject ]</a>
              <a href="author.html#899">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: saintmlx
Date: 2007-05-30 23:23:42 +0200 (Wed, 30 May 2007)
New Revision: 7450

Modified:
   trunk/commands/PLearnCommands/Plide.cc
   trunk/plearn/base/Object.cc
   trunk/plearn/base/Object.h
   trunk/plearn/base/TypeTraits.h
   trunk/plearn/python/PythonCodeSnippet.h
   trunk/plearn/python/PythonObjectWrapper.cc
   trunk/plearn/python/PythonObjectWrapper.h
   trunk/plearn/python/PythonProcessedVMatrix.cc
   trunk/plearn/vmat/VMatrix.cc
   trunk/plearn_learners/generic/PLearner.cc
   trunk/python_modules/plearn/pybridge/embedded_code_snippet.py
   trunk/python_modules/plearn/pybridge/wrapped_plearn_object.py
   trunk/python_modules/plearn/pyext/__init__.py
Log:
- several mods. to inner workings of PLearn/Python bridge
- support for TMat&lt;T&gt; from python
- newObjectFromClassname: construct empty Object w/o building it
- type traits for const 
- 'remote declare' some methods and functions



Modified: trunk/commands/PLearnCommands/Plide.cc
===================================================================
--- trunk/commands/PLearnCommands/Plide.cc	2007-05-30 20:58:22 UTC (rev 7449)
+++ trunk/commands/PLearnCommands/Plide.cc	2007-05-30 21:23:42 UTC (rev 7450)
@@ -331,7 +331,7 @@
 {
     if (args.size() != 0)
         PLERROR(&quot;%sExpecting 0 argument; got %d&quot;, __FUNCTION__, args.size());
-    return version_string();
+    return PythonObjectWrapper(version_string());
 }
 
 PythonObjectWrapper Plide::getAllClassnames(const TVec&lt;PythonObjectWrapper&gt;&amp; args) const
@@ -349,7 +349,7 @@
         if (it-&gt;second.constructor)
             all_classes.push_back(it-&gt;second.type_name);
     }
-    return all_classes;
+    return PythonObjectWrapper(all_classes);
 }
 
 PythonObjectWrapper Plide::helpResourcesPath(const TVec&lt;PythonObjectWrapper&gt;&amp; args)
@@ -382,7 +382,7 @@
     PLASSERT( m_help_config &amp;&amp; m_help_command );
     ostringstream os;
     m_help_command-&gt;helpIndex(os, m_help_config);
-    return os.str();
+    return PythonObjectWrapper(os.str());
 }
 
 PythonObjectWrapper Plide::helpCommands(const TVec&lt;PythonObjectWrapper&gt;&amp; args) const
@@ -393,7 +393,7 @@
     PLASSERT( m_help_config &amp;&amp; m_help_command );
     ostringstream os;
     m_help_command-&gt;helpCommands(os, m_help_config);
-    return os.str();
+    return PythonObjectWrapper(os.str());
 }
 
 PythonObjectWrapper Plide::helpClasses(const TVec&lt;PythonObjectWrapper&gt;&amp; args) const
@@ -404,7 +404,7 @@
     PLASSERT( m_help_config &amp;&amp; m_help_command );
     ostringstream os;
     m_help_command-&gt;helpClasses(os, m_help_config);
-    return os.str();
+    return PythonObjectWrapper(os.str());
 }
 
 PythonObjectWrapper Plide::helpOnCommand(const TVec&lt;PythonObjectWrapper&gt;&amp; args) const
@@ -415,7 +415,7 @@
     PLASSERT( m_help_config &amp;&amp; m_help_command );
     ostringstream os;
     m_help_command-&gt;helpOnCommand(args[0].as&lt;string&gt;(), os, m_help_config);
-    return os.str();
+    return PythonObjectWrapper(os.str());
 }
 
 PythonObjectWrapper Plide::helpOnClass(const TVec&lt;PythonObjectWrapper&gt;&amp; args) const
@@ -426,7 +426,7 @@
     PLASSERT( m_help_config &amp;&amp; m_help_command );
     ostringstream os;
     m_help_command-&gt;helpOnClass(args[0].as&lt;string&gt;(), os, m_help_config);
-    return os.str();
+    return PythonObjectWrapper(os.str());
 }
 
 PythonObjectWrapper Plide::setOptionLevel(const TVec&lt;PythonObjectWrapper&gt;&amp; args) const
@@ -468,7 +468,7 @@
             if (flags &amp; OptionBase::buildoption)
                 build_options.push_back((*it)-&gt;optionname());
         }
-        return make_pair(tme.one_line_descr, build_options);
+        return PythonObjectWrapper(make_pair(tme.one_line_descr, build_options));
     }
     else
         return PythonObjectWrapper();        // None

Modified: trunk/plearn/base/Object.cc
===================================================================
--- trunk/plearn/base/Object.cc	2007-05-30 20:58:22 UTC (rev 7449)
+++ trunk/plearn/base/Object.cc	2007-05-30 21:23:42 UTC (rev 7450)
@@ -987,6 +987,12 @@
 */
 
 
+
+Object* newObjectFromClassname(const string&amp; classname)
+{
+    return TypeFactory::instance().newObject(classname);
+}
+
 BEGIN_DECLARE_REMOTE_FUNCTIONS
 
     declareFunction(&quot;newObject&quot;, &amp;newObject,
@@ -995,6 +1001,12 @@
                             &quot;the string representation of the object&quot;),
                      RetDoc (&quot;newly created object&quot;)));
 
+    declareFunction(&quot;newObjectFromClassname&quot;, &amp;newObjectFromClassname,
+                    (BodyDoc(&quot;Returns PLearn object from a class name (string.)\n&quot;),
+                     ArgDoc(&quot;classname&quot;, 
+                            &quot;the class of the object, as a string&quot;),
+                     RetDoc (&quot;newly created object&quot;)));
+
     declareFunction(&quot;loadObject&quot;, &amp;loadObject,
                     (BodyDoc(&quot;Returns PLearn object from a file describing it.\n&quot;),
                      ArgDoc(&quot;filename&quot;, 

Modified: trunk/plearn/base/Object.h
===================================================================
--- trunk/plearn/base/Object.h	2007-05-30 20:58:22 UTC (rev 7449)
+++ trunk/plearn/base/Object.h	2007-05-30 21:23:42 UTC (rev 7450)
@@ -1093,6 +1093,9 @@
     return readObject(in);
 }
 
+Object* newObjectFromClassname(const string&amp; classname);
+
+
 inline PStream &amp;operator&gt;&gt;(PStream &amp;in, Object &amp;o)
 {
     o.newread(in);

Modified: trunk/plearn/base/TypeTraits.h
===================================================================
--- trunk/plearn/base/TypeTraits.h	2007-05-30 20:58:22 UTC (rev 7449)
+++ trunk/plearn/base/TypeTraits.h	2007-05-30 21:23:42 UTC (rev 7450)
@@ -107,6 +107,20 @@
     { return 0xFF; }
 };
 
+template&lt;class T&gt;
+class TypeTraits&lt;T const&gt;
+{
+public:
+    static inline string name() 
+    { return TypeTraits&lt;T&gt;::name()+&quot; const&quot;; }
+
+    static inline unsigned char little_endian_typecode()
+    { return 0xFF; }
+
+    static inline unsigned char big_endian_typecode()
+    { return 0xFF; }
+};
+
 #define DECLARE_TYPE_TRAITS_FOR_BASETYPE(T,LITTLE_ENDIAN_TYPECODE,BIG_ENDIAN_TYPECODE)  \
 template&lt;&gt;                                                                              \
 class TypeTraits&lt;T&gt;                                                                     \

Modified: trunk/plearn/python/PythonCodeSnippet.h
===================================================================
--- trunk/plearn/python/PythonCodeSnippet.h	2007-05-30 20:58:22 UTC (rev 7449)
+++ trunk/plearn/python/PythonCodeSnippet.h	2007-05-30 21:23:42 UTC (rev 7450)
@@ -172,8 +172,15 @@
     //! Set an object into the global environment.
     void setGlobalObject(const string&amp; object_name,
                          const PythonObjectWrapper&amp; pow);
+    template&lt;typename T&gt;
+    void setGlobalObject(const string&amp; object_name,
+                         const T&amp; o)
+    {
+        setGlobalObject(object_name, PythonObjectWrapper(o));
+    }
+
+
     
-    
     //#####  Function Call Interface  #########################################
 
     //! Checks whether the specified function name is callable
@@ -364,7 +371,7 @@
                           const T&amp; arg1) const
 {
     TVec&lt;PythonObjectWrapper&gt; args(1);
-    args[0]= arg1;
+    args[0]= PythonObjectWrapper(arg1);
     return invoke(function_name, args);
 /*
 
@@ -414,8 +421,8 @@
                           const U&amp; arg2) const
 {
     TVec&lt;PythonObjectWrapper&gt; args(2);
-    args[0]= arg1;
-    args[1]= arg2;
+    args[0]= PythonObjectWrapper(arg1);
+    args[1]= PythonObjectWrapper(arg2);
     return invoke(function_name, args);
 /*
     PythonGlobalInterpreterLock gil;         // For thread-safety
@@ -467,9 +474,9 @@
                           const V&amp; arg3) const
 {
     TVec&lt;PythonObjectWrapper&gt; args(3);
-    args[0]= arg1;
-    args[1]= arg2;
-    args[2]= arg3;
+    args[0]= PythonObjectWrapper(arg1);
+    args[1]= PythonObjectWrapper(arg2);
+    args[2]= PythonObjectWrapper(arg3);
     return invoke(function_name, args);
 
 /*
@@ -526,10 +533,10 @@
                           const W&amp; arg4) const
 {
     TVec&lt;PythonObjectWrapper&gt; args(4);
-    args[0]= arg1;
-    args[1]= arg2;
-    args[2]= arg3;
-    args[3]= arg4;
+    args[0]= PythonObjectWrapper(arg1);
+    args[1]= PythonObjectWrapper(arg2);
+    args[2]= PythonObjectWrapper(arg3);
+    args[3]= PythonObjectWrapper(arg4);
     return invoke(function_name, args);
 /*
     PythonGlobalInterpreterLock gil;         // For thread-safety
@@ -588,11 +595,11 @@
                           const X&amp; arg5) const
 {
     TVec&lt;PythonObjectWrapper&gt; args(5);
-    args[0]= arg1;
-    args[1]= arg2;
-    args[2]= arg3;
-    args[3]= arg4;
-    args[4]= arg5;
+    args[0]= PythonObjectWrapper(arg1);
+    args[1]= PythonObjectWrapper(arg2);
+    args[2]= PythonObjectWrapper(arg3);
+    args[3]= PythonObjectWrapper(arg4);
+    args[4]= PythonObjectWrapper(arg5);
     return invoke(function_name, args);
 /*
     PythonGlobalInterpreterLock gil;         // For thread-safety
@@ -655,12 +662,12 @@
                           const Y&amp; arg6) const
 {
     TVec&lt;PythonObjectWrapper&gt; args(6);
-    args[0]= arg1;
-    args[1]= arg2;
-    args[2]= arg3;
-    args[3]= arg4;
-    args[4]= arg5;
-    args[5]= arg6;
+    args[0]= PythonObjectWrapper(arg1);
+    args[1]= PythonObjectWrapper(arg2);
+    args[2]= PythonObjectWrapper(arg3);
+    args[3]= PythonObjectWrapper(arg4);
+    args[4]= PythonObjectWrapper(arg5);
+    args[5]= PythonObjectWrapper(arg6);
     return invoke(function_name, args);
 /*
     PythonGlobalInterpreterLock gil;         // For thread-safety
@@ -729,13 +736,13 @@
                           const Z&amp; arg7) const
 {
     TVec&lt;PythonObjectWrapper&gt; args(7);
-    args[0]= arg1;
-    args[1]= arg2;
-    args[2]= arg3;
-    args[3]= arg4;
-    args[4]= arg5;
-    args[5]= arg6;
-    args[6]= arg7;
+    args[0]= PythonObjectWrapper(arg1);
+    args[1]= PythonObjectWrapper(arg2);
+    args[2]= PythonObjectWrapper(arg3);
+    args[3]= PythonObjectWrapper(arg4);
+    args[4]= PythonObjectWrapper(arg5);
+    args[5]= PythonObjectWrapper(arg6);
+    args[6]= PythonObjectWrapper(arg7);
     return invoke(function_name, args);
 /*
     PythonGlobalInterpreterLock gil;         // For thread-safety

Modified: trunk/plearn/python/PythonObjectWrapper.cc
===================================================================
--- trunk/plearn/python/PythonObjectWrapper.cc	2007-05-30 20:58:22 UTC (rev 7449)
+++ trunk/plearn/python/PythonObjectWrapper.cc	2007-05-30 21:23:42 UTC (rev 7450)
@@ -429,20 +429,22 @@
 bool PythonObjectWrapper::m_unref_injected= false;
 PyMethodDef PythonObjectWrapper::m_unref_method_def;
 
-PyObject* PythonObjectWrapper::newPyObject(const Object* x)
+
+PyObject* ConvertToPyObject&lt;Object*&gt;::newPyObject(const Object* x)
 {
     // void ptr becomes None
     if(!x) 
-        return newPyObject();
+        return PythonObjectWrapper::newPyObject();
 
     PythonGlobalInterpreterLock gil;         // For thread-safety
 
     static PythonEmbedder embedder;
-    initializePython();
+    PythonObjectWrapper::initializePython();
 
     //see if this obj. is already wrapped
-    wrapped_objects_t::iterator objit= m_wrapped_objects.find(x);
-    if(objit != m_wrapped_objects.end())
+    PythonObjectWrapper::wrapped_objects_t::iterator objit= 
+        PythonObjectWrapper::m_wrapped_objects.find(x);
+    if(objit != PythonObjectWrapper::m_wrapped_objects.end())
     {
         PyObject* o= objit-&gt;second;
         Py_INCREF(o);//new ref
@@ -464,22 +466,27 @@
                 &quot;WrappedPLearnObject python code.&quot;);
     }
 
+    string wrapper_name= &quot;WrappedPLearnObject&quot;;
     // now find the class in the env.
     typedef map&lt;string, PyObject*&gt; env_t;
-    env_t env= PythonObjectWrapper(pyenv, transfer_ownership).as&lt;env_t&gt;();
-    env_t::iterator clit= env.find(&quot;WrappedPLearnObject&quot;);
+    env_t env= PythonObjectWrapper(
+        pyenv, PythonObjectWrapper::transfer_ownership).as&lt;env_t&gt;();
+    env_t::iterator clit= env.find(wrapper_name);
     if(clit == env.end())
         PLERROR(&quot;in PythonObjectWrapper::newPyObject : &quot;
-                &quot;class WrappedPLearnObject not defined &quot;
-                &quot;in plearn.pybridge.wrapped_plearn_object&quot;);
+                &quot;class %s not defined &quot;
+                &quot;in plearn.pybridge.wrapped_plearn_object&quot;,
+                wrapper_name.c_str());
     PyObject* wrapper= clit-&gt;second;
 
     //inject unref method if not already done
-    if(!m_unref_injected)
+    // N.B. always injected into WrappedPLearnObject
+    // even when using WrappedPLearnVMat
+    if(!PythonObjectWrapper::m_unref_injected)
     {
-        PyMethodDef* py_method= &amp;m_unref_method_def;
+        PyMethodDef* py_method= &amp;PythonObjectWrapper::m_unref_method_def;
         py_method-&gt;ml_name  = &quot;unref&quot;;
-        py_method-&gt;ml_meth  = python_del;
+        py_method-&gt;ml_meth  = PythonObjectWrapper::python_del;
         py_method-&gt;ml_flags = METH_VARARGS;
         py_method-&gt;ml_doc   = &quot;Injected unref function from PythonObjectWrapper; &quot;
             &quot;DO NOT USE THIS FUNCTION! IT MAY DEALLOCATE THE PLEARN OBJECT!&quot;;
@@ -497,36 +504,54 @@
         }
         PyObject_SetAttrString(wrapper, py_method-&gt;ml_name, py_methobj);
         Py_DECREF(py_methobj);
-        m_unref_injected= true;
+        PythonObjectWrapper::m_unref_injected= true;
     }
 
+    //get wrapped for VMats if needed
+    if(dynamic_cast&lt;const VMatrix*&gt;(x))
+    {
+        wrapper_name= &quot;WrappedPLearnVMat&quot;;
+        clit= env.find(wrapper_name);
+        if(clit == env.end())
+            PLERROR(&quot;in PythonObjectWrapper::newPyObject : &quot;
+                    &quot;class %s not defined &quot;
+                    &quot;in plearn.pybridge.wrapped_plearn_object&quot;,
+                    wrapper_name.c_str());
+        wrapper= clit-&gt;second; // the actual wrapper class
+    }
+
     if(!PyCallable_Check(wrapper))
         PLERROR(&quot;in PythonObjectWrapper::newPyObject : &quot;
-                &quot;WrappedPLearnObject is not callable [not a class?]&quot;);
+                &quot;%s is not callable [not a class?]&quot;,
+                wrapper_name.c_str());
 
     // get ptr of object to wrap
     PyObject* plobj= PyCObject_FromVoidPtr(const_cast&lt;Object*&gt;(x), NULL);
 
     // try to find existing python class
     string classname= x-&gt;classname();
-    pypl_classes_t::iterator clit2= m_pypl_classes.find(classname);
+    PythonObjectWrapper::pypl_classes_t::iterator clit2= 
+        PythonObjectWrapper::m_pypl_classes.find(classname);
     PyObject* the_pyclass= 0;
-    if(clit2 == m_pypl_classes.end())
+    if(clit2 == PythonObjectWrapper::m_pypl_classes.end())
     {
         // create new python type deriving from WrappedPLearnObject
         string derivcode= string(&quot;\nclass &quot;)
-            + classname + &quot;(WrappedPLearnObject):\n&quot;
+            + classname + &quot;(&quot; + wrapper_name + &quot;):\n&quot;
             &quot;\tpass\n\n&quot;;
 
         PyObject* res= PyRun_String(derivcode.c_str(), 
                                     Py_file_input, pyenv, pyenv);
         Py_XDECREF(res);
-        env= PythonObjectWrapper(pyenv, transfer_ownership).as&lt;env_t&gt;();
+        env= PythonObjectWrapper(
+            pyenv, PythonObjectWrapper::transfer_ownership).as&lt;env_t&gt;();
         clit= env.find(classname);
         if(clit == env.end())
             PLERROR(&quot;in PythonObjectWrapper::newPyObject : &quot;
                     &quot;Cannot create new python class deriving from &quot;
-                    &quot;WrappedPLearnObject (%s).&quot;, classname.c_str());
+                    &quot;%s (%s).&quot;, 
+                    wrapper_name.c_str(),
+                    classname.c_str());
 
         //set option names
         OptionList&amp; options= x-&gt;getOptionList();
@@ -551,9 +576,10 @@
         PP&lt;PObjectPool&lt;PyMethodDef&gt; &gt; meth_def_pool= 
             new PObjectPool&lt;PyMethodDef&gt;(methods-&gt;size()+1);
 
-        m_pypl_classes.insert(
+        PythonObjectWrapper::m_pypl_classes.insert(
             make_pair(classname, PLPyClass(the_pyclass, meth_def_pool)));
-        TVec&lt;string&gt;&amp; methods_help= m_pypl_classes.find(classname)-&gt;second.methods_help;
+        TVec&lt;string&gt;&amp; methods_help= 
+            PythonObjectWrapper::m_pypl_classes.find(classname)-&gt;second.methods_help;
 
         while(methods)
         {
@@ -566,7 +592,7 @@
                 // Create a Python Function Object
                 PyMethodDef* py_method= meth_def_pool-&gt;allocate();
                 py_method-&gt;ml_name  = const_cast&lt;char*&gt;(it-&gt;first.first.c_str());
-                py_method-&gt;ml_meth  = trampoline;
+                py_method-&gt;ml_meth  = PythonObjectWrapper::trampoline;
                 py_method-&gt;ml_flags = METH_VARARGS;
                 methods_help.push_back(HelpSystem::helpOnMethod(classname,
                                                                 it-&gt;first.first.c_str(),
@@ -626,12 +652,12 @@
     // augment refcount since python now 'points' to this obj.
     x-&gt;ref();
 
-    m_wrapped_objects[x]= the_obj;
+    PythonObjectWrapper::m_wrapped_objects[x]= the_obj;
 
     return the_obj;
 }
 
-PyObject* PythonObjectWrapper::newPyObject(const bool&amp; x)
+PyObject* ConvertToPyObject&lt;bool&gt;::newPyObject(const bool&amp; x)
 {
     if (x) {
         Py_XINCREF(Py_True);
@@ -644,43 +670,43 @@
 }
 
 
-PyObject* PythonObjectWrapper::newPyObject(const int&amp; x)
+PyObject* ConvertToPyObject&lt;int&gt;::newPyObject(const int&amp; x)
 {
     return PyInt_FromLong(long(x));
 }
 
-PyObject* PythonObjectWrapper::newPyObject(const unsigned int&amp; x)
+PyObject* ConvertToPyObject&lt;unsigned int&gt;::newPyObject(const unsigned int&amp; x)
 {
     return PyLong_FromUnsignedLong(static_cast&lt;unsigned long&gt;(x));
 }
     
-PyObject* PythonObjectWrapper::newPyObject(const long&amp; x)
+PyObject* ConvertToPyObject&lt;long&gt;::newPyObject(const long&amp; x)
 {
     return PyLong_FromLong(x);
 }
 
-PyObject* PythonObjectWrapper::newPyObject(const unsigned long&amp; x)
+PyObject* ConvertToPyObject&lt;unsigned long&gt;::newPyObject(const unsigned long&amp; x)
 {
     return PyLong_FromUnsignedLong(x);
 }
     
-PyObject* PythonObjectWrapper::newPyObject(const double&amp; x)
+PyObject* ConvertToPyObject&lt;double&gt;::newPyObject(const double&amp; x)
 {
     return PyFloat_FromDouble(x);
 }
 
-PyObject* PythonObjectWrapper::newPyObject(const char* x)
+PyObject* ConvertToPyObject&lt;char*&gt;::newPyObject(const char* x)
 {
     return PyString_FromString(x);
 }
     
-PyObject* PythonObjectWrapper::newPyObject(const string&amp; x)
+PyObject* ConvertToPyObject&lt;string&gt;::newPyObject(const string&amp; x)
 {
     return PyString_FromString(x.c_str());
 }
 
 
-PyObject* PythonObjectWrapper::newPyObject(const Vec&amp; data)
+PyObject* ConvertToPyObject&lt;Vec&gt;::newPyObject(const Vec&amp; data)
 {
     PyArrayObject* pyarr = 0;
     if (data.isNull() || data.isEmpty())
@@ -691,7 +717,7 @@
     return (PyObject*)pyarr;
 }
 
-PyObject* PythonObjectWrapper::newPyObject(const Mat&amp; data)
+PyObject* ConvertToPyObject&lt;Mat&gt;::newPyObject(const Mat&amp; data)
 {
     PyArrayObject* pyarr = 0;
     if (data.isNull() || data.isEmpty())
@@ -728,15 +754,16 @@
     return (PyObject*)pyarr;
 }
 
-PyObject* PythonObjectWrapper::newPyObject(const VMat&amp; vm)
+PyObject* ConvertToPyObject&lt;VMat&gt;::newPyObject(const VMat&amp; vm)
 {
     if (vm.isNull())
-        return newPyObject(Mat());
+        return ConvertToPyObject&lt;Mat&gt;::newPyObject(Mat());
     else
-        return newPyObject(vm.toMat());
+        return ConvertToPyObject&lt;Mat&gt;::newPyObject(vm.toMat());
+    //return ConvertToPyObject&lt;Object*&gt;::newPyObject(static_cast&lt;Object*&gt;(vm));
 }
 
-PyObject* PythonObjectWrapper::newPyObject(const PythonObjectWrapper&amp; pow)
+PyObject* ConvertToPyObject&lt;PythonObjectWrapper&gt;::newPyObject(const PythonObjectWrapper&amp; pow)
 {
     Py_XINCREF(pow.m_object);
     return pow.m_object;

Modified: trunk/plearn/python/PythonObjectWrapper.h
===================================================================
--- trunk/plearn/python/PythonObjectWrapper.h	2007-05-30 20:58:22 UTC (rev 7449)
+++ trunk/plearn/python/PythonObjectWrapper.h	2007-05-30 21:23:42 UTC (rev 7450)
@@ -225,6 +225,12 @@
 };
 
 template &lt;class T&gt;
+struct ConvertFromPyObject&lt;TMat&lt;T&gt; &gt;
+{
+    static TMat&lt;T&gt; convert(PyObject*, bool print_traceback);
+};
+
+template &lt;class T&gt;
 struct ConvertFromPyObject&lt; std::vector&lt;T&gt; &gt;
 {
     static std::vector&lt;T&gt; convert(PyObject*, bool print_traceback);
@@ -242,6 +248,148 @@
     static std::pair&lt;T,U&gt; convert(PyObject*, bool print_traceback);
 };
 
+
+/////////////////////////////////////
+// ConvertToPyObject&lt;&gt;
+// Conversions from PLearn to Python
+template&lt;typename T&gt;
+struct ConvertToPyObject
+{
+    static PyObject* newPyObject(const T&amp; x)
+    {
+        PLERROR(&quot;Cannot convert type %s by value to python&quot;,
+                TypeTraits&lt;T&gt;::name().c_str());
+        return 0;//shut up compiler
+    }
+};
+
+template&lt;&gt; struct ConvertToPyObject&lt;Object*&gt;
+{ static PyObject* newPyObject(const Object* x); };
+
+template&lt;&gt; struct ConvertToPyObject&lt;bool&gt;
+{ static PyObject* newPyObject(const bool&amp; x); };
+    
+template&lt;&gt; struct ConvertToPyObject&lt;int&gt;
+{ static PyObject* newPyObject(const int&amp; x); };
+template&lt;&gt; struct ConvertToPyObject&lt;unsigned int&gt;
+{ static PyObject* newPyObject(const unsigned int&amp; x); };
+    
+template&lt;&gt; struct ConvertToPyObject&lt;long&gt;
+{ static PyObject* newPyObject(const long&amp; x); };
+template&lt;&gt; struct ConvertToPyObject&lt;unsigned long&gt;
+{ static PyObject* newPyObject(const unsigned long&amp; x); };
+    
+template&lt;&gt; struct ConvertToPyObject&lt;double&gt;
+{ static PyObject* newPyObject(const double&amp; x); };
+
+template&lt;&gt; struct ConvertToPyObject&lt;char*&gt;
+{ static PyObject* newPyObject(const char* x); };
+
+template&lt;size_t N&gt; struct ConvertToPyObject&lt;char[N]&gt;
+{ static PyObject* newPyObject(const char x[N]); };
+    
+template&lt;&gt; struct ConvertToPyObject&lt;string&gt;
+{ static PyObject* newPyObject(const string&amp; x); };
+  
+//! PLearn Vec: use numarray
+template&lt;&gt; struct ConvertToPyObject&lt;Vec&gt;
+{ static PyObject* newPyObject(const Vec&amp;); };
+
+//! PLearn Mat: use numarray
+template&lt;&gt; struct ConvertToPyObject&lt;Mat&gt;
+{ static PyObject* newPyObject(const Mat&amp;); };
+
+//! PLearn VMat.  Very inefficient for now: convert to a temporary Mat
+//! and then bridge to using numarray.  Fieldnames and other metainfos
+//! are lost when converting to Python.
+//!
+//! @TODO  Must provide a complete Python wrapper over VMatrix objects
+template&lt;&gt; struct ConvertToPyObject&lt;VMat&gt;
+{ static PyObject* newPyObject(const VMat&amp; vm); };
+    
+//! Generic PP: wrap pointed object
+template&lt;class T&gt; struct ConvertToPyObject&lt;PP&lt;T&gt; &gt;
+{ static PyObject* newPyObject(const PP&lt;T&gt;&amp;); };
+    
+//! tuples (1 to 7 elts.)
+template&lt;class T&gt; 
+struct ConvertToPyObject&lt;tuple&lt;T&gt; &gt;
+{ static PyObject* newPyObject(const tuple&lt;T&gt;&amp;); };
+template &lt;class T, class U&gt; 
+struct ConvertToPyObject&lt;tuple&lt;T,U&gt; &gt;
+{ static PyObject* newPyObject(const tuple&lt;T, U&gt;&amp;); };
+template &lt;class T, class U, class V&gt; 
+struct ConvertToPyObject&lt;tuple&lt;T,U,V&gt; &gt;
+{ static PyObject* newPyObject(const tuple&lt;T, U, V&gt;&amp;); };
+template &lt;class T, class U, class V, class W&gt; 
+struct ConvertToPyObject&lt;tuple&lt;T,U,V,W&gt; &gt;
+{ static PyObject* newPyObject(const tuple&lt;T, U, V, W&gt;&amp;); };
+template &lt;class T, class U, class V, class W, class X&gt; 
+struct ConvertToPyObject&lt;tuple&lt;T,U,V,W,X&gt; &gt;
+{ static PyObject* newPyObject(const tuple&lt;T, U, V, W, X&gt;&amp;); };
+template &lt;class T, class U, class V, class W, class X, class Y&gt; 
+struct ConvertToPyObject&lt;tuple&lt;T,U,V,W,X,Y&gt; &gt;
+{ static PyObject* newPyObject(const tuple&lt;T, U, V, W, X, Y&gt;&amp;); };
+template &lt;class T, class U, class V, class W, class X, class Y, class Z&gt; 
+struct ConvertToPyObject&lt;tuple&lt;T,U,V,W,X,Y,Z&gt; &gt;
+{ static PyObject* newPyObject(const tuple&lt;T, U, V, W, X, Y, Z&gt;&amp;); };
+
+//! Generic vector: create a Python list of those objects recursively
+template &lt;class T&gt; struct ConvertToPyObject&lt;TVec&lt;T&gt; &gt;
+{ static PyObject* newPyObject(const TVec&lt;T&gt;&amp;); };
+
+//! Generic matrix: create a Python list of those objects recursively
+template &lt;class T&gt; struct ConvertToPyObject&lt;TMat&lt;T&gt; &gt;
+{ static PyObject* newPyObject(const TMat&lt;T&gt;&amp;); };
+
+//! C++ stdlib vector&lt;&gt;: create a Python list of those objects recursively
+template &lt;class T&gt; struct ConvertToPyObject&lt;std::vector&lt;T&gt; &gt;
+{ static PyObject* newPyObject(const std::vector&lt;T&gt;&amp;); };
+
+//! C++ stlib map&lt;&gt;: create a Python dict of those objects
+template &lt;class T, class U&gt; struct ConvertToPyObject&lt;std::map&lt;T,U&gt; &gt;
+{ static PyObject* newPyObject(const std::map&lt;T,U&gt;&amp;); };
+
+//! C++ stdlib pair&lt;&gt;: create a Python tuple with two elements
+template &lt;class T, class U&gt; struct ConvertToPyObject&lt;std::pair&lt;T,U&gt; &gt;
+{ static PyObject* newPyObject(const std::pair&lt;T,U&gt;&amp;); };
+    
+//! Pointer to vector&lt;&gt;: simply dereference pointer, or None if NULL
+//!
+//! (NOTE: we don't have conversion from general pointer type since it's
+//! not clear that we always want to convert by dereferencing; for some
+//! object types, it's possible that we want to preserve object identities).
+template &lt;class T&gt; struct ConvertToPyObject&lt;std::vector&lt;T&gt; const* &gt;
+{ static PyObject* newPyObject(const std::vector&lt;T&gt;*); };
+
+//! Pointer to map&lt;&gt;: simply dereference pointer, or None if NULL
+template &lt;class T, class U&gt; struct ConvertToPyObject&lt;std::map&lt;T,U&gt; const* &gt;
+{ static PyObject* newPyObject(const std::map&lt;T,U&gt;*); };
+
+//! For a general PythonObjectWrapper: we simply increment the refcount
+//! to the underlying Python object, no matter whether we own it or not.
+template&lt;&gt; struct ConvertToPyObject&lt;PythonObjectWrapper&gt;
+{ static PyObject* newPyObject(const PythonObjectWrapper&amp; pow); };
+
+
+
+struct PLPyClass
+{
+    // holds info about a PLearn class
+    // injected into python
+    PLPyClass(PyObject* pyclass_,
+              PP&lt;PObjectPool&lt;PyMethodDef&gt; &gt;&amp; methods_)
+        :pyclass(pyclass_),
+         methods(methods_),
+         methods_help(0),
+         nref(1)
+    {}
+    PyObject* pyclass;
+    PP&lt;PObjectPool&lt;PyMethodDef&gt; &gt; methods;
+    TVec&lt;string&gt; methods_help;
+    int nref;
+};
+
 //#####  PythonGlobalInterpreterLock  #########################################
 
 /**
@@ -342,16 +490,16 @@
     
     //! Constructor for general type (forwarded to newPyObject)
     template &lt;class T&gt;
-    PythonObjectWrapper(const T&amp; x, OwnershipMode o = control_ownership,
+    explicit PythonObjectWrapper(const T&amp; x, OwnershipMode o = control_ownership,
                         bool acquire_gil = true)
         : m_ownership(o)
     {
         if (acquire_gil) {
             PythonGlobalInterpreterLock gil;
-            m_object = newPyObject(x);
+            m_object = ConvertToPyObject&lt;T&gt;::newPyObject(x);
         }
         else
-            m_object = newPyObject(x);
+            m_object = ConvertToPyObject&lt;T&gt;::newPyObject(x);
     }
 
     //! Copy constructor: increment refcount if controlling ownership.
@@ -419,89 +567,9 @@
      *  @function newPyObject
      *  @brief    Create a raw \c PyObject* from various types
      */
+
     static PyObject* newPyObject();  //!&lt; Return None (increments refcount)
 
-    static PyObject* newPyObject(const Object* x);
-
-    static PyObject* newPyObject(const bool&amp; x);
-    
-    static PyObject* newPyObject(const int&amp; x);
-    static PyObject* newPyObject(const unsigned int&amp; x);
-    
-    static PyObject* newPyObject(const long&amp; x);
-    static PyObject* newPyObject(const unsigned long&amp; x);
-    
-    static PyObject* newPyObject(const double&amp; x);
-
-    static PyObject* newPyObject(const char* x);
-    
-    static PyObject* newPyObject(const string&amp; x);
-  
-    //! PLearn Vec: use numarray
-    static PyObject* newPyObject(const Vec&amp;);
-
-    //! PLearn Mat: use numarray
-    static PyObject* newPyObject(const Mat&amp;);
-
-    //! PLearn VMat.  Very inefficient for now: convert to a temporary Mat
-    //! and then bridge to using numarray.  Fieldnames and other metainfos
-    //! are lost when converting to Python.
-    //!
-    //! @TODO  Must provide a complete Python wrapper over VMatrix objects
-    static PyObject* newPyObject(const VMat&amp; vm);
-    
-    //! Generic PP: wrap pointed object
-    template &lt;class T&gt;
-    static PyObject* newPyObject(const PP&lt;T&gt;&amp;);
-    
-    //! tuples (1 to 7 elts.)
-    template &lt;class T&gt;
-    static PyObject* newPyObject(const tuple&lt;T&gt;&amp;);
-    template &lt;class T, class U&gt;
-    static PyObject* newPyObject(const tuple&lt;T, U&gt;&amp;);
-    template &lt;class T, class U, class V&gt;
-    static PyObject* newPyObject(const tuple&lt;T, U, V&gt;&amp;);
-    template &lt;class T, class U, class V, class W&gt;
-    static PyObject* newPyObject(const tuple&lt;T, U, V, W&gt;&amp;);
-    template &lt;class T, class U, class V, class W, class X&gt;
-    static PyObject* newPyObject(const tuple&lt;T, U, V, W, X&gt;&amp;);
-    template &lt;class T, class U, class V, class W, class X, class Y&gt;
-    static PyObject* newPyObject(const tuple&lt;T, U, V, W, X, Y&gt;&amp;);
-    template &lt;class T, class U, class V, class W, class X, class Y, class Z&gt;
-    static PyObject* newPyObject(const tuple&lt;T, U, V, W, X, Y, Z&gt;&amp;);
-
-    //! Generic vector: create a Python list of those objects recursively
-    template &lt;class T&gt;
-    static PyObject* newPyObject(const TVec&lt;T&gt;&amp;);
-
-    //! C++ stdlib vector&lt;&gt;: create a Python list of those objects recursively
-    template &lt;class T&gt;
-    static PyObject* newPyObject(const std::vector&lt;T&gt;&amp;);
-
-    //! C++ stlib map&lt;&gt;: create a Python dict of those objects
-    template &lt;class T, class U&gt;
-    static PyObject* newPyObject(const std::map&lt;T,U&gt;&amp;);
-
-    //! C++ stdlib pair&lt;&gt;: create a Python tuple with two elements
-    template &lt;class T, class U&gt;
-    static PyObject* newPyObject(const std::pair&lt;T,U&gt;&amp;);
-    
-    //! Pointer to vector&lt;&gt;: simply dereference pointer, or None if NULL
-    //!
-    //! (NOTE: we don't have conversion from general pointer type since it's
-    //! not clear that we always want to convert by dereferencing; for some
-    //! object types, it's possible that we want to preserve object identities).
-    template &lt;class T&gt;
-    static PyObject* newPyObject(const std::vector&lt;T&gt;*);
-
-    //! Pointer to map&lt;&gt;: simply dereference pointer, or None if NULL
-    template &lt;class T, class U&gt;
-    static PyObject* newPyObject(const std::map&lt;T,U&gt;*);
-
-    //! For a general PythonObjectWrapper: we simply increment the refcount
-    //! to the underlying Python object, no matter whether we own it or not.
-    static PyObject* newPyObject(const PythonObjectWrapper&amp; pow);
-    
     /**
      *  This function is called by PythonCodeSnippet to carry out
      *  initializations related to libnumarray.
@@ -512,23 +580,6 @@
     OwnershipMode m_ownership;               //!&lt; Whether we own the PyObject or not
     PyObject* m_object;
     
-    struct PLPyClass
-    {
-        // holds info about a PLearn class
-        // injected into python
-        PLPyClass(PyObject* pyclass_,
-                  PP&lt;PObjectPool&lt;PyMethodDef&gt; &gt;&amp; methods_)
-            :pyclass(pyclass_),
-             methods(methods_),
-             methods_help(0),
-             nref(1)
-        {}
-        PyObject* pyclass;
-        PP&lt;PObjectPool&lt;PyMethodDef&gt; &gt; methods;
-        TVec&lt;string&gt; methods_help;
-        int nref;
-    };
-
     //for the unique unref injected method
     static bool m_unref_injected;
     static PyMethodDef m_unref_method_def;
@@ -539,6 +590,8 @@
     typedef map&lt;const Object*, PyObject*&gt; wrapped_objects_t;
 
     static wrapped_objects_t m_wrapped_objects; //!&lt; for wrapped PLearn Objects
+
+    template&lt;class T&gt; friend class ConvertToPyObject;
 };
 
 
@@ -593,6 +646,48 @@
 }
 
 template &lt;class T&gt;
+TMat&lt;T&gt; ConvertFromPyObject&lt;TMat&lt;T&gt; &gt;::convert(PyObject* pyobj, bool print_traceback)
+{
+    PLASSERT( pyobj );
+    
+    // Here, we support both Python Tuples and Lists
+    if (PyTuple_Check(pyobj)) {
+        // Tuple case
+        int len= PyTuple_GET_SIZE(pyobj);
+        TMat&lt;T&gt; v;
+        for(int i= 0; i &lt; len; ++i) 
+        {
+            PyObject* row_i= PyTuple_GET_ITEM(pyobj, i);
+            TVec&lt;T&gt; r= ConvertFromPyObject&lt;TVec&lt;T&gt; &gt;::convert(row_i, print_traceback);
+            if(i == 0)
+                v.resize(0, r.size());
+            v.appendRow(r);
+        }
+        return v;
+    }
+    else if (PyList_Check(pyobj)) {
+        // List case
+        int len= PyList_GET_SIZE(pyobj);
+        TMat&lt;T&gt; v;
+        for(int i= 0; i &lt; len; ++i) 
+        {
+            PyObject* row_i= PyList_GET_ITEM(pyobj, i);
+            TVec&lt;T&gt; r= ConvertFromPyObject&lt;TVec&lt;T&gt; &gt;::convert(row_i, print_traceback);
+            if(i == 0)
+                v.resize(0, r.size());
+            v.appendRow(r);
+        }
+        return v;
+    }
+    else
+        PLPythonConversionError(&quot;ConvertFromPyObject&lt; TMat&lt;T&gt; &gt;&quot;, pyobj,
+                                print_traceback);
+
+    return TMat&lt;T&gt;();                        // Shut up compiler
+}
+
+
+template &lt;class T&gt;
 std::vector&lt;T&gt; ConvertFromPyObject&lt; std::vector&lt;T&gt; &gt;::convert(PyObject* pyobj,
                                                               bool print_traceback)
 {
@@ -650,40 +745,65 @@
 
 //#####  newPyObject Implementations  #########################################
 
+template&lt;size_t N&gt; 
+PyObject*  ConvertToPyObject&lt;char[N]&gt;::newPyObject(const char x[N])
+{
+    return ConvertToPyObject&lt;char*&gt;::newPyObject(x);
+}
+
+
 template &lt;class T&gt;
-PyObject* PythonObjectWrapper::newPyObject(const PP&lt;T&gt;&amp; data)
+PyObject* ConvertToPyObject&lt;PP&lt;T&gt; &gt;::newPyObject(const PP&lt;T&gt;&amp; data)
 {
-    return newPyObject(static_cast&lt;T*&gt;(data));
+    Object* o= dynamic_cast&lt;Object*&gt;(static_cast&lt;T*&gt;(data));
+    if(o)
+        return ConvertToPyObject&lt;Object*&gt;::newPyObject(o);
+    return ConvertToPyObject&lt;T*&gt;::newPyObject(static_cast&lt;T*&gt;(data));
 }
 
 template &lt;class T&gt;
-PyObject* PythonObjectWrapper::newPyObject(const TVec&lt;T&gt;&amp; data)
+PyObject* ConvertToPyObject&lt;TVec&lt;T&gt; &gt;::newPyObject(const TVec&lt;T&gt;&amp; data)
 {
     PyObject* newlist = PyList_New(data.size());
     for (int i=0, n=data.size() ; i&lt;n ; ++i) {
         // Since PyList_SET_ITEM steals the reference to the item being set,
         // one does not need to Py_XDECREF the inserted string as was required
         // for the PyArrayObject code above...
-        PyList_SET_ITEM(newlist, i, newPyObject(data[i]));
+        PyList_SET_ITEM(newlist, i, ConvertToPyObject&lt;T&gt;::newPyObject(data[i]));
     }
     return newlist;
 }
 
 template &lt;class T&gt;
-PyObject* PythonObjectWrapper::newPyObject(const std::vector&lt;T&gt;&amp; data)
+PyObject* ConvertToPyObject&lt;TMat&lt;T&gt; &gt;::newPyObject(const TMat&lt;T&gt;&amp; data)
 {
     PyObject* newlist = PyList_New(data.size());
+    for (int i=0, n=data.size() ; i&lt;n ; ++i) 
+    {
+        // Since PyList_SET_ITEM steals the reference to the item being set,
+        // one does not need to Py_XDECREF the inserted string as was required
+        // for the PyArrayObject code above...
+        PyList_SET_ITEM(newlist, i, 
+                        ConvertToPyObject&lt;TVec&lt;T&gt; &gt;::newPyObject(data(i)));
+    }
+    return newlist;
+}
+
+template &lt;class T&gt;
+PyObject* ConvertToPyObject&lt;std::vector&lt;T&gt; &gt;::newPyObject(const std::vector&lt;T&gt;&amp; data)
+{
+    PyObject* newlist = PyList_New(data.size());
     for (int i=0, n=data.size() ; i&lt;n ; ++i) {
         // Since PyList_SET_ITEM steals the reference to the item being set,
         // one does not need to Py_XDECREF the inserted string as was required
         // for the PyArrayObject code above...
-        PyList_SET_ITEM(newlist, i, newPyObject(data[i]));
+        PyList_SET_ITEM(newlist, i, ConvertToPyObject&lt;T&gt;::newPyObject(data[i]));
     }
     return newlist;
 }
     
 template &lt;class T, class U&gt;
-PyObject* PythonObjectWrapper::newPyObject(const std::map&lt;T,U&gt;&amp; data)
+PyObject* ConvertToPyObject&lt;std::map&lt;T,U&gt; &gt;::newPyObject(const std::map&lt;T,U&gt;&amp; data)
 {
     // From the Python C API Documentation section 1.10.2: (Note that
     // PyDict_SetItem() and friends don't take over ownership -- they are
@@ -692,8 +812,8 @@
     for (typename std::map&lt;T,U&gt;::const_iterator it = data.begin(), end = data.end() ;
          it != end ; ++it)
     {
-        PyObject* new_key = newPyObject(it-&gt;first);
-        PyObject* new_val = newPyObject(it-&gt;second);
+        PyObject* new_key = ConvertToPyObject&lt;T&gt;::newPyObject(it-&gt;first);
+        PyObject* new_val = ConvertToPyObject&lt;U&gt;::newPyObject(it-&gt;second);
         int non_success = PyDict_SetItem(newdict, new_key, new_val);
         Py_XDECREF(new_key);
         Py_XDECREF(new_val);
@@ -709,109 +829,109 @@
 }
 
 template &lt;class T, class U&gt;
-PyObject* PythonObjectWrapper::newPyObject(const std::pair&lt;T,U&gt;&amp; data)
+PyObject* ConvertToPyObject&lt;std::pair&lt;T,U&gt; &gt;::newPyObject(const std::pair&lt;T,U&gt;&amp; data)
 {
     // According to Python Doc, since PyTuple_SET_ITEM steals the reference to
     // the item being set, one does not need to Py_XDECREF the inserted object.
     PyObject* newtuple = PyTuple_New(2);
-    PyTuple_SET_ITEM(newtuple, 0, newPyObject(data.first));
-    PyTuple_SET_ITEM(newtuple, 1, newPyObject(data.second));
+    PyTuple_SET_ITEM(newtuple, 0, ConvertToPyObject&lt;T&gt;::newPyObject(data.first));
+    PyTuple_SET_ITEM(newtuple, 1, ConvertToPyObject&lt;U&gt;::newPyObject(data.second));
     return newtuple;
 }
 
 template &lt;class T&gt;
-PyObject* PythonObjectWrapper::newPyObject(const tuple&lt;T&gt;&amp; data)
+PyObject* ConvertToPyObject&lt;tuple&lt;T&gt; &gt;::newPyObject(const tuple&lt;T&gt;&amp; data)
 {
     PyObject* newtuple= PyTuple_New(1);
-    PyTuple_SET_ITEM(newtuple, 0, newPyObject(get&lt;0&gt;(data)));
+    PyTuple_SET_ITEM(newtuple, 0, ConvertToPyObject&lt;T&gt;::newPyObject(get&lt;0&gt;(data)));
     return newtuple;
 }
 
 template &lt;class T, class U&gt;
-PyObject* PythonObjectWrapper::newPyObject(const tuple&lt;T, U&gt;&amp; data)
+PyObject* ConvertToPyObject&lt;tuple&lt;T,U&gt; &gt;::newPyObject(const tuple&lt;T, U&gt;&amp; data)
 {
     PyObject* newtuple= PyTuple_New(2);
-    PyTuple_SET_ITEM(newtuple, 0, newPyObject(get&lt;0&gt;(data)));
-    PyTuple_SET_ITEM(newtuple, 1, newPyObject(get&lt;1&gt;(data)));
+    PyTuple_SET_ITEM(newtuple, 0, ConvertToPyObject&lt;T&gt;::newPyObject(get&lt;0&gt;(data)));
+    PyTuple_SET_ITEM(newtuple, 1, ConvertToPyObject&lt;U&gt;::newPyObject(get&lt;1&gt;(data)));
     return newtuple;
 }
 
 template &lt;class T, class U, class V&gt;
-PyObject* PythonObjectWrapper::newPyObject(const tuple&lt;T, U, V&gt;&amp; data)
+PyObject* ConvertToPyObject&lt;tuple&lt;T,U,V&gt; &gt;::newPyObject(const tuple&lt;T, U, V&gt;&amp; data)
 {
     PyObject* newtuple= PyTuple_New(3);
-    PyTuple_SET_ITEM(newtuple, 0, newPyObject(get&lt;0&gt;(data)));
-    PyTuple_SET_ITEM(newtuple, 1, newPyObject(get&lt;1&gt;(data)));
-    PyTuple_SET_ITEM(newtuple, 2, newPyObject(get&lt;2&gt;(data)));
+    PyTuple_SET_ITEM(newtuple, 0, ConvertToPyObject&lt;T&gt;::newPyObject(get&lt;0&gt;(data)));
+    PyTuple_SET_ITEM(newtuple, 1, ConvertToPyObject&lt;U&gt;::newPyObject(get&lt;1&gt;(data)));
+    PyTuple_SET_ITEM(newtuple, 2, ConvertToPyObject&lt;V&gt;::newPyObject(get&lt;2&gt;(data)));
     return newtuple;
 }
 
 template &lt;class T, class U, class V, class W&gt;
-PyObject* PythonObjectWrapper::newPyObject(const tuple&lt;T, U, V, W&gt;&amp; data)
+PyObject* ConvertToPyObject&lt;tuple&lt;T,U,V,W&gt; &gt;::newPyObject(const tuple&lt;T, U, V, W&gt;&amp; data)
 {
     PyObject* newtuple= PyTuple_New(4);
-    PyTuple_SET_ITEM(newtuple, 0, newPyObject(get&lt;0&gt;(data)));
-    PyTuple_SET_ITEM(newtuple, 1, newPyObject(get&lt;1&gt;(data)));
-    PyTuple_SET_ITEM(newtuple, 2, newPyObject(get&lt;2&gt;(data)));
-    PyTuple_SET_ITEM(newtuple, 3, newPyObject(get&lt;3&gt;(data)));
+    PyTuple_SET_ITEM(newtuple, 0, ConvertToPyObject&lt;T&gt;::newPyObject(get&lt;0&gt;(data)));
+    PyTuple_SET_ITEM(newtuple, 1, ConvertToPyObject&lt;U&gt;::newPyObject(get&lt;1&gt;(data)));
+    PyTuple_SET_ITEM(newtuple, 2, ConvertToPyObject&lt;V&gt;::newPyObject(get&lt;2&gt;(data)));
+    PyTuple_SET_ITEM(newtuple, 3, ConvertToPyObject&lt;W&gt;::newPyObject(get&lt;3&gt;(data)));
     return newtuple;
 }
 
 template &lt;class T, class U, class V, class W, class X&gt;
-PyObject* PythonObjectWrapper::newPyObject(const tuple&lt;T, U, V, W, X&gt;&amp; data)
+PyObject* ConvertToPyObject&lt;tuple&lt;T,U,V,W,X&gt; &gt;::newPyObject(const tuple&lt;T, U, V, W, X&gt;&amp; data)
 {
     PyObject* newtuple= PyTuple_New(5);
-    PyTuple_SET_ITEM(newtuple, 0, newPyObject(get&lt;0&gt;(data)));
-    PyTuple_SET_ITEM(newtuple, 1, newPyObject(get&lt;1&gt;(data)));
-    PyTuple_SET_ITEM(newtuple, 2, newPyObject(get&lt;2&gt;(data)));
-    PyTuple_SET_ITEM(newtuple, 3, newPyObject(get&lt;3&gt;(data)));
-    PyTuple_SET_ITEM(newtuple, 4, newPyObject(get&lt;4&gt;(data)));
+    PyTuple_SET_ITEM(newtuple, 0, ConvertToPyObject&lt;T&gt;::newPyObject(get&lt;0&gt;(data)));
+    PyTuple_SET_ITEM(newtuple, 1, ConvertToPyObject&lt;U&gt;::newPyObject(get&lt;1&gt;(data)));
+    PyTuple_SET_ITEM(newtuple, 2, ConvertToPyObject&lt;V&gt;::newPyObject(get&lt;2&gt;(data)));
+    PyTuple_SET_ITEM(newtuple, 3, ConvertToPyObject&lt;W&gt;::newPyObject(get&lt;3&gt;(data)));
+    PyTuple_SET_ITEM(newtuple, 4, ConvertToPyObject&lt;X&gt;::newPyObject(get&lt;4&gt;(data)));
     return newtuple;
 }
 
 template &lt;class T, class U, class V, class W, class X, class Y&gt;
-PyObject* PythonObjectWrapper::newPyObject(const tuple&lt;T, U, V, W, X, Y&gt;&amp; data)
+PyObject* ConvertToPyObject&lt;tuple&lt;T,U,V,W,X,Y&gt; &gt;::newPyObject(const tuple&lt;T, U, V, W, X, Y&gt;&amp; data)
 {
     PyObject* newtuple= PyTuple_New(6);
-    PyTuple_SET_ITEM(newtuple, 0, newPyObject(get&lt;0&gt;(data)));
-    PyTuple_SET_ITEM(newtuple, 1, newPyObject(get&lt;1&gt;(data)));
-    PyTuple_SET_ITEM(newtuple, 2, newPyObject(get&lt;2&gt;(data)));
-    PyTuple_SET_ITEM(newtuple, 3, newPyObject(get&lt;3&gt;(data)));
-    PyTuple_SET_ITEM(newtuple, 4, newPyObject(get&lt;4&gt;(data)));
-    PyTuple_SET_ITEM(newtuple, 5, newPyObject(get&lt;5&gt;(data)));
+    PyTuple_SET_ITEM(newtuple, 0, ConvertToPyObject&lt;T&gt;::newPyObject(get&lt;0&gt;(data)));
+    PyTuple_SET_ITEM(newtuple, 1, ConvertToPyObject&lt;U&gt;::newPyObject(get&lt;1&gt;(data)));
+    PyTuple_SET_ITEM(newtuple, 2, ConvertToPyObject&lt;V&gt;::newPyObject(get&lt;2&gt;(data)));
+    PyTuple_SET_ITEM(newtuple, 3, ConvertToPyObject&lt;W&gt;::newPyObject(get&lt;3&gt;(data)));
+    PyTuple_SET_ITEM(newtuple, 4, ConvertToPyObject&lt;X&gt;::newPyObject(get&lt;4&gt;(data)));
+    PyTuple_SET_ITEM(newtuple, 5, ConvertToPyObject&lt;Y&gt;::newPyObject(get&lt;5&gt;(data)));
     return newtuple;
 }
 
 template &lt;class T, class U, class V, class W, class X, class Y, class Z&gt;
-PyObject* PythonObjectWrapper::newPyObject(const tuple&lt;T, U, V, W, X, Y, Z&gt;&amp; data)
+PyObject* ConvertToPyObject&lt;tuple&lt;T,U,V,W,X,Y,Z&gt; &gt;::newPyObject(const tuple&lt;T, U, V, W, X, Y, Z&gt;&amp; data)
 {
     PyObject* newtuple= PyTuple_New(7);
-    PyTuple_SET_ITEM(newtuple, 0, newPyObject(get&lt;0&gt;(data)));
-    PyTuple_SET_ITEM(newtuple, 1, newPyObject(get&lt;1&gt;(data)));
-    PyTuple_SET_ITEM(newtuple, 2, newPyObject(get&lt;2&gt;(data)));
-    PyTuple_SET_ITEM(newtuple, 3, newPyObject(get&lt;3&gt;(data)));
-    PyTuple_SET_ITEM(newtuple, 4, newPyObject(get&lt;4&gt;(data)));
-    PyTuple_SET_ITEM(newtuple, 5, newPyObject(get&lt;5&gt;(data)));
-    PyTuple_SET_ITEM(newtuple, 6, newPyObject(get&lt;6&gt;(data)));
+    PyTuple_SET_ITEM(newtuple, 0, ConvertToPyObject&lt;T&gt;::newPyObject(get&lt;0&gt;(data)));
+    PyTuple_SET_ITEM(newtuple, 1, ConvertToPyObject&lt;U&gt;::newPyObject(get&lt;1&gt;(data)));
+    PyTuple_SET_ITEM(newtuple, 2, ConvertToPyObject&lt;V&gt;::newPyObject(get&lt;2&gt;(data)));
+    PyTuple_SET_ITEM(newtuple, 3, ConvertToPyObject&lt;W&gt;::newPyObject(get&lt;3&gt;(data)));
+    PyTuple_SET_ITEM(newtuple, 4, ConvertToPyObject&lt;X&gt;::newPyObject(get&lt;4&gt;(data)));
+    PyTuple_SET_ITEM(newtuple, 5, ConvertToPyObject&lt;Y&gt;::newPyObject(get&lt;5&gt;(data)));
+    PyTuple_SET_ITEM(newtuple, 6, ConvertToPyObject&lt;Z&gt;::newPyObject(get&lt;6&gt;(data)));
     return newtuple;
 }
 
 template &lt;class T&gt;
-PyObject* PythonObjectWrapper::newPyObject(const std::vector&lt;T&gt;* data)
+PyObject* ConvertToPyObject&lt;std::vector&lt;T&gt; const* &gt;::newPyObject(const std::vector&lt;T&gt;* data)
 {
     if (data)
-        return newPyObject(*data);
+        return ConvertToPyObject&lt;std::vector&lt;T&gt; &gt;::newPyObject(*data);
     else
-        return newPyObject();
+        return PythonObjectWrapper::newPyObject();
 }
 
 template &lt;class T, class U&gt;
-PyObject* PythonObjectWrapper::newPyObject(const std::map&lt;T,U&gt;* data)
+PyObject* ConvertToPyObject&lt;std::map&lt;T,U&gt; const* &gt;::newPyObject(const std::map&lt;T,U&gt;* data)
 {
     if (data)
-        return newPyObject(*data);
+        return ConvertToPyObject&lt;std::map&lt;T,U&gt; &gt;::newPyObject(*data);
     else
-        return newPyObject();
+        return PythonObjectWrapper::newPyObject();
 }
 
 PStream&amp; operator&gt;&gt;(PStream&amp; in, PythonObjectWrapper&amp; v);

Modified: trunk/plearn/python/PythonProcessedVMatrix.cc
===================================================================
--- trunk/plearn/python/PythonProcessedVMatrix.cc	2007-05-30 20:58:22 UTC (rev 7449)
+++ trunk/plearn/python/PythonProcessedVMatrix.cc	2007-05-30 21:23:42 UTC (rev 7450)
@@ -235,7 +235,7 @@
 
     sourcerow.resize(source-&gt;width());
     source-&gt;getRow(i, sourcerow);
-    return sourcerow;
+    return PythonObjectWrapper(sourcerow);
 }
 
 

Modified: trunk/plearn/vmat/VMatrix.cc
===================================================================
--- trunk/plearn/vmat/VMatrix.cc	2007-05-30 20:58:22 UTC (rev 7449)
+++ trunk/plearn/vmat/VMatrix.cc	2007-05-30 21:23:42 UTC (rev 7450)
@@ -225,6 +225,14 @@
         (BodyDoc(&quot;Saves this matrix as a .pmat file.&quot;),
          ArgDoc (&quot;pmatfile&quot;, &quot;Path of the file to create.&quot;)));
 
+    declareMethod(
+        rmm, &quot;subMat&quot;, &amp;VMatrix::subMat,
+        (BodyDoc(&quot;Return a sub-matrix from a VMatrix\n&quot;),
+         ArgDoc (&quot;i&quot;, &quot;start row&quot;),
+         ArgDoc (&quot;j&quot;, &quot;start col&quot;),
+         ArgDoc (&quot;l&quot;, &quot;length&quot;),
+         ArgDoc (&quot;w&quot;, &quot;width&quot;),
+         RetDoc (&quot;The sub-VMatrix&quot;)));
 }
 
 

Modified: trunk/plearn_learners/generic/PLearner.cc
===================================================================
--- trunk/plearn_learners/generic/PLearner.cc	2007-05-30 20:58:22 UTC (rev 7449)
+++ trunk/plearn_learners/generic/PLearner.cc	2007-05-30 21:23:42 UTC (rev 7450)
@@ -280,6 +280,11 @@
                  &quot;upon setting the training set\n&quot;)));
 
     declareMethod(
+        rmm, &quot;getTrainingSet&quot;, &amp;PLearner::getTrainingSet,
+        (BodyDoc(&quot;Returns the current training set.&quot;),
+         RetDoc (&quot;The trainset&quot;)));
+
+    declareMethod(
         rmm, &quot;setExperimentDirectory&quot;, &amp;PLearner::setExperimentDirectory,
         (BodyDoc(&quot;The experiment directory is the directory in which files related to\n&quot;
                  &quot;this model are to be saved.  If it is an empty string, it is understood\n&quot;

Modified: trunk/python_modules/plearn/pybridge/embedded_code_snippet.py
===================================================================
--- trunk/python_modules/plearn/pybridge/embedded_code_snippet.py	2007-05-30 20:58:22 UTC (rev 7449)
+++ trunk/python_modules/plearn/pybridge/embedded_code_snippet.py	2007-05-30 21:23:42 UTC (rev 7450)
@@ -1,3 +1,33 @@
+#
+# Copyright (C) 2007 Xavier Saint-Mleux, ApSTAT Technologies inc.
+#
+#  Redistribution and use in source and binary forms, with or without
+#  modification, are permitted provided that the following conditions are met:
+#
+#   1. Redistributions of source code must retain the above copyright
+#      notice, this list of conditions and the following disclaimer.
+#
+#   2. Redistributions in binary form must reproduce the above copyright
+#      notice, this list of conditions and the following disclaimer in the
+#      documentation and/or other materials provided with the distribution.
+#
+#   3. The name of the authors may not be used to endorse or promote
+#      products derived from this software without specific prior written
+#      permission.
+#
+#  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
+#  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+#  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
+#  NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+#  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+#  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+#  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+#  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+#  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+#  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+#  This file is part of the PLearn library. For more information on the PLearn
+#  library, go to the PLearn Web site at www.plearn.org
 
 class EmbeddedCodeSnippet(object):
     &quot;&quot;&quot;

Modified: trunk/python_modules/plearn/pybridge/wrapped_plearn_object.py
===================================================================
--- trunk/python_modules/plearn/pybridge/wrapped_plearn_object.py	2007-05-30 20:58:22 UTC (rev 7449)
+++ trunk/python_modules/plearn/pybridge/wrapped_plearn_object.py	2007-05-30 21:23:42 UTC (rev 7450)
@@ -1,3 +1,33 @@
+#
+# Copyright (C) 2007 Xavier Saint-Mleux, ApSTAT Technologies inc.
+#
+#  Redistribution and use in source and binary forms, with or without
+#  modification, are permitted provided that the following conditions are met:
+#
+#   1. Redistributions of source code must retain the above copyright
+#      notice, this list of conditions and the following disclaimer.
+#
+#   2. Redistributions in binary form must reproduce the above copyright
+#      notice, this list of conditions and the following disclaimer in the
+#      documentation and/or other materials provided with the distribution.
+#
+#   3. The name of the authors may not be used to endorse or promote
+#      products derived from this software without specific prior written
+#      permission.
+#
+#  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
+#  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+#  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
+#  NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+#  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+#  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+#  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+#  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+#  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+#  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+#  This file is part of the PLearn library. For more information on the PLearn
+#  library, go to the PLearn Web site at www.plearn.org
 
 class WrappedPLearnObject(object):
 
@@ -22,9 +52,33 @@
         return self.unref()
 
     def __repr__(self):
-        #s= self.__class__.__name__ + '('
-        #s+= ', '.join([o+'= '+repr(self.__getattr__(o))
-        #               for o in self._optionnames])
-        #s+= ')'
-        #return s
         return self.asString() #PLearn repr. for now
+
+from numarray import *
+
+class WrappedPLearnVMat(WrappedPLearnObject):
+    def __init__(self, cptr):
+        WrappedPLearnObject.__init__(self, cptr)
+
+    def __len__(self):
+        return self.length
+
+    def __getitem__(self, key):
+        l= len(self)
+        if isinstance(key,int):
+            if key &lt; 0: key+= l
+            if key &lt; 0 or key &gt;= l:
+                raise IndexError
+            return self.getRow(key)
+        if isinstance(key,slice):
+            start= key.start or 0
+            stop= key.stop or l-1
+            step= key.step or 1
+            if start &lt; 0: start+= l
+            if stop &lt; 0: stop+= l
+            if step==1:
+                return self.subMat(start, 0, stop-start, self.width)
+            #return pl.MemoryVMatrix(data= [self[i] for i in xrange(start, stop, step)])
+            raise NotImplementedError, 'slice step != 1'
+        raise TypeError, &quot;key should be an int or a slice&quot;
+    

Modified: trunk/python_modules/plearn/pyext/__init__.py
===================================================================
--- trunk/python_modules/plearn/pyext/__init__.py	2007-05-30 20:58:22 UTC (rev 7449)
+++ trunk/python_modules/plearn/pyext/__init__.py	2007-05-30 21:23:42 UTC (rev 7450)
@@ -42,10 +42,15 @@
     class __metaclass__(type):
         def __getattr__(cls, name):
             def newObj(**kwargs):
-                obj= newObject(name+'()')
+                call_build= True
+                obj= newObjectFromClassname(name)
                 for k in kwargs.keys():
-                    obj.__setattr__(k, kwargs[k])
-                obj.build()
+                    if k=='__call_build':
+                        call_build= kwargs[k]
+                    else:
+                        obj.__setattr__(k, kwargs[k])
+                if call_build:
+                    obj.build()
                 return obj
             return newObj
 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000898.html">[Plearn-commits] r7449 - trunk/plearn/io
</A></li>
	<LI>Next message: <A HREF="000900.html">[Plearn-commits] r7451 - trunk/python_modules/plearn/learners/autolr
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#899">[ date ]</a>
              <a href="thread.html#899">[ thread ]</a>
              <a href="subject.html#899">[ subject ]</a>
              <a href="author.html#899">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/plearn-commits">More information about the Plearn-commits
mailing list</a><br>
</body></html>
