<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Plearn-commits] r10228 - in trunk/scripts: . DEPRECATED
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/plearn-commits/2009-June/index.html" >
   <LINK REL="made" HREF="mailto:plearn-commits%40lists.berlios.de?Subject=Re%3A%20%5BPlearn-commits%5D%20r10228%20-%20in%20trunk/scripts%3A%20.%20DEPRECATED&In-Reply-To=%3C200906022300.n52N0HIC017039%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003667.html">
   <LINK REL="Next"  HREF="003669.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Plearn-commits] r10228 - in trunk/scripts: . DEPRECATED</H1>
    <B>plearner at BerliOS</B> 
    <A HREF="mailto:plearn-commits%40lists.berlios.de?Subject=Re%3A%20%5BPlearn-commits%5D%20r10228%20-%20in%20trunk/scripts%3A%20.%20DEPRECATED&In-Reply-To=%3C200906022300.n52N0HIC017039%40sheep.berlios.de%3E"
       TITLE="[Plearn-commits] r10228 - in trunk/scripts: . DEPRECATED">plearner at mail.berlios.de
       </A><BR>
    <I>Wed Jun  3 01:00:17 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="003667.html">[Plearn-commits] r10227 - in trunk/python_modules/plearn: . table
</A></li>
        <LI>Next message: <A HREF="003669.html">[Plearn-commits] r10229 - trunk/scripts
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3668">[ date ]</a>
              <a href="thread.html#3668">[ thread ]</a>
              <a href="subject.html#3668">[ subject ]</a>
              <a href="author.html#3668">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: plearner
Date: 2009-06-03 01:00:15 +0200 (Wed, 03 Jun 2009)
New Revision: 10228

Added:
   trunk/scripts/DEPRECATED/upackage.py
   trunk/scripts/plcollect
   trunk/scripts/pltable
Removed:
   trunk/scripts/upackage.py
Modified:
   trunk/scripts/cldispatch
Log:
ApSTAT contributions of a few scripts


Copied: trunk/scripts/DEPRECATED/upackage.py (from rev 10224, trunk/scripts/upackage.py)

Modified: trunk/scripts/cldispatch
===================================================================
--- trunk/scripts/cldispatch	2009-06-02 22:59:44 UTC (rev 10227)
+++ trunk/scripts/cldispatch	2009-06-02 23:00:15 UTC (rev 10228)
@@ -3,7 +3,37 @@
 # cldispatch: dispatch utility for parallel PLearn
 #
 # Copyright 2004, Apstat Technologies, inc.
-# All rights reserved.
+#
+# This file was contributed by ApSTAT Technologies to the
+# PLearn library under the following BSD-style license:
+#
+#  Redistribution and use in source and binary forms, with or without
+#  modification, are permitted provided that the following conditions are met:
+#
+#   1. Redistributions of source code must retain the above copyright
+#      notice, this list of conditions and the following disclaimer.
+#
+#   2. Redistributions in binary form must reproduce the above copyright
+#      notice, this list of conditions and the following disclaimer in the
+#      documentation and/or other materials provided with the distribution.
+#
+#   3. The name of the authors may not be used to endorse or promote
+#      products derived from this software without specific prior written
+#      permission.
+#
+#  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
+#  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+#  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
+#  NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+#  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+#  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+#  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+#  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+#  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+#  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+#  This file is part of the PLearn library. For more information on the PLearn
+#  library, go to the PLearn Web site at www.plearn.org
 
 from optparse import OptionParser
 from plearn.parallel.dispatch import *

Added: trunk/scripts/plcollect
===================================================================
--- trunk/scripts/plcollect	2009-06-02 22:59:44 UTC (rev 10227)
+++ trunk/scripts/plcollect	2009-06-02 23:00:15 UTC (rev 10228)
@@ -0,0 +1,154 @@
+#!/usr/bin/env python
+
+# plcollect.py
+# Copyright (C) 2008 Pascal Vincent
+#
+#  Redistribution and use in source and binary forms, with or without
+#  modification, are permitted provided that the following conditions are met:
+#
+#   1. Redistributions of source code must retain the above copyright
+#      notice, this list of conditions and the following disclaimer.
+#
+#   2. Redistributions in binary form must reproduce the above copyright
+#      notice, this list of conditions and the following disclaimer in the
+#      documentation and/or other materials provided with the distribution.
+#
+#   3. The name of the authors may not be used to endorse or promote
+#      products derived from this software without specific prior written
+#      permission.
+#
+#  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
+#  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+#  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
+#  NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+#  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+#  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+#  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+#  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+#  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+#  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+#  This file is part of the PLearn library. For more information on the PLearn
+#  library, go to the PLearn Web site at www.plearn.org
+
+
+import os
+import sys
+from os.path import join
+
+from plearn.table.table import *
+# from plearn.utilities.autoscript import autoscript
+
+def parse_filepath(filepath, separators=['__','/']):
+    &quot;&quot;&quot;parses the filepath:
+      Splits it on all given separators then checks each part in turn,
+      If it contains an = then it is assumed to form a key=value pair
+      and the coresponding pair which will get appended to a pairs_list.
+      If not the part is appended to a summarized path string.
+      The call returns a tuple (pairs_list, summarized_path).
+      &quot;&quot;&quot;
+    pairs_list = []
+    summarized_path = &quot;&quot;
+    n = len(filepath)
+    part_start = 0
+    i = 0
+    prev_sep = '' # previous found separator
+    added_ellipses = False    
+    while i&lt;n:
+        foundsep = None
+        for sep in separators:
+            if filepath[i:min(i+len(sep),n)]==sep: # we have found a separator
+                foundsep = sep
+                break
+        if foundsep is None and i==n-1: # consider the end of string as a separator
+            i += 1
+            foundsep = ''
+            
+        if foundsep is None: # no separator: increment i
+            i += 1
+        else: # found a separator: take care of that part
+            part = filepath[part_start:i]                
+            pair = tuple(part.split('=',1))
+            if len(pair)==2: # this part is a key=value pair: append it to the list
+                pairs_list.append(pair)
+                if not added_ellipses:
+                    summarized_path += '...'
+                    added_ellipses = True
+            else: # this part is not a key=value pair, append it to the summarized_path
+                if added_ellipses:
+                    summarized_path += prev_sep
+                summarized_path += part+foundsep
+                added_ellipses = False
+            # move past that separator
+            i += len(foundsep)
+            part_start = i
+            prev_sep = foundsep
+    return pairs_list, summarized_path
+
+def plcollect(rootdir=&quot;expdir&quot;, resultfile_txt=&quot;exp_results.txt&quot;, searchedfilenames=[]):
+    &quot;&quot;&quot;
+    Looks for all split_stats.pmat files it can find in rootdir and its subdirectories,
+    and comples them into a single resultfile_txt
+    &quot;&quot;&quot;
+
+    if len(searchedfilenames) == 0: # use default
+        searchedfilenames = [&quot;Strat0results.pmat&quot;]
+
+    filenames = []
+    # first look for all matching files
+    for root, dirs, files in os.walk(rootdir):
+        for filename in files:
+            if filename in searchedfilenames:
+                filenames.append(os.path.join(root,filename))
+
+    filepath_fields = []
+    content_fields = []
+    for filename in filenames:
+        pairs, summarypath = parse_filepath(filename)
+        t = openTable(filename)
+        for key,val in pairs:
+            if key not in filepath_fields:
+                filepath_fields.append(key)
+        for fieldname in t.fieldnames:
+            if fieldname not in content_fields:
+                content_fields.append(fieldname)
+
+    fieldnames = filepath_fields+content_fields
+    result_table = TableFile(resultfile_txt, 'w+', [&quot;_filepath_&quot;,&quot;_summarypath_&quot;]+fieldnames)
+    print &quot;fieldnames length:&quot;,len(fieldnames)
+
+    for filename in filenames:
+        try:
+            print &quot;Processing &quot;, filename
+            pairs, summarypath = parse_filepath(filename)
+            d = dict(pairs)
+            t = openTable(filename)
+            for trow in t:
+                d2 = d.copy()
+                d2.update(zip(t.fieldnames,trow))
+                resrow = [filename, summarypath]
+                for fieldname in fieldnames:
+                    if fieldname in d2:
+                        resrow.append(d2[fieldname])
+                    else:
+                        resrow.append(&quot;-&quot;)
+                result_table.append(resrow)
+        except struct.error:
+            print &quot;Probably a buggy .pmat&quot;
+
+
+if len(sys.argv)&lt;3:
+    print &quot;Usage: plcollect.py expdir results.txt list_of_matrix_filenames&quot;
+    print &quot;&quot;&quot;
+    Looks in expdir and its subdirectories for all matrix files whose name matches
+    one specified in the list_of_matrix_filenames  
+    and compiles their content into a single results.txt
+
+    list of matrix filenames if unspecified defaults to split_stats.pmat
+    &quot;&quot;&quot;
+    sys.exit()
+
+
+plcollect(sys.argv[1], sys.argv[2], sys.argv[3:])
+
+


Property changes on: trunk/scripts/plcollect
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/scripts/pltable
===================================================================
--- trunk/scripts/pltable	2009-06-02 22:59:44 UTC (rev 10227)
+++ trunk/scripts/pltable	2009-06-02 23:00:15 UTC (rev 10228)
@@ -0,0 +1,43 @@
+#!/usr/bin/env python
+
+&quot;&quot;&quot;
+pltable
+Copyright (C) 2005 ApSTAT Technologies Inc.
+
+This file was contributed by ApSTAT Technologies to the
+PLearn library under the following BSD-style license: 
+
+#  Redistribution and use in source and binary forms, with or without
+#  modification, are permitted provided that the following conditions are met:
+#
+#   1. Redistributions of source code must retain the above copyright
+#      notice, this list of conditions and the following disclaimer.
+#
+#   2. Redistributions in binary form must reproduce the above copyright
+#      notice, this list of conditions and the following disclaimer in the
+#      documentation and/or other materials provided with the distribution.
+#
+#   3. The name of the authors may not be used to endorse or promote
+#      products derived from this software without specific prior written
+#      permission.
+#
+#  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
+#  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+#  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
+#  NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+#  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+#  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+#  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+#  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+#  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+#  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+#  This file is part of the PLearn library. For more information on the PLearn
+#  library, go to the PLearn Web site at www.plearn.org
+&quot;&quot;&quot;
+
+import sys
+import cgitb; cgitb.enable(format='PLearn')
+from plearn.table.pltable_commands import main
+
+main(sys.argv)


Property changes on: trunk/scripts/pltable
___________________________________________________________________
Name: svn:executable
   + *

Deleted: trunk/scripts/upackage.py
===================================================================
--- trunk/scripts/upackage.py	2009-06-02 22:59:44 UTC (rev 10227)
+++ trunk/scripts/upackage.py	2009-06-02 23:00:15 UTC (rev 10228)
@@ -1,380 +0,0 @@
-#!/usr/bin/env python2.3
-
-# upackage
-#
-# Copyright (C) 2004 ApSTAT Technologies Inc.
-#
-#  Redistribution and use in source and binary forms, with or without
-#  modification, are permitted provided that the following conditions are met:
-#
-#   1. Redistributions of source code must retain the above copyright
-#      notice, this list of conditions and the following disclaimer.
-#
-#   2. Redistributions in binary form must reproduce the above copyright
-#      notice, this list of conditions and the following disclaimer in the
-#      documentation and/or other materials provided with the distribution.
-#
-#   3. The name of the authors may not be used to endorse or promote
-#      products derived from this software without specific prior written
-#      permission.
-#
-#  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
-#  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-#  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
-#  NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-#  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-#  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-#  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-#  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-#  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-#  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-#
-#  This file is part of the PLearn library. For more information on the PLearn
-#  library, go to the PLearn Web site at www.plearn.org
-
-# Author: Pascal Vincent
-__cvs_id__ = &quot;$Id$&quot;
-
-
-import sys
-import os
-import string
-import urllib
-
-upackagedir = os.environ.get('UPACKAGEDIR',os.path.join(os.environ.get(os.environ.get('HOME')),'.upackage'))
-
-def check_setup():
-    &quot;&quot;&quot;Checks setup for upackage.&quot;&quot;&quot;
-    if not os.path.isdir(upackagedir):
-        mkdir(upackagedir)
-
-    configfile = os.path.join(upackagedir,'config.py')
-    if not os.path.isfile(configfile):
-        f = open(configfile,'w')
-        f.write(&quot;&quot;&quot;
-upackage_sources = [  
-'/home/pascal/mypackages',
-'<A HREF="upackdb://www.upackages.org/upackdb">upackdb://www.upackages.org/upackdb</A>',
-'<A HREF="ftp://ftp.upackages.org/upackages">ftp://ftp.upackages.org/upackages</A>'
-]
-&quot;&quot;&quot;)
-        f.close()
-        print &quot;Created &quot;+configfile
-        print &quot;You may edit it to configure the behavior of upackage or to add sources of upackages.&quot;
-
-    # make sure we have a upackages sub-directory
-    mkdir(os.path.join(upackagedir,'upackages'))
-
-    improper_environment = False
-    if upackagedir not in string.split(os.environ.get('PYTHONPATH'),':'):        
-        print 'You must add '+upackagedir+' to the PYTHONPATH environment variable.'
-        improper_environment = True
-
-    platform = 'intel-linux'
-    prefixpath = os.path.join(os.path.join(upackagedir,'local'),platform)
-    # make sure we have a local/platform sub-directory
-    mkdir(prefixpath)
-
-    libdir = os.path.join(prefixpath,'lib')
-    if libdir not in string.split(os.environ.get('LD_LIBRARY_PATH'),':'):
-        print 'You must add '+libdir+' to the LD_LIBRARY_PATH environment variable.'
-        improper_environment = True
-
-    if libdir not in string.split(os.environ.get('LIBRARY_PATH'),':'):
-        print 'You must add '+libdir+' to the LIBRARY_PATH environment variable.'
-        improper_environment = True
-
-    includedir = os.path.join(prefixpath,'include')
-    if includedir not in string.split(os.environ.get('CPATH'),':'):
-        print 'You must add '+includedir+' to the CPATH environment variable.'
-        improper_environment = True
-
-    execpath = string.split(os.environ.get('PATH'),':')
-    bindir = os.path.join(prefixpath,'bin')
-    if bindir not in execpath:
-        print 'You must add '+bindir+' to the PATH environment variable.'
-        improper_environment = True
-
-    if improper_environment:
-        print &quot;&quot;&quot;\n
-Please edit your startup file (.cshrc or .profile)
-and define your environment variables correctly.
-Then start a new shell and rerun upackage.&quot;&quot;&quot;
-        sys.exit()
-
-check_setup()
-
-# include config.py
-execfile(os.path.join(upackagedir,'config.py'))
-
-
-
-def ask_upackdb_for_package_url(upackdburl,packagename):    
-    raise Error('Could not contact upackage database '+upackdburl)
-    raise Error('Package '+packagename+' is not known by database '+upackdburl)
-
-def get_upack_version(upack_url):
-    &quot;&quot;&quot;Attempts to open the given upack and reads its first line,
-    which should be like: upack_version = '2004.06.18'
-    If successful the obtained version string is returned.
-    Otherwise some exception is raised.
-    &quot;&quot;&quot;
-    f = urllib.urlopen(url)    
-    firstline = f.readline()    
-    tokens = string.split(firstline, &quot; =\t\&quot;\'&quot;)
-    if len(tokens!=2) or tokens[0]!='upack_version':
-        raise Error('First line of upackage '+upack_url+&quot; appears invalid. It should be ex: upack_version = '2004.03.29' instead of &quot;+firstline)
-    return tokens[1]
-
-def get_package(packagename):
-    packagepath = os.path.join(os.path.join(upackagedir,'upackages'),packagename+'.py')
-
-    oldversion = ''
-    try: oldversion = get_upack_version(packagepath)
-    except: pass
-    
-    for source in upackage_sources:
-        if string_begins_with(source, 'upackdb:'):
-            url = ''
-            try: url = ask_upackdb_for_package_url(source,packagename)
-            except: pass
-
-            if url!='': # The upackage db query returned a url where to fetch the .upack file from
-                newversion = ''
-                try: newversion = get_upack_version(url)
-                except: pass
-                
-                if newversion!='': # found a .upack file of which we were able to read the version
-                    if oldversion='' or compare_versions(newversion,oldversion)&gt;0:
-                        download(url, packagepath)
-                    break
-
-        elif string_begins_with(source, 'ftp:') or string_begins_with(source,'http:'):
-            url = source+'/'+packagename+'.upack'
-            newversion = ''
-            try: newversion = get_upack_version(url)
-            except: pass
-
-            if newversion!='': # found a .upack file of which we were able to read the version
-                if oldversion='' or compare_versions(newversion,oldversion)&gt;0:
-                    download(url, packagepath)
-                break
-
-    exec 'import upackages.'+packagename
-    exec 'package = upackages.'+packagename
-    return package
-
-def install_single_package(packagename, version, prefixdir):
-    upackages.make_usr_structure(prefixdir)
-    package = get_package(packagename)
-    srcdir = prefixdir+'/src/'+packagename+'/'+version
-    upackages.chdir(srcdir)
-    package.install(version, prefixdir)
-
-def install(packagename, version='', prefixdir=''):
-    package = get_package(packagename)
-
-    installed_versions = package.get_installed_versions()
-    installable_versions = package.get_installable_versions()
-
-    if version=='': # Let the user choose a version 
-        if installed_versions!=[]:
-            print 'VERSIONS OF',packagename,'THAT APPEAR TO BE CURRENTLY INSTALLED ON YOUR SYSTEM:'
-            print '  '+string.join(installed_versions,'\n  ')
-        print 'VERSIONS OF',packagename,'THAT ARE INSTALLABLE AS UPACKAGES:'
-        print '  '+string.join(installable_versions,'\n  ')
-        version = string.strip(raw_input('VERSION TO INSTALL (leave blank to exit)? '))
-        print '\n\n'
-        if version=='':
-            sys.exit()
-
-    if version not in installable_versions:
-        print 'Version',version,'is not in the list of installable package versions.'
-        sys.exit()
-    # if version in installed_versions:
-    #    print packagename, version, 'appears to be already installed.'
-    #    sys.exit()
-
-    if prefixdir=='': # Let the user choose a prefix
-        prefixes = get_environment_prefixpath()
-        print &quot;&quot;&quot;\n
-        CHOOSE THE PREFIX WHERE TO BUILD AND INSTALL THE PACKAGE
-        (make sure you have write permission for that directory, switch user and rerun if needed)
-        The following prefixes are listed in UPACKAGE_PREFIX_PATH:&quot;&quot;&quot;
-        for i in range(len(prefixes)):
-            print i+1,':',prefixes[i]
-        i = input('Which one to use? ')
-        print '\n\n'
-        prefixdir=prefixes[i-1]
-
-    dependencies = package.get_dependencies(version)
-    for (depname, minimum_version) in dependencies:
-        deppack = get_package(depname)
-        installed_versions = deppack.get_installed_versions()
-        found_ver = ''
-        for ver in installed_versions:
-            if upackages.version_equal_or_greater(ver, minimum_version):
-                found_ver = ver
-                break
-        if found_ver!='':
-            print 'Found dependency ', depname, found_ver, 'OK.'
-        else:
-            print 'MISSING DEPENDENCY: ', packagename, 'requires', depname, 'version &gt;=',minimum_version
-            print '  Versions of '+depname+' installable with upackage are:'
-            print '    '+string.join(deppack.get_installable_versions(),'    \n')
-            print '  Please enter the version you wish upackage to install '
-            print '  (alternatively press return when you are finished installing it with your O.S. packaging system).'
-            iver = string.strip(raw_input('  Version of '+depname+' to install? '))
-            print '\n\n'
-            if iver!='':
-                install(depname, iver, prefixdir)
-
-    install_single_package(packagename, version, prefixdir)
-    print 'FINISHED INSTALLING', packagename, version
-
-
-def environment_help_and_exit():
-    print &quot;&quot;&quot;
-    Please edit your shell startup file
-    (.cshrc or .profile or equivalent) and
-    properly define your environment variables there.
-    
-    The following environment variables must be
-    defined for upackage to work properly:
-
-    UPACKAGE_PREFIX_PATH should contain a colon-separated list of
-    base prefix directories in which you can install extra packages
-    for yourself or the group of people you work with.
-    c-shell ex: setenv UPACKAGE_PREFIX_PATH $HOME/usr:$GROUPHOME/usr 
-    Where $GROUPHOME is some common place where you or somebody else 
-    in your group can install stuff so that everybody in the group can use it.
-    Note that if you work on multiple architectures/OS, you will probably
-    want to set-up architecture-dependent paths
-    for ex: setenv UPACKAGE_PREFIX_PATH $HOME/usr/$ARCH:$GROUPHOME/usr/$ARCH
-    Where $ARCH is defined to depend on the os/architecture.
-
-    PATH should contain (among other things) all the prefixes in
-    UPACKAGE_PREFIX_PATH with /bin appended to them.
-
-    LD_LIBRARY_PATH should contain a colon-separated list
-    of directories in which dynamic libraries may be searched-for.
-    (/lib and /usr/lib may be omitted from the list, but the list will
-    typically contain /usr/local/lib). In particular, it should contain
-    all the prefixes in UPACKAGE_PREFIX_PATH with /lib appended to them.
-
-    LIBRARY_PATH is used to give gcc a list of directories where to locate libraries.
-    It will typically be the same as LD_LIBRARY_PATH
-
-    CPATH is used to give gcc a list of directories where to locate includes.
-    It should contain all the prefixes in UPACKAGE_PREFIX_PATH with
-    /include appended to them.
-    &quot;&quot;&quot;
-    sys.exit()
-
-def get_environment_prefixpath():
-    &quot;&quot;&quot;Checks if relevant environment variables are consistently defined.
-    And returns the content of environment variable UPACKAGE_PREFIX_PATH
-    as a list of strings (the paths of the prefix directories).
-    The variables that are checked are: UPACKAGE_PREFIX_PATH,
-    LD_LIBRARY_PATH, LIBRARY_PATH, CPATH
-    If one of those is missing or inconsistent with UPACKAGE_PREFIX_PATH,
-    then the function calls environment_help_and_exit()
-    &quot;&quot;&quot;
-
-    upackage_prefix_path = os.environ.get('UPACKAGE_PREFIX_PATH')
-    if not upackage_prefix_path:
-        print 'Environment variable UPACKAGE_PREFIX_PATH not defined!!!\n'
-        environment_help_and_exit()
-    upackage_prefix_path = [ string.rstrip(d,'/') for d in string.split(upackage_prefix_path,':') if d!='' ]
-
-    ld_library_path = os.environ.get('LD_LIBRARY_PATH')
-    if not ld_library_path:
-        print 'Environment variable LD_LIBRARY_PATH not defined!!!\n'
-        environment_help_and_exit()
-    ld_library_path = [ string.rstrip(d,'/') for d in string.split(ld_library_path,':') if d!='' ]
-    for d in upackage_prefix_path:
-        if os.path.join(d,'lib') not in ld_library_path:
-            print os.path.join(d,'lib'), 'not in LD_LIBRARY_PATH' 
-            environment_help_and_exit()
-
-    library_path = os.environ.get('LIBRARY_PATH')
-    if not library_path:
-        print 'Environment variable LIBRARY_PATH not defined!!!\n'
-        environment_help_and_exit()
-    library_path = [ string.rstrip(d,'/') for d in string.split(library_path,':') if d!='' ]
-    for d in upackage_prefix_path:
-        if os.path.join(d,'lib') not in library_path:
-            print os.path.join(d,'lib'), 'not in LIBRARY_PATH' 
-            environment_help_and_exit()
-
-    cpath = os.environ.get('CPATH')
-    if not cpath:
-        print 'Environment variable CPATH not defined!!!\n'
-        environment_help_and_exit()
-    cpath = [ string.rstrip(d,'/') for d in string.split(cpath,':') if d!='' ]
-    for d in upackage_prefix_path:
-        if os.path.join(d,'include') not in cpath:
-            print os.path.join(d,'include'), 'not in CPATH' 
-            environment_help_and_exit()
-
-    return upackage_prefix_path
-    
-
-def help_and_exit():
-    print 'Usage:', sys.argv[0], ' force_install &lt;packagename&gt; &lt;version&gt; &lt;prefixdir&gt;'
-    print '   or:', sys.argv[0], ' install &lt;packagename&gt; [&lt;version&gt;] [&lt;prefixdir&gt;]'
-    print '   or:', sys.argv[0], ' list'
-    print '   or:', sys.argv[0], ' info &lt;packagename&gt;'    
-    print '   or:', sys.argv[0], ' dependencies &lt;packagename&gt; &lt;packageversion&gt;'    
-    sys.exit()
-
-        
-def run():
-    args = sys.argv[1:]
-
-    if len(args)==0:
-        help_and_exit()
-
-    command = args[0]
-
-    if command=='list':
-        print 'Available packages:'
-        print string.join(upackages.packages,'\n')
-
-    elif command=='force_install':
-        packagename = args[1]
-        version = args[2]
-        prefixdir = args[3]
-        install_single_package(packagename, version, prefixdir)
-
-    elif command=='install':
-        packagename = args[1]
-        version = ''
-        try: version = args[2]
-        except: pass
-        prefixdir=''
-        try: prefixdir = args[3]
-        except: pass
-        install(packagename, version, prefixdir)
-
-    elif command=='info':
-        packagename = args[1]
-        package = get_package(packagename)
-        print 'UPACKAGE',packagename
-        print package.description()
-        print 'Versions installable with upackage:', package.get_installable_versions() 
-        print 'Currently installed versions found on your system:', package.get_installed_versions()
-
-    elif command=='dependencies':
-        packagename = args[1]
-        version = args[2]
-        package = get_package(packagename)
-        dependencies = package.get_dependencies(version)
-        print 'UPACKAGE',packagename, version, ' installation depends on:'
-        for depname, depver in dependencies:
-            print '  ',depname,' version &gt;=',depver
-        
-try:
-    run()
-except KeyboardInterrupt:
-    print '\nABORTED due to KeyboardInterrupt.'


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003667.html">[Plearn-commits] r10227 - in trunk/python_modules/plearn: . table
</A></li>
	<LI>Next message: <A HREF="003669.html">[Plearn-commits] r10229 - trunk/scripts
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3668">[ date ]</a>
              <a href="thread.html#3668">[ thread ]</a>
              <a href="subject.html#3668">[ subject ]</a>
              <a href="author.html#3668">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/plearn-commits">More information about the Plearn-commits
mailing list</a><br>
</body></html>
