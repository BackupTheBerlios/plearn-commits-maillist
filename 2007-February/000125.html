<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Plearn-commits] r6676 - in trunk: commands/PLearnCommands	examples/Demo/Tasks/2d_classif/Datasets/moons.amat.metadata	plearn/base plearn/io plearn/math plearn/misc plearn/sys	plearn/vmat plearn_learners/generic plearn_learners/testers	python_modules/plearn/io python_modules/plearn/parallel	python_modules/plearn/utilities scripts
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/plearn-commits/2007-February/index.html" >
   <LINK REL="made" HREF="mailto:plearn-commits%40lists.berlios.de?Subject=Re%3A%20%5BPlearn-commits%5D%20r6676%20-%20in%20trunk%3A%20commands/PLearnCommands%0A%09examples/Demo/Tasks/2d_classif/Datasets/moons.amat.metadata%0A%09plearn/base%20plearn/io%20plearn/math%20plearn/misc%20plearn/sys%0A%09plearn/vmat%20plearn_learners/generic%20plearn_learners/testers%0A%09python_modules/plearn/io%20python_modules/plearn/parallel%0A%09python_modules/plearn/utilities%20scripts&In-Reply-To=%3C200702222105.l1ML5uGJ020153%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000124.html">
   <LINK REL="Next"  HREF="000126.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Plearn-commits] r6676 - in trunk: commands/PLearnCommands	examples/Demo/Tasks/2d_classif/Datasets/moons.amat.metadata	plearn/base plearn/io plearn/math plearn/misc plearn/sys	plearn/vmat plearn_learners/generic plearn_learners/testers	python_modules/plearn/io python_modules/plearn/parallel	python_modules/plearn/utilities scripts</H1>
    <B>saintmlx at BerliOS</B> 
    <A HREF="mailto:plearn-commits%40lists.berlios.de?Subject=Re%3A%20%5BPlearn-commits%5D%20r6676%20-%20in%20trunk%3A%20commands/PLearnCommands%0A%09examples/Demo/Tasks/2d_classif/Datasets/moons.amat.metadata%0A%09plearn/base%20plearn/io%20plearn/math%20plearn/misc%20plearn/sys%0A%09plearn/vmat%20plearn_learners/generic%20plearn_learners/testers%0A%09python_modules/plearn/io%20python_modules/plearn/parallel%0A%09python_modules/plearn/utilities%20scripts&In-Reply-To=%3C200702222105.l1ML5uGJ020153%40sheep.berlios.de%3E"
       TITLE="[Plearn-commits] r6676 - in trunk: commands/PLearnCommands	examples/Demo/Tasks/2d_classif/Datasets/moons.amat.metadata	plearn/base plearn/io plearn/math plearn/misc plearn/sys	plearn/vmat plearn_learners/generic plearn_learners/testers	python_modules/plearn/io python_modules/plearn/parallel	python_modules/plearn/utilities scripts">saintmlx at mail.berlios.de
       </A><BR>
    <I>Thu Feb 22 22:05:56 CET 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000124.html">[Plearn-commits] r6675 - in trunk: plearn/var	plearn_learners/regressors
</A></li>
        <LI>Next message: <A HREF="000126.html">[Plearn-commits] r6677 - trunk/plearn/misc
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#125">[ date ]</a>
              <a href="thread.html#125">[ thread ]</a>
              <a href="subject.html#125">[ subject ]</a>
              <a href="author.html#125">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: saintmlx
Date: 2007-02-22 22:05:50 +0100 (Thu, 22 Feb 2007)
New Revision: 6676

Added:
   trunk/commands/PLearnCommands/TestClientCommand.cc
   trunk/commands/PLearnCommands/TestClientCommand.h
   trunk/plearn/io/ServerLogStreamBuf.cc
   trunk/plearn/io/ServerLogStreamBuf.h
   trunk/scripts/xdispatch
Modified:
   trunk/commands/PLearnCommands/ServerCommand.cc
   trunk/commands/PLearnCommands/plearn_main.cc
   trunk/examples/Demo/Tasks/2d_classif/Datasets/moons.amat.metadata/stats.psave
   trunk/plearn/base/ProgressBar.cc
   trunk/plearn/base/ProgressBar.h
   trunk/plearn/io/PStream.cc
   trunk/plearn/io/PStreamBuf.cc
   trunk/plearn/io/PStreamBuf.h
   trunk/plearn/io/Poll.cc
   trunk/plearn/io/Poll.h
   trunk/plearn/io/PrPStreamBuf.cc
   trunk/plearn/io/openSocket.cc
   trunk/plearn/io/pl_log.cc
   trunk/plearn/io/pl_log.h
   trunk/plearn/math/TMat_maths_impl.h
   trunk/plearn/misc/PLearnServer.cc
   trunk/plearn/misc/PLearnServer.h
   trunk/plearn/misc/PLearnService.cc
   trunk/plearn/misc/PLearnService.h
   trunk/plearn/misc/RemotePLearnServer.cc
   trunk/plearn/misc/RemotePLearnServer.h
   trunk/plearn/sys/Popen.cc
   trunk/plearn/sys/Popen.h
   trunk/plearn/vmat/VMatrix.cc
   trunk/plearn_learners/generic/NNet.cc
   trunk/plearn_learners/testers/PTester.cc
   trunk/plearn_learners/testers/PTester.h
   trunk/python_modules/plearn/io/server.py
   trunk/python_modules/plearn/parallel/dbi.py
   trunk/python_modules/plearn/parallel/dispatch.py
   trunk/python_modules/plearn/parallel/utils.py
   trunk/python_modules/plearn/utilities/progress.py
Log:
- added progress and log messages for remote servers
- PTester can perform splits in parallel on several servers



Modified: trunk/commands/PLearnCommands/ServerCommand.cc
===================================================================
--- trunk/commands/PLearnCommands/ServerCommand.cc	2007-02-21 15:49:27 UTC (rev 6675)
+++ trunk/commands/PLearnCommands/ServerCommand.cc	2007-02-22 21:05:50 UTC (rev 6676)
@@ -113,11 +113,22 @@
             myhostname = buf;
 #endif
 
+        PRNetAddr assigned_addr;
+        PR_InitializeNetAddr(PR_IpAddrAny, PR_htons(0), &amp;assigned_addr);
+        st= PR_GetSockName(sock, &amp;assigned_addr);
+        if(port==0 &amp;&amp; st==PR_SUCCESS)
+            port= PR_ntohs(assigned_addr.inet.port);
+
         pout &lt;&lt; &quot;PLEARN_SERVER_TCP &quot; &lt;&lt; myhostname &lt;&lt; &quot; &quot; &lt;&lt; port &lt;&lt; &quot; &quot; &lt;&lt; mypid &lt;&lt; endl;
         NORMAL_LOG &lt;&lt; &quot;PLEARN_SERVER STARTING IN TCP MODE ON &quot;  &lt;&lt; myhostname &lt;&lt; &quot;, PORT &quot; &lt;&lt; port &lt;&lt; &quot;, PID &quot; &lt;&lt; mypid &lt;&lt; endl;
-      
+
         for (bool running = true; running; ) {
             NORMAL_LOG &lt;&lt; &quot;\nPLEARN_SERVER WAITING FOR CONNECTION&quot;  &lt;&lt; endl;
+            
+            ///***///***
+            pout &lt;&lt; &quot; JBL &quot; &lt;&lt; endl;
+            ///***///***
+
             st = PR_Listen(sock,0);
             if(st!=PR_SUCCESS)
                 PLERROR(&quot;serverCommand: listen on socket failed&quot;);
@@ -131,6 +142,10 @@
 
             PLearnServer server(io);
             running = server.run();
+            io.flush();
+            if (PR_Close(fd) != PR_SUCCESS)
+                PLERROR(&quot;ServerCommand: couldn't close client socket from %s!&quot;, buf);
+
         }
         NORMAL_LOG &lt;&lt; &quot;PLEARN_SERVER CLOSING SOCKET&quot; &lt;&lt; endl;
         if (PR_Shutdown(sock, PR_SHUTDOWN_BOTH) != PR_SUCCESS)

Added: trunk/commands/PLearnCommands/TestClientCommand.cc
===================================================================
--- trunk/commands/PLearnCommands/TestClientCommand.cc	2007-02-21 15:49:27 UTC (rev 6675)
+++ trunk/commands/PLearnCommands/TestClientCommand.cc	2007-02-22 21:05:50 UTC (rev 6676)
@@ -0,0 +1,193 @@
+// -*- C++ -*-
+
+// TestClientCommand.cc
+//
+// Copyright (C) 2007 Xavier Saint-Mleux, Apstat Technologies, inc.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+// 
+//  1. Redistributions of source code must retain the above copyright
+//     notice, this list of conditions and the following disclaimer.
+// 
+//  2. Redistributions in binary form must reproduce the above copyright
+//     notice, this list of conditions and the following disclaimer in the
+//     documentation and/or other materials provided with the distribution.
+// 
+//  3. The name of the authors may not be used to endorse or promote
+//     products derived from this software without specific prior written
+//     permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
+// NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+// 
+// This file is part of the PLearn library. For more information on the PLearn
+// library, go to the PLearn Web site at www.plearn.org
+
+// Authors: Xavier Saint-Mleux
+
+/*! \file TestClientCommand.cc */
+
+
+#include &quot;TestClientCommand.h&quot;
+#include &lt;plearn/misc/PLearnService.h&gt;
+#include &lt;plearn/io/pl_log.h&gt;
+#include &lt;plearn/vmat/MemoryVMatrix.h&gt;
+#include &lt;plearn/base/PDateTime.h&gt;
+#include &lt;plearn/base/ProgressBar.h&gt;
+
+namespace PLearn {
+using namespace std;
+
+//! This allows to register the 'TestClientCommand' command in the command registry
+PLearnCommandRegistry TestClientCommand::reg_(new TestClientCommand);
+
+TestClientCommand::TestClientCommand():
+    PLearnCommand(&quot;testclient&quot;,
+
+                  &quot;Launches plearn in test client mode&quot;,
+
+                  &quot;testclient\n&quot;
+                  &quot;  Launches plearn in test client mode \n&quot;
+                  &quot; \n&quot;
+        )
+{}
+
+
+//! The actual implementation of the 'TestClientCommand' command 
+void TestClientCommand::run(const vector&lt;string&gt;&amp; args)
+{
+
+    cout &lt;&lt; &quot;test client run&quot; &lt;&lt; endl;
+    
+
+    PLearnService&amp; ps(PLearnService::instance()); 
+  
+    int ns= ps.availableServers();
+    TVec&lt;PP&lt;RemotePLearnServer&gt; &gt; ss= ps.reserveServers(ns);
+
+
+    cout &lt;&lt; &quot;test client has servers&quot; &lt;&lt; endl;
+
+    TVec&lt;int&gt; objids(ns);
+
+    for(int i= 0; i &lt; ns; ++i)
+    {
+        //ss[i]-&gt;newObjectAsync(1, string(&quot;MemoryVMatrix(width= 5000, length= 7000)&quot;));
+        //ss[i]-&gt;newObjectAsync(string(&quot;MemoryVMatrix(width= 5000, length= 7000)&quot;));
+        objids[i]= ss[i]-&gt;newObject(string(&quot;MemoryVMatrix(width= 5000, length= 7000)&quot;));
+        cerr &lt;&lt; &quot;NEW OBJ &quot; &lt;&lt; i &lt;&lt; '-' &lt;&lt; objids[i] &lt;&lt; endl;
+    }
+/*
+    for(int i= 0; i &lt; ns; ++i)
+    {
+        int j= ps.watchServers(ss, PLearnService::log_callback, PLearnService::progress_callback);
+        cout &lt;&lt; &quot;result 1 from &quot; &lt;&lt; j &lt;&lt; &quot; at &quot; &lt;&lt; PDateTime::currentLocalTime() &lt;&lt; endl;
+        ss[j]-&gt;getResults(objids[j]);
+    }
+*/
+    for(int i= 0; i &lt; ns; ++i)
+        ss[i]-&gt;callMethod(objids[i], &quot;fill&quot;, 3.21*static_cast&lt;real&gt;(i+1));
+
+    for(int i= 0; i &lt; ns; ++i)
+    {
+/*
+        int j= ps.watchServers(ss, PLearnService::log_callback, PLearnService::progress_callback);
+        cout &lt;&lt; &quot;result 2 from &quot; &lt;&lt; j &lt;&lt; &quot; at &quot; &lt;&lt; PDateTime::currentLocalTime() &lt;&lt; endl;
+        ss[j]-&gt;getResults();
+*/
+        ps.waitForResult()-&gt;getResults();
+    }
+
+    cout &lt;&lt; &quot;before getRow&quot; &lt;&lt; endl;
+
+    for(int i= 0; i &lt; ns; ++i)
+        ss[i]-&gt;callMethod(objids[i], &quot;getRow&quot;, 3);
+
+    cout &lt;&lt; &quot;after getRow&quot; &lt;&lt; endl;
+
+    for(int i= 0; i &lt; ns; ++i)
+    {
+        cout &lt;&lt; &quot;bws &quot; &lt;&lt; i &lt;&lt; endl;
+
+        int j= ps.watchServers(ss, PLearnService::log_callback, PLearnService::progress_callback);
+        cout &lt;&lt; &quot;result 3 from &quot; &lt;&lt; j &lt;&lt; &quot; at &quot; &lt;&lt; PDateTime::currentLocalTime() &lt;&lt; endl;
+        Vec vv;
+
+        cout &lt;&lt; &quot;getting it&quot; &lt;&lt; endl;
+
+        ss[j]-&gt;getResults(vv);
+
+        cout &lt;&lt; &quot;got it&quot; &lt;&lt; endl;
+
+        pout &lt;&lt; '\t' &lt;&lt; vv[0] &lt;&lt; endl;
+    }
+
+    cout &lt;&lt; &quot;before call dot&quot; &lt;&lt; endl;
+
+    for(int i= 0; i &lt; ns; ++i)
+        ss[i]-&gt;callMethod(objids[i], &quot;dot&quot;, 1, 3, 4500);
+
+    cout &lt;&lt; &quot;after call dot&quot; &lt;&lt; endl;
+
+    for(int i= 0; i &lt; ns; ++i)
+    {
+        int j= ps.watchServers(ss, PLearnService::log_callback, PLearnService::progress_callback);
+        cout &lt;&lt; &quot;result 4 from &quot; &lt;&lt; j &lt;&lt; &quot; at &quot; &lt;&lt; PDateTime::currentLocalTime() &lt;&lt; endl;
+        real x;
+        ss[j]-&gt;getResults(x);
+        cout &lt;&lt; endl &lt;&lt; '=' &lt;&lt; x &lt;&lt; endl;
+    }
+
+    cout &lt;&lt; &quot;before call save&quot; &lt;&lt; endl;
+
+    for(int i= 0; i &lt; ns; ++i)
+        ss[i]-&gt;callMethod(objids[i], &quot;savePMAT&quot;, string(&quot;/home/saintmlx/testclient/mat&quot;)+tostring(i)+string(&quot;.pmat&quot;));
+
+    cout &lt;&lt; &quot;after call save&quot; &lt;&lt; endl;
+
+    for(int i= 0; i &lt; ns; ++i)
+    {
+        int j= ps.watchServers(ss, PLearnService::log_callback, PLearnService::progress_callback);
+        cout &lt;&lt; &quot;result 5 from &quot; &lt;&lt; j &lt;&lt; &quot; at &quot; &lt;&lt; PDateTime::currentLocalTime() &lt;&lt; endl;
+        ss[j]-&gt;getResults();
+    }
+
+    cout &lt;&lt; &quot;before delete&quot; &lt;&lt; endl;
+
+    for(int i= 0; i &lt; ns; ++i)
+        ss[i]-&gt;deleteObjectAsync(objids[i]);
+
+    cout &lt;&lt; &quot;after delete&quot; &lt;&lt; endl;
+
+    for(int i= 0; i &lt; ns; ++i)
+    {
+        int j= ps.watchServers(ss, PLearnService::log_callback, PLearnService::progress_callback);
+        cout &lt;&lt; &quot;result 6 from &quot; &lt;&lt; j &lt;&lt; &quot; at &quot; &lt;&lt; PDateTime::currentLocalTime() &lt;&lt; endl;
+        ss[j]-&gt;getResults();
+    }
+
+}
+
+} // end of namespace PLearn
+
+
+/*
+  Local Variables:
+  mode:c++
+  c-basic-offset:4
+  c-file-style:&quot;stroustrup&quot;
+  c-file-offsets:((innamespace . 0)(inline-open . 0))
+  indent-tabs-mode:nil
+  fill-column:79
+  End:
+*/
+// vim: filetype=cpp:expandtab:shiftwidth=4:tabstop=8:softtabstop=4:encoding=utf-8:textwidth=79 :

Added: trunk/commands/PLearnCommands/TestClientCommand.h
===================================================================
--- trunk/commands/PLearnCommands/TestClientCommand.h	2007-02-21 15:49:27 UTC (rev 6675)
+++ trunk/commands/PLearnCommands/TestClientCommand.h	2007-02-22 21:05:50 UTC (rev 6676)
@@ -0,0 +1,74 @@
+// -*- C++ -*-
+
+// TestClientCommand.h
+//
+// Copyright (C) 2007 Xavier Saint-Mleux, Apstat Technologies, inc.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+// 
+//  1. Redistributions of source code must retain the above copyright
+//     notice, this list of conditions and the following disclaimer.
+// 
+//  2. Redistributions in binary form must reproduce the above copyright
+//     notice, this list of conditions and the following disclaimer in the
+//     documentation and/or other materials provided with the distribution.
+// 
+//  3. The name of the authors may not be used to endorse or promote
+//     products derived from this software without specific prior written
+//     permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
+// NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+// 
+// This file is part of the PLearn library. For more information on the PLearn
+// library, go to the PLearn Web site at www.plearn.org
+
+// Authors: Xavier Saint-Mleux
+
+/*! \file TestClientCommand.h */
+
+
+#ifndef TestClientCommand_INC
+#define TestClientCommand_INC
+
+#include &lt;commands/PLearnCommands/PLearnCommand.h&gt;
+#include &lt;commands/PLearnCommands/PLearnCommandRegistry.h&gt;
+
+namespace PLearn {
+
+class TestClientCommand: public PLearnCommand
+{
+public:
+    TestClientCommand();                    
+    virtual void run(const std::vector&lt;std::string&gt;&amp; args);
+
+protected:
+    static PLearnCommandRegistry reg_;
+};
+
+  
+} // end of namespace PLearn
+
+#endif
+
+
+/*
+  Local Variables:
+  mode:c++
+  c-basic-offset:4
+  c-file-style:&quot;stroustrup&quot;
+  c-file-offsets:((innamespace . 0)(inline-open . 0))
+  indent-tabs-mode:nil
+  fill-column:79
+  End:
+*/
+// vim: filetype=cpp:expandtab:shiftwidth=4:tabstop=8:softtabstop=4:encoding=utf-8:textwidth=79 :

Modified: trunk/commands/PLearnCommands/plearn_main.cc
===================================================================
--- trunk/commands/PLearnCommands/plearn_main.cc	2007-02-21 15:49:27 UTC (rev 6675)
+++ trunk/commands/PLearnCommands/plearn_main.cc	2007-02-22 21:05:50 UTC (rev 6676)
@@ -158,6 +158,8 @@
         verbosity_value =
             PL_Log::vlevelFromString( command_line[verbosity_value_pos] );
     }
+    // set verbosity level now so that it is valid for the rest of global_options
+    PL_Log::instance().verbosity( verbosity_value );
 
     // Option to enable logging for the specified modules, specified as
     // --enable-logging module1,module2,module3,... i.e. as a comma-separated
@@ -235,7 +237,6 @@
         }
     command_line.resize( cleaned ); // Truncating the end of the vector.
   
-    PL_Log::instance().verbosity( verbosity_value );
     if (no_version_pos == -1)
         output_version( );
 

Modified: trunk/examples/Demo/Tasks/2d_classif/Datasets/moons.amat.metadata/stats.psave
===================================================================
--- trunk/examples/Demo/Tasks/2d_classif/Datasets/moons.amat.metadata/stats.psave	2007-02-21 15:49:27 UTC (rev 6675)
+++ trunk/examples/Demo/Tasks/2d_classif/Datasets/moons.amat.metadata/stats.psave	2007-02-22 21:05:50 UTC (rev 6676)
@@ -5,8 +5,8 @@
 nnonmissing_ = 54 ;
 sumsquarew_ = 54 ;
 sum_ = 38.4679999999999964 ;
-sumsquare_ = 35.5002080000000078 ;
-sumcube_ = 35.9551203199999918 ;
+sumsquare_ = 35.5002080000000007 ;
+sumcube_ = 35.9551203199999989 ;
 sumfourth_ = 38.3519593203199989 ;
 min_ = -0.855999999999999983 ;
 max_ = 0.508000000000000007 ;

Modified: trunk/plearn/base/ProgressBar.cc
===================================================================
--- trunk/plearn/base/ProgressBar.cc	2007-02-21 15:49:27 UTC (rev 6675)
+++ trunk/plearn/base/ProgressBar.cc	2007-02-22 21:05:50 UTC (rev 6676)
@@ -3,6 +3,7 @@
 // PLearn (A C++ Machine Learning Library)
 // Copyright (C) 1998 Pascal Vincent
 // Copyright (C) 1999-2002 Pascal Vincent, Yoshua Bengio and University of Montreal
+// Copyright (C) 2007 Xavier Saint-Mleux, ApSTAT Technologies inc.
 //
 
 // Redistribution and use in source and binary forms, with or without
@@ -172,6 +173,91 @@
 }
 
 
+//*************************/
+// RemoteProgressBarPlugin
+
+RemoteProgressBarPlugin::RemoteProgressBarPlugin(ostream&amp; _out, unsigned int nticks_)
+    :TextProgressBarPlugin(_out), nticks(nticks_)
+{}
+
+RemoteProgressBarPlugin::RemoteProgressBarPlugin(PStream&amp; _out, unsigned int nticks_)
+    :TextProgressBarPlugin(_out), nticks(nticks_)
+{}
+
+void RemoteProgressBarPlugin::addProgressBar(ProgressBar* pb)
+{ printTitle(pb); }
+
+void RemoteProgressBarPlugin::update(ProgressBar* pb, unsigned long newpos)
+{
+    // this handles the case where we reuse the same progress bar
+    if(newpos &lt; pb-&gt;currentpos)
+    {
+        pb-&gt;currentpos=0;
+        printTitle(pb);
+    }
+    if(0 &lt;  (int( newpos / (double(pb-&gt;maxpos) / nticks) ) -
+             int(round( pb-&gt;currentpos / (double(pb-&gt;maxpos) / nticks) ))))
+    {
+        out.write(&quot;*PU &quot;);
+        out &lt;&lt; reinterpret_cast&lt;unsigned int&gt;(pb) &lt;&lt; newpos &lt;&lt; endl;
+        pb-&gt;currentpos = newpos;
+    }
+}
+
+void RemoteProgressBarPlugin::printTitle(ProgressBar* pb)
+{
+    string fulltitle = string(&quot; &quot;) + pb-&gt;title + &quot; (&quot; + tostring(pb-&gt;maxpos) + &quot;) &quot;;
+    out.write(&quot;*PA &quot;);
+    out &lt;&lt; reinterpret_cast&lt;unsigned int&gt;(pb) &lt;&lt; pb-&gt;maxpos &lt;&lt; fulltitle &lt;&lt; endl;
+}
+
+void RemoteProgressBarPlugin::killProgressBar(ProgressBar* pb)
+{
+    out.write(&quot;*PK &quot;);
+    out &lt;&lt; reinterpret_cast&lt;unsigned int&gt;(pb) &lt;&lt; endl;
+}
+
+//*************************/
+// LineOutputProgressBarPlugin
+
+LineOutputProgressBarPlugin::LineOutputProgressBarPlugin(ostream&amp; _out, unsigned int nticks_)
+    :TextProgressBarPlugin(_out), nticks(nticks_)
+{}
+
+LineOutputProgressBarPlugin::LineOutputProgressBarPlugin(PStream&amp; _out, unsigned int nticks_)
+    :TextProgressBarPlugin(_out), nticks(nticks_)
+{}
+
+void LineOutputProgressBarPlugin::addProgressBar(ProgressBar* pb)
+{ out &lt;&lt; &quot;In progress: &quot; &lt;&lt; pbInfo(pb) &lt;&lt; endl; }
+
+void LineOutputProgressBarPlugin::update(ProgressBar* pb, unsigned long newpos)
+{
+    // this handles the case where we reuse the same progress bar
+    if(newpos &lt; pb-&gt;currentpos)
+    {
+        pb-&gt;currentpos= newpos;
+        out &lt;&lt; &quot;In progress: &quot;;//to be continued...
+    }
+    else if(0 &lt;  (int( newpos / (double(pb-&gt;maxpos) / nticks) ) -
+             int(round( pb-&gt;currentpos / (double(pb-&gt;maxpos) / nticks) ))))
+        pb-&gt;currentpos= newpos;
+    out &lt;&lt; pbInfo(pb) &lt;&lt; endl;
+}
+
+void LineOutputProgressBarPlugin::killProgressBar(ProgressBar* pb)
+{ out &lt;&lt; pbInfo(pb) &lt;&lt; &quot; Finished&quot; &lt;&lt; endl; }
+
+string LineOutputProgressBarPlugin::pbInfo(ProgressBar* pb)
+{
+    unsigned int curpos= pb-&gt;currentpos,
+                 maxpos= pb-&gt;maxpos;
+    return string(&quot;[&quot;) + pb-&gt;title + &quot;] &quot; 
+        + tostring(curpos) + '/' + tostring(maxpos)
+        + &quot; (&quot; + tostring(static_cast&lt;double&gt;(curpos)*100.0 / static_cast&lt;double&gt;(maxpos)) + &quot;%)&quot;;
+}
+
+
 } // end of namespace PLearn
 
 

Modified: trunk/plearn/base/ProgressBar.h
===================================================================
--- trunk/plearn/base/ProgressBar.h	2007-02-21 15:49:27 UTC (rev 6675)
+++ trunk/plearn/base/ProgressBar.h	2007-02-22 21:05:50 UTC (rev 6676)
@@ -3,6 +3,7 @@
 // PLearn (A C++ Machine Learning Library)
 // Copyright (C) 1998 Pascal Vincent
 // Copyright (C) 1999-2002 Pascal Vincent, Yoshua Bengio and University of Montreal
+// Copyright (C) 2007 Xavier Saint-Mleux, ApSTAT Technologies inc.
 //
 
 // Redistribution and use in source and binary forms, with or without
@@ -77,6 +78,7 @@
 //! Simple plugin for displaying text progress bar
 class TextProgressBarPlugin : public ProgressBarPlugin
 {
+protected:
     PStream out;
 public:
     virtual void addProgressBar(ProgressBar * pb);
@@ -89,7 +91,43 @@
     static int width;
 };
 
+//! Similar to TextProgressBarPlugin with a different output format 
+//! so that remote servers can update progress bars on a client.
+class RemoteProgressBarPlugin : public TextProgressBarPlugin
+{
+public:
+    virtual void addProgressBar(ProgressBar* pb);
+    virtual void update(ProgressBar* pb, unsigned long newpos);
 
+    RemoteProgressBarPlugin(ostream&amp; _out, unsigned int nticks_= 20);
+    RemoteProgressBarPlugin(PStream&amp; _out, unsigned int nticks_= 20);
+
+    virtual void killProgressBar(ProgressBar* pb);
+
+protected:
+    void printTitle(ProgressBar* pb);
+    unsigned int nticks;
+};
+
+//! Similar to TextProgressBarPlugin with a different output format 
+//! so that updates appear on different lines of output.
+//! (for logging or when multiple progress bars are used simultaneously)
+class LineOutputProgressBarPlugin : public TextProgressBarPlugin
+{
+public:
+    virtual void addProgressBar(ProgressBar* pb);
+    virtual void update(ProgressBar* pb, unsigned long newpos);
+
+    LineOutputProgressBarPlugin(ostream&amp; _out, unsigned int nticks_= 100);
+    LineOutputProgressBarPlugin(PStream&amp; _out, unsigned int nticks_= 100);
+
+    virtual void killProgressBar(ProgressBar* pb);
+
+protected:
+    static string pbInfo(ProgressBar* pb);
+    unsigned int nticks;
+};
+
 //! Simpler plugin that doesn't display a progress bar at all.  Useful to
 //! disable progress bars for operations that are known to be short.
 //! Use it as follows:

Modified: trunk/plearn/io/PStream.cc
===================================================================
--- trunk/plearn/io/PStream.cc	2007-02-21 15:49:27 UTC (rev 6675)
+++ trunk/plearn/io/PStream.cc	2007-02-22 21:05:50 UTC (rev 6676)
@@ -40,6 +40,7 @@
 #include &lt;plearn/math/pl_math.h&gt;
 #include &lt;nspr/prio.h&gt;
 #include &lt;ctype.h&gt;
+#include &lt;plearn/io/pl_log.h&gt;
 
 
 // This is probably an ugly hack to get it to work under Visual Studio.
@@ -174,20 +175,20 @@
     :inherited(0),
      inmode(plearn_ascii), 
      outmode(plearn_ascii), 
+     format_float (format_float_default),
+     format_double(format_double_default),
      implicit_storage(true),
-     compression_mode(compr_none),
-     format_float (format_float_default),
-     format_double(format_double_default)
+     compression_mode(compr_none)
 {}
 
 PStream::PStream(streambuftype* sb)
     :inherited(sb),
      inmode(plearn_ascii), 
      outmode(plearn_ascii), 
+     format_float (format_float_default),
+     format_double(format_double_default),
      implicit_storage(true),
-     compression_mode(compr_none),
-     format_float (format_float_default),
-     format_double(format_double_default)
+     compression_mode(compr_none)
 {}
 
 
@@ -196,10 +197,10 @@
     :inherited(new StdPStreamBuf(pin_,own_pin_)),
      inmode(plearn_ascii), 
      outmode(plearn_ascii),
+     format_float (format_float_default),
+     format_double(format_double_default),
      implicit_storage(true),
-     compression_mode(compr_none),
-     format_float (format_float_default),
-     format_double(format_double_default)
+     compression_mode(compr_none)
 {}
 //! ctor. from an ostream (O)
 
@@ -207,10 +208,10 @@
     :inherited(new StdPStreamBuf(pout_,own_pout_)),
      inmode(plearn_ascii), 
      outmode(plearn_ascii),
+     format_float (format_float_default),
+     format_double(format_double_default),
      implicit_storage(true),
-     compression_mode(compr_none),
-     format_float (format_float_default),
-     format_double(format_double_default)
+     compression_mode(compr_none)
 {}
 
 //! ctor. from an iostream (IO)
@@ -218,10 +219,10 @@
     :inherited(new StdPStreamBuf(pios_,own_pios_)),
      inmode(plearn_ascii), 
      outmode(plearn_ascii),
+     format_float (format_float_default),
+     format_double(format_double_default),
      implicit_storage(true),
-     compression_mode(compr_none),
-     format_float (format_float_default),
-     format_double(format_double_default)
+     compression_mode(compr_none)
 {}
 
 //! ctor. from an istream and an ostream (IO)
@@ -229,10 +230,10 @@
     :inherited(new StdPStreamBuf(pin_,pout_,own_pin_,own_pout_)),
      inmode(plearn_ascii), 
      outmode(plearn_ascii),
+     format_float (format_float_default),
+     format_double(format_double_default),
      implicit_storage(true),
-     compression_mode(compr_none),
-     format_float (format_float_default),
-     format_double(format_double_default)
+     compression_mode(compr_none)
 {}
 
 //! dtor.
@@ -1991,7 +1992,7 @@
 
 //! The binread_ for float and double are special
 
-    void binread_(PStream&amp; in, double* x, unsigned int n, unsigned char typecode)
+void binread_(PStream&amp; in, double* x, unsigned int n, unsigned char typecode)
 { 
     if(typecode==TypeTraits&lt;double&gt;::little_endian_typecode())
     {

Modified: trunk/plearn/io/PStreamBuf.cc
===================================================================
--- trunk/plearn/io/PStreamBuf.cc	2007-02-21 15:49:27 UTC (rev 6675)
+++ trunk/plearn/io/PStreamBuf.cc	2007-02-22 21:05:50 UTC (rev 6676)
@@ -38,6 +38,7 @@
 
 /*! \file PStreamBuf.cc */
 #include &quot;PStreamBuf.h&quot;
+#include &lt;plearn/io/pl_log.h&gt;
 
 #define PSTREAMBUF_NO_GET (-1000)
 
@@ -125,6 +126,7 @@
 #endif
 
     inbuf_p = inbuf + ungetsize;
+    inbuf_end= inbuf_p; //buf empty until read_ finished
     streamsize n = read_(inbuf_p, inbuf_chunksize);
     inbuf_end = inbuf_p + n;
     return n;
@@ -152,25 +154,40 @@
     if(nleft) // need some more ?
     {
         if(nleft&gt;=inbuf_chunksize) // large block: read it directly
-            nleft -= read_(p,nleft);
+        {
+            streamsize nr= read_(p,nleft);
+            nleft-= nr;
+            p+= nr;
+            while(nleft &gt; 0 &amp;&amp; nr &gt; 0) // need some more and not eof?
+            {
+                nr= read_(p,nleft);
+                nleft-= nr;
+                p+= nr;
+            }
+        }
         else // small block: read it in the buffer first
         {
             inbuf_n = refill_in_buf();
-            if(inbuf_n)
+            while(nleft &gt; 0 &amp;&amp; inbuf_n &gt; 0) // need some more and not eof?
             {
                 streamsize k = nleft&lt;inbuf_n ?nleft :inbuf_n;
                 memcpy(p,inbuf_p,k);
                 inbuf_p += k;
                 nleft -= k;
+                p+= k;
+                if(nleft &gt; 0)
+                    inbuf_n = refill_in_buf();
             }
         }
     }
-  
+
     streamsize nread = n-nleft;
+
     if (nread &gt; 0)
-        last_get = (unsigned char) p[nread - 1];
+        last_get = (unsigned char) p[-1];//p has advanced and now points one after the end
     else
         last_get = EOF;
+
     return nread;
 }
 

Modified: trunk/plearn/io/PStreamBuf.h
===================================================================
--- trunk/plearn/io/PStreamBuf.h	2007-02-21 15:49:27 UTC (rev 6675)
+++ trunk/plearn/io/PStreamBuf.h	2007-02-22 21:05:50 UTC (rev 6676)
@@ -126,6 +126,9 @@
 
 public:
 
+    bool inbufEmpty() const
+    { return !(inbuf_p&lt;inbuf_end); }
+
     bool isReadable() const
     { return is_readable; }
 
@@ -159,6 +162,8 @@
             return -1;
     }
   
+    
+    //! Reads n chars, unless eof is reached or an error occurs; blocks if needed
     streamsize read(char* p, streamsize n);
 
     //! Puts the given characters back in the input buffer

Modified: trunk/plearn/io/Poll.cc
===================================================================
--- trunk/plearn/io/Poll.cc	2007-02-21 15:49:27 UTC (rev 6675)
+++ trunk/plearn/io/Poll.cc	2007-02-22 21:05:50 UTC (rev 6676)
@@ -3,6 +3,7 @@
 // Poll.cc
 //
 // Copyright (C) 2005 Christian Hudon 
+// Copyright (C) 2007 Xavier Saint-Mleux, ApSTAT Technologies inc.
 // 
 // Redistribution and use in source and binary forms, with or without
 // modification, are permitted provided that the following conditions are met:
@@ -43,7 +44,9 @@
 
 #include &quot;Poll.h&quot;
 #include &lt;plearn/base/plerror.h&gt;
+#include &lt;plearn/base/PrUtils.h&gt;
 #include &lt;plearn/io/PrPStreamBuf.h&gt;
+#include &lt;plearn/math/random.h&gt;
 
 namespace PLearn {
 using namespace std;
@@ -54,33 +57,69 @@
 
     int i = 0;
     for (vector&lt;PStream&gt;::const_iterator it = streams.begin();
-         it != streams.end(); ++it, ++i) {
+         it != streams.end(); ++it, ++i) 
+    {
         PStreamBuf* st = *it;
         PrPStreamBuf* pr_st = dynamic_cast&lt;PrPStreamBuf*&gt;(st);
         if (!pr_st)
             PLERROR(&quot;Poll::setStreamsToWatch: only PrPStreamBuf streams supported!&quot;);
 
         m_streams_to_watch.push_back(*it);
-        m_poll_descriptors[i].fd = pr_st-&gt;out;
+        m_poll_descriptors[i].fd = pr_st-&gt;in;
         m_poll_descriptors[i].in_flags = PR_POLL_READ;
     }
+
 }
 
-int Poll::waitForEvents(int timeout) {
+int Poll::waitForEvents(int timeout, bool shuffle_events_) 
+{
     if (m_poll_descriptors.size() == 0)
         PLERROR(&quot;Poll::waitforEvents: called with no streams to watch.&quot;);
-    
+
+    shuffle_events= shuffle_events_;
+    if(shuffle_events)//shuffle index vec if necessary
+    {
+        shuffled_index= TVec&lt;int&gt;(0, m_poll_descriptors.size()-1, 1);
+        shuffleElements(shuffled_index);
+    }
+
     m_next_unexamined_event = 0;
-    return PR_Poll(&amp;m_poll_descriptors[0], PRIntn(m_poll_descriptors.size()),
-                   timeout);
+
+    //first, check for non-empty buffers (ready to read)
+    int nevents= 0;
+    for(unsigned int i= 0; i &lt; m_poll_descriptors.size(); ++i)
+        if(!m_streams_to_watch[i]-&gt;inbufEmpty())
+            ++nevents;
+
+    if(nevents &gt; 0)//if we already have some events, poll w/ no wait
+        timeout= PR_INTERVAL_NO_WAIT;
+
+    //poll underlying streams
+    last_n_poll_events= PR_Poll(&amp;m_poll_descriptors[0], PRIntn(m_poll_descriptors.size()), timeout);
+
+    if(last_n_poll_events &lt; 0)
+        PLERROR((string(&quot;Poll::waitForEvents: poll error: &quot;) + getPrErrorString()).c_str());
+
+    nevents= 0;// now count _all_ events (non-empty buffers + stream polling)
+    for(unsigned int i= 0; i &lt; m_poll_descriptors.size(); ++i)
+        if ((last_n_poll_events &gt; 0 
+             &amp;&amp; m_poll_descriptors[i].out_flags &amp; PR_POLL_READ)
+            || !m_streams_to_watch[i]-&gt;inbufEmpty())
+            ++nevents;
+
+    return nevents;
 }
 
 PStream Poll::getNextPendingEvent() {
-    while (m_next_unexamined_event &lt; m_poll_descriptors.size()) {
-        const int i = m_next_unexamined_event++;
-        if (m_poll_descriptors[i].out_flags &amp; PR_POLL_READ) {
+    while (m_next_unexamined_event &lt; m_poll_descriptors.size()) 
+    {
+        int i = m_next_unexamined_event++;
+        if(shuffle_events)
+            i= shuffled_index[i];
+        if ((last_n_poll_events &gt; 0 
+             &amp;&amp; m_poll_descriptors[i].out_flags &amp; PR_POLL_READ)
+            || !m_streams_to_watch[i]-&gt;inbufEmpty())
             return m_streams_to_watch[i];
-        }
     }
 
     PLERROR(&quot;Poll::getNextPendingEvent: called with no more pending events!&quot;);

Modified: trunk/plearn/io/Poll.h
===================================================================
--- trunk/plearn/io/Poll.h	2007-02-21 15:49:27 UTC (rev 6675)
+++ trunk/plearn/io/Poll.h	2007-02-22 21:05:50 UTC (rev 6676)
@@ -3,6 +3,7 @@
 // Poll.h
 //
 // Copyright (C) 2005 Christian Hudon 
+// Copyright (C) 2007 Xavier Saint-Mleux, ApSTAT Technologies inc.
 // 
 // Redistribution and use in source and binary forms, with or without
 // modification, are permitted provided that the following conditions are met:
@@ -47,8 +48,8 @@
 #include &lt;vector&gt;
 #include &lt;nspr/prio.h&gt;
 #include &lt;plearn/io/PStream.h&gt;
+#include &lt;plearn/math/TVec.h&gt;
 
-
 namespace PLearn {
 using namespace std;
 
@@ -61,7 +62,7 @@
 public:
     void setStreamsToWatch(const vector&lt;PStream&gt;&amp; streams);
 
-    int waitForEvents(int timeout = 0);
+    int waitForEvents(int timeout = 0, bool shuffle_events_= false);
 
     PStream getNextPendingEvent();
 
@@ -76,6 +77,10 @@
     /** Counter used to iterate through the m_poll_descriptors
         in getNextPendingEvent */
     unsigned int m_next_unexamined_event;
+
+    int last_n_poll_events; //nb. events for the last PR_Poll; indicates wether out_flags s/b used.
+    bool shuffle_events;
+    TVec&lt;int&gt; shuffled_index;
 };
 
 } // end of namespace PLearn

Modified: trunk/plearn/io/PrPStreamBuf.cc
===================================================================
--- trunk/plearn/io/PrPStreamBuf.cc	2007-02-21 15:49:27 UTC (rev 6675)
+++ trunk/plearn/io/PrPStreamBuf.cc	2007-02-22 21:05:50 UTC (rev 6676)
@@ -42,8 +42,10 @@
 
 
 #include &quot;PrPStreamBuf.h&quot;
+#include &lt;plearn/base/PrUtils.h&gt;
 #include &lt;nspr/prio.h&gt;
 #include &lt;stdio.h&gt;
+#include &quot;PStream.h&quot;
 
 namespace PLearn {
 using namespace std;
@@ -82,7 +84,10 @@
 
 PrPStreamBuf::streamsize PrPStreamBuf::read_(char* p, streamsize n)
 {
-    return PR_Read(in, p, PRInt32(n));
+    PRInt32 nr= PR_Read(in, p, PRInt32(n));
+    if(nr &lt; 0)
+        PLERROR((string(&quot;in PrPStreamBuf::read_ : no chars read: &quot;) + getPrErrorString()).c_str());
+    return nr;
 }
 
 //! writes exactly n characters from p (unbuffered, must flush)

Added: trunk/plearn/io/ServerLogStreamBuf.cc
===================================================================
--- trunk/plearn/io/ServerLogStreamBuf.cc	2007-02-21 15:49:27 UTC (rev 6675)
+++ trunk/plearn/io/ServerLogStreamBuf.cc	2007-02-22 21:05:50 UTC (rev 6676)
@@ -0,0 +1,83 @@
+// -*- C++ -*-
+
+// ServerLogStreamBuf.cc
+//
+// Copyright (C) 2007 Xavier Saint-Mleux, Apstat Technologies, inc.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+// 
+//  1. Redistributions of source code must retain the above copyright
+//     notice, this list of conditions and the following disclaimer.
+// 
+//  2. Redistributions in binary form must reproduce the above copyright
+//     notice, this list of conditions and the following disclaimer in the
+//     documentation and/or other materials provided with the distribution.
+// 
+//  3. The name of the authors may not be used to endorse or promote
+//     products derived from this software without specific prior written
+//     permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
+// NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+// 
+// This file is part of the PLearn library. For more information on the PLearn
+// library, go to the PLearn Web site at www.plearn.org
+
+// Authors: Xavier Saint-Mleux
+
+/*! \file ServerLogStreamBuf.cc */
+
+
+#include &quot;ServerLogStreamBuf.h&quot;
+
+namespace PLearn {
+using namespace std;
+
+ServerLogStreamBuf::ServerLogStreamBuf(PStream log_, const string&amp; module_name_, int verbosity_)
+    : PStreamBuf(false, true, 4096, 4096), 
+      log(log_), module_name(module_name_), verbosity(verbosity_)
+{}
+
+ServerLogStreamBuf::~ServerLogStreamBuf()
+{
+    flush();
+}
+
+ServerLogStreamBuf::streamsize ServerLogStreamBuf::read_(char* p, streamsize n)
+{
+    PLERROR(&quot;ServerLogStreamBuf::read_ should never be used!&quot;);
+    return 0; // never reached 
+}
+
+//! writes exactly n characters from p (unbuffered, must flush)
+void ServerLogStreamBuf::write_(const char* p, streamsize n)
+{
+    log.write(&quot;*L &quot;); 
+    string msg(p, n);
+    log &lt;&lt; module_name &lt;&lt; verbosity &lt;&lt; msg;
+    log.flush();
+}
+  
+} // end of namespace PLearn
+
+
+/*
+  Local Variables:
+  mode:c++
+  c-basic-offset:4
+  c-file-style:&quot;stroustrup&quot;
+  c-file-offsets:((innamespace . 0)(inline-open . 0))
+  indent-tabs-mode:nil
+  fill-column:79
+  End:
+*/
+// vim: filetype=cpp:expandtab:shiftwidth=4:tabstop=8:softtabstop=4:encoding=utf-8:textwidth=79 :

Added: trunk/plearn/io/ServerLogStreamBuf.h
===================================================================
--- trunk/plearn/io/ServerLogStreamBuf.h	2007-02-21 15:49:27 UTC (rev 6675)
+++ trunk/plearn/io/ServerLogStreamBuf.h	2007-02-22 21:05:50 UTC (rev 6676)
@@ -0,0 +1,94 @@
+// -*- C++ -*-
+
+// ServerLogStreamBuf.h
+//
+// Copyright (C) 2007 Xavier Saint-Mleux, Apstat Technologies, inc.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+// 
+//  1. Redistributions of source code must retain the above copyright
+//     notice, this list of conditions and the following disclaimer.
+// 
+//  2. Redistributions in binary form must reproduce the above copyright
+//     notice, this list of conditions and the following disclaimer in the
+//     documentation and/or other materials provided with the distribution.
+// 
+//  3. The name of the authors may not be used to endorse or promote
+//     products derived from this software without specific prior written
+//     permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
+// NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+// 
+// This file is part of the PLearn library. For more information on the PLearn
+// library, go to the PLearn Web site at www.plearn.org
+
+// Authors: Xavier Saint-Mleux
+
+/*! \file ServerLogStreamBuf.h */
+
+
+#ifndef ServerLogStreamBuf_INC
+#define ServerLogStreamBuf_INC
+
+#include &quot;PStreamBuf.h&quot;
+#include &quot;PStream.h&quot;
+
+
+namespace PLearn {
+
+class ServerLogStreamBuf: public PStreamBuf
+{
+  
+private:
+  
+    typedef PStreamBuf inherited;
+
+    PStream log;
+    string module_name;
+    int verbosity;
+
+protected:
+    // *********************
+    // * protected options *
+    // *********************
+
+public:
+
+    ServerLogStreamBuf(PStream log_, const string&amp; module_name_= &quot;&quot;, int verbosity_= 0);
+    virtual ~ServerLogStreamBuf();
+
+protected:
+
+    virtual streamsize read_(char* p, streamsize n); // SHOULD NOT BE USED!!!
+
+    //! writes exactly n characters from p (unbuffered, must flush)
+    virtual void write_(const char* p, streamsize n);
+
+};
+
+} // end of namespace PLearn
+
+#endif
+
+
+/*
+  Local Variables:
+  mode:c++
+  c-basic-offset:4
+  c-file-style:&quot;stroustrup&quot;
+  c-file-offsets:((innamespace . 0)(inline-open . 0))
+  indent-tabs-mode:nil
+  fill-column:79
+  End:
+*/
+// vim: filetype=cpp:expandtab:shiftwidth=4:tabstop=8:softtabstop=4:encoding=utf-8:textwidth=79 :

Modified: trunk/plearn/io/openSocket.cc
===================================================================
--- trunk/plearn/io/openSocket.cc	2007-02-21 15:49:27 UTC (rev 6675)
+++ trunk/plearn/io/openSocket.cc	2007-02-22 21:05:50 UTC (rev 6676)
@@ -77,6 +77,7 @@
     st.setMode(io_formatting);
   
     PRFileDesc* socket = PR_NewTCPSocket();
+
     if (!socket)
         PLERROR(&quot;openSocket: socket creation failed! (Maybe you ran out of file descriptors?)&quot;);
 
@@ -96,9 +97,10 @@
         if (PR_Connect(socket, &amp;address, PR_SecondsToInterval(timeout))
                                                                 == PR_SUCCESS)
         {
-            st = new PrPStreamBuf(socket, socket, true, true);
-            return st;
-        } else {
+            return new PrPStreamBuf(socket, socket, true, true);
+        } 
+        else 
+        {
 #ifdef BOUNDCHECK
             string ip_adr = &quot;Unknown IP address&quot;;
             if (PR_NetAddrToString(&amp;address, buf, sizeof(buf)) == PR_SUCCESS)

Modified: trunk/plearn/io/pl_log.cc
===================================================================
--- trunk/plearn/io/pl_log.cc	2007-02-21 15:49:27 UTC (rev 6675)
+++ trunk/plearn/io/pl_log.cc	2007-02-22 21:05:50 UTC (rev 6676)
@@ -69,7 +69,23 @@
     return m_pstream;
 }
 
+//#####  Server Plugin Implementation  #######################################
 
+PStream&amp; PL_LogPluginServer::getStream(
+    PStream::mode_t outmode, const string&amp; module_name, int requested_verbosity)
+{
+    //gets everything as raw ascii, outputs it in desired format.
+    //m_pstream.setOutMode(outmode);
+    m_sstream= new ServerLogStreamBuf(m_pstream, module_name, requested_verbosity);
+    m_sstream.setOutMode(outmode);
+    //m_sstream.setOutMode(PStream::raw_ascii);
+    return m_sstream;
+}
+
+
+
+
+
 //#####  LogInterceptorPStreamBuf  ############################################
 
 /**

Modified: trunk/plearn/io/pl_log.h
===================================================================
--- trunk/plearn/io/pl_log.h	2007-02-21 15:49:27 UTC (rev 6675)
+++ trunk/plearn/io/pl_log.h	2007-02-22 21:05:50 UTC (rev 6676)
@@ -55,6 +55,7 @@
 
 // From Plearn
 #include &quot;PStream.h&quot;
+#include &quot;ServerLogStreamBuf.h&quot;
 
 namespace PLearn {
 
@@ -118,6 +119,25 @@
 };
 
 
+/**
+ *  Server implementation of PL_LogPlugin :: outputs to client through opened socket
+ */
+class PL_LogPluginServer : public PL_LogPlugin
+{
+public:
+    PL_LogPluginServer(PStream pstream)
+        : m_pstream(pstream)
+    { }
+    
+    virtual PStream&amp; getStream(PStream::mode_t outmode, const string&amp; module_name,
+                               int requested_verbosity);
+
+protected:
+    PStream m_pstream;                      
+    PStream m_sstream;                      
+};
+
+
 class LogInterceptorPStreamBuf;              //!&lt; Forward declare
 
 /**

Modified: trunk/plearn/math/TMat_maths_impl.h
===================================================================
--- trunk/plearn/math/TMat_maths_impl.h	2007-02-21 15:49:27 UTC (rev 6675)
+++ trunk/plearn/math/TMat_maths_impl.h	2007-02-22 21:05:50 UTC (rev 6676)
@@ -453,13 +453,13 @@
 template&lt;class T&gt;
 T product(const TVec&lt;T&gt;&amp; vec)
 {
-    double res = 1.0;
+    T res(static_cast&lt;T&gt;(1.0));
     if (vec.size() == 0)
         return res;
     T* v = vec.data();
     for(int i=0; i&lt;vec.length(); i++)
         res *= v[i];
-    return T(res);
+    return res;
 }
 
 /*

Modified: trunk/plearn/misc/PLearnServer.cc
===================================================================
--- trunk/plearn/misc/PLearnServer.cc	2007-02-21 15:49:27 UTC (rev 6675)
+++ trunk/plearn/misc/PLearnServer.cc	2007-02-22 21:05:50 UTC (rev 6676)
@@ -3,6 +3,7 @@
 // PLearnServer.cc
 //
 // Copyright (C) 2005 Pascal Vincent 
+// Copyright (C) 2007 Xavier Saint-Mleux, ApSTAT Technologies inc.
 // 
 // Redistribution and use in source and binary forms, with or without
 // modification, are permitted provided that the following conditions are met:
@@ -180,7 +181,7 @@
              &quot;\n&quot;
              &quot;Summary of currently supported functions:\n&quot;
              &quot;  !F cd 1 \&quot;path\&quot; \n\n&quot;
-             &quot;Advanced technical note: objects with objid&gt;=10000 are also inserted in the stream's copies_map\n&quot;
+             &quot;OBSOLETE: Advanced technical note: objects with objid&gt;=10000 are also inserted in the stream's copies_map\n&quot;
              &quot;so that they may be referenced as arguments to method or funtion calls, for ex as: *10001; \n&quot;
              &quot;\n&quot;
         );
@@ -189,8 +190,6 @@
 
 bool PLearnServer::run()
 {
-    const int upper_bound_id = 10000;
-
     int obj_id;
     Object* obj;
     ObjMap::iterator found;
@@ -198,27 +197,36 @@
     int n_args; // number of input arguments to the method call
     string filepath;
 
+    // forward log messages to client
+    PP&lt;PL_LogPlugin&gt; orig_log_plugin= PL_Log::instance().getCurrentPlugin();
+    PL_Log::instance().setPlugin(new PL_LogPluginServer(io));
+    // forward progress messages to client
+    PP&lt;ProgressBarPlugin&gt; orig_pb_plugin= ProgressBar::getCurrentPlugin();
+    ProgressBar::setPlugin(new RemoteProgressBarPlugin(io));
+    // forward pout&amp;perr to client
+    PStream orig_pout= pout;
+    PStream orig_perr= perr;
+    pout= new ServerLogStreamBuf(io, &quot;pout&quot;);
+    perr= new ServerLogStreamBuf(io, &quot;perr&quot;);
+
     DBG_LOG &lt;&lt; &quot;ENTERING PLearnServer::run()&quot; &lt;&lt; endl;
+
     for(;;)
     {
         if(clear_maps)
         {
             io.copies_map_in.clear();
             io.copies_map_out.clear();
-
             for (ObjMap::iterator it = objmap.begin(); it != objmap.end(); ++it)
-                if (it-&gt;first &gt;= upper_bound_id)
-                    io.copies_map_in[it-&gt;first] = it-&gt;second;
+                io.copies_map_in[it-&gt;first] = it-&gt;second;
         }
         int c = -1;
-        do { c = io.get(); }
-        while(c!='!' &amp;&amp; c!=EOF);
+        do 
+            c = io.get(); 
+        while(io &amp;&amp; c!='!' &amp;&amp; c!=EOF);
         
-        if(c==EOF)
-        {
-            // cerr &lt;&lt; &quot;Read EOF: quitting&quot; &lt;&lt; endl;
+        if(c==EOF || !io)
             return true;
-        }
         int command = io.get();
         
         try 
@@ -235,7 +243,6 @@
                 break;
 
             case 'F': // call function 
-
                 io &gt;&gt; method_name &gt;&gt; n_args;
                 callFunction(method_name, n_args);
                 io &lt;&lt; endl;
@@ -251,6 +258,18 @@
                 io &lt;&lt; endl;  
                 DBG_LOG &lt;&lt; &quot;-&gt; OBJECT CREATED.&quot; &lt;&lt; endl;
                 break;
+
+            case 'O': // new w/o id; id is returned
+                DBG_LOG &lt;&lt; &quot;PLearnServer NEW OBJECT w/o ID&quot; &lt;&lt; endl;
+                obj = 0;
+                io &gt;&gt; obj;           // Read new object
+                obj_id= findFreeObjID(obj);
+                DBG_LOG &lt;&lt; &quot;  obj_id = &quot; &lt;&lt; obj_id &lt;&lt; endl;
+                objmap[obj_id] = obj;
+                Object::prepareToSendResults(io,1);
+                io &lt;&lt; obj_id &lt;&lt; endl;  
+                DBG_LOG &lt;&lt; &quot;-&gt; OBJECT CREATED.&quot; &lt;&lt; endl;
+                break;
             
             case 'L': // load from file
                 DBG_LOG &lt;&lt; &quot;PLearnServer LOAD OBJECT&quot; &lt;&lt; endl;
@@ -305,6 +324,11 @@
                 break;
 
             case 'Q': // quit
+                PL_Log::instance().setPlugin(orig_log_plugin);
+                ProgressBar::setPlugin(orig_pb_plugin);
+                pout= orig_pout;
+                perr= orig_perr;
+                io.setMode(PStream::plearn_ascii);
                 DBG_LOG &lt;&lt; &quot;PLearnServer QUIT&quot; &lt;&lt; endl;
                 // cerr &lt;&lt; &quot;Quitting&quot; &lt;&lt; endl;
                 DBG_LOG &lt;&lt; &quot;LEAVING PLearnServer::run()&quot; &lt;&lt; endl;
@@ -358,6 +382,25 @@
     return true;
 }
 
+int PLearnServer::findFreeObjID(const Object* obj) const
+{
+    //DUMMY method that tries to find an unused ID (LCG look-alike seeded w/ obj's address)
+    // this algorithm is not guaranteed to work... use at your own risk or modify accordingly
+    int id= reinterpret_cast&lt;unsigned int&gt;(obj) &gt;&gt; 1;
+    if(id &lt; 0) id= -id;
+    const int maxtries= 65536;
+    int ntries= 0;
+    while(objmap.find(id) != objmap.end() &amp;&amp; ++ntries &lt; maxtries)
+    {
+        id= id*1664525 + 1013904223;//simple &quot;LCG&quot;
+        if(id &lt; 0) id= -id;
+    }
+    if(ntries &gt;= maxtries)
+        PLERROR(&quot;PLearnServer::findFreeObjID : can't find a suitable ID within %d tries.&quot;, maxtries);
+    return id;
+}
+
+
 } // end of namespace PLearn
 
 

Modified: trunk/plearn/misc/PLearnServer.h
===================================================================
--- trunk/plearn/misc/PLearnServer.h	2007-02-21 15:49:27 UTC (rev 6675)
+++ trunk/plearn/misc/PLearnServer.h	2007-02-22 21:05:50 UTC (rev 6676)
@@ -68,9 +68,12 @@
     PStream io;
     bool clear_maps;
     ObjMap objmap;
+
+    virtual int findFreeObjID(const Object* obj) const;
+
 public:
     PLearnServer(const PStream&amp; input_output);
-    ~PLearnServer();
+    virtual ~PLearnServer();
 
     //! Enters the server loop which listens for commands and executes them.
     //! Returns false only if server kill command '!K' was issued

Modified: trunk/plearn/misc/PLearnService.cc
===================================================================
--- trunk/plearn/misc/PLearnService.cc	2007-02-21 15:49:27 UTC (rev 6675)
+++ trunk/plearn/misc/PLearnService.cc	2007-02-22 21:05:50 UTC (rev 6676)
@@ -3,6 +3,7 @@
 // PLearnService.cc
 //
 // Copyright (C) 2005 Pascal Vincent 
+// Copyright (C) 2007 Xavier Saint-Mleux, ApSTAT Technologies inc.
 // 
 // Redistribution and use in source and binary forms, with or without
 // modification, are permitted provided that the following conditions are met:
@@ -80,6 +81,8 @@
 {
     PStream in = openFile(serversfile, PStream::raw_ascii, &quot;r&quot;);
 
+    DBG_LOG &lt;&lt; &quot;PLearnService::connectToServers(&quot; &lt;&lt; serversfile &lt;&lt; ')' &lt;&lt; endl;
+
     string hostname;
     string pid;
     int tcpport = -1;
@@ -100,28 +103,56 @@
 
 void PLearnService::connectToServers(TVec&lt; pair&lt;string,int&gt; &gt; hostname_and_port)
 {
+
+    DBG_LOG &lt;&lt; &quot;PLearnService::connectToServers(&quot; &lt;&lt; hostname_and_port &lt;&lt; ')' &lt;&lt; endl;
+
     if(available_servers.size()&gt;0)
         disconnectFromServers();
     for(int k=0; k&lt;hostname_and_port.length(); k++)
     {
         pair&lt;string, int&gt; host_port = hostname_and_port[k];
-        PStream servio = openSocket(host_port.first, host_port.second, PStream::plearn_binary);
-        // PStream servio = openSocket(host_port.first, host_port.second, PStream::plearn_ascii);
+        PStream servio = openSocket(host_port.first, host_port.second, PStream::plearn_ascii);
         PP&lt;RemotePLearnServer&gt; serv = new RemotePLearnServer(servio);
         serv-&gt;callFunction(&quot;binary&quot;);
-        serv-&gt;expectResults(0);
+        
+        TVec&lt;PP&lt;RemotePLearnServer&gt; &gt; ss;
+        ss.push_back(serv);
+
+        watchServers(ss, log_callback, progress_callback);
+
+        servio &lt;&lt; PStream::plearn_binary;
+
+        reserved_servers.insert(serv);
+        serv-&gt;getResults();
+        reserved_servers.erase(serv);
         available_servers.push(serv);
-        //serversio.append(servio);
-        //available_servers.push(k);
     }
 }
 
 void PLearnService::disconnectFromServers()
 {
-    available_servers = TVec&lt; PP&lt;RemotePLearnServer&gt; &gt;();
+    //available_servers = TVec&lt; PP&lt;RemotePLearnServer&gt; &gt;();
+    while(available_servers.length() &gt; 0)
+        disconnectFromServer(available_servers[0]);
 }
 
 
+void PLearnService::disconnectFromServer(PP&lt;RemotePLearnServer&gt; server)
+{
+    for(int i= 0; i &lt; available_servers.length(); ++i)
+        if(available_servers[i] == server)
+        {
+            available_servers.remove(i);
+            server-&gt;io.write(&quot;!Q &quot;);
+            server-&gt;io &lt;&lt; endl;
+            if(progress_bars.find(server) != progress_bars.end())
+                progress_bars.erase(server);
+            return;
+        }
+    PLERROR(&quot;PLearnService::disconnectFromServer : trying to disconnect from a server which is not available&quot;
+            &quot; (not connected to or reserved)&quot;);
+}
+
 int PLearnService::availableServers() const
 {    
     return available_servers.size();
@@ -166,8 +197,8 @@
 void PLearnService::freeServer(PP&lt;RemotePLearnServer&gt; server)
 {
     DBG_LOG &lt;&lt; &quot;PLearnService::freeServer(...)&quot; &lt;&lt; endl;
+    server-&gt;deleteAllObjects();
     server-&gt;clearMaps();
-    server-&gt;deleteAllObjects();
     if(reserved_servers.erase(server)!=1)
         PLERROR(&quot;Problem in PLearnService::freeServer are you sure this server had been properly reserved?&quot;);
     available_servers.push(server);
@@ -200,6 +231,122 @@
     return -1;  // To make the compiler happy (never reached).
 }
 
+
+int PLearnService::watchServers(TVec&lt; PP&lt;RemotePLearnServer&gt; &gt; servers, 
+                                log_callback_t log_callback, 
+                                progress_callback_t progress_callback)
+{
+    Poll p;
+    int n = servers.size();
+    vector&lt;PStream&gt; streams(n);
+    for(int k=0; k&lt;n; k++)
+        streams[k] = servers[k]-&gt;io;
+    p.setStreamsToWatch(streams);
+
+    for(;;)
+    {
+        PRInt32 npending = p.waitForEvents(PR_INTERVAL_NO_TIMEOUT, true);
+        if(npending&lt;=0)
+            return -1;
+
+        int the_k= -1;
+        PStream io = p.getNextPendingEvent();    
+
+        for(int k=0; k&lt;n; k++)
+            if(streams[k] == io)
+                the_k= k;
+
+        if(the_k &gt;= 0)
+        {
+            int c= io.peek();
+            // skip blanks one at a time and poll again
+            if(static_cast&lt;char&gt;(c) == ' ' || static_cast&lt;char&gt;(c) == '\t' 
+               || static_cast&lt;char&gt;(c) == '\n' || static_cast&lt;char&gt;(c) == '\r') 
+            {
+                io.get();
+                continue;
+            }
+            else if(static_cast&lt;char&gt;(c) == '*') //async. message (log or progress)
+            {
+                io.get(); // get '*'
+                c= io.get();// get msg type ('L'og or 'P'rogress)
+
+                int vlevel, c0;
+                unsigned int pos, ptr;
+                string mesg;
+                string module(&quot;&quot;);
+                switch(static_cast&lt;char&gt;(c))
+                {
+                case 'L' : // log message
+                    io &gt;&gt; module &gt;&gt; vlevel &gt;&gt; mesg;
+                    log_callback(servers[the_k], module, vlevel, mesg);
+                    break;
+                case 'P' : // progress message
+                    c0= io.get(); // action: 'A'dd, 'U'pdate or 'K'ill
+                    io &gt;&gt; ptr;// pbar id.
+                    if(static_cast&lt;char&gt;(c0) != 'K')
+                        io &gt;&gt; pos;// Add: maxpos; Update: curpos
+                    if(static_cast&lt;char&gt;(c0) == 'A')
+                        io &gt;&gt; mesg;// pbar title
+                    progress_callback(servers[the_k], ptr, static_cast&lt;char&gt;(c0), pos, mesg);
+                    break;
+                default:
+                    PLERROR(&quot;PLearnService::watchServers : Expected *L or *P, received *%c&quot;, c);
+                    break;
+                }
+            }
+            else //synchronous message, return server's id
+            {
+                return the_k;
+            }
+        }
+        else
+            PLERROR(&quot;stream returned by NextPendingEvent is none of the servers' io field. This should not happen!&quot;);
+    }
+    return -1;  // To make the compiler happy (never reached).
+}
+
+
+
+PP&lt;RemotePLearnServer&gt; PLearnService::waitForResult(TVec&lt; PP&lt;RemotePLearnServer&gt; &gt; servers, 
+                                log_callback_t log_callback, 
+                                progress_callback_t progress_callback)
+{
+    int min_server= 0;
+    if(servers.isEmpty())
+    {
+        servers= available_servers;
+        min_server= available_servers.length();
+        for(std::set&lt;PP&lt;RemotePLearnServer&gt; &gt;::iterator it= reserved_servers.begin();
+            it != reserved_servers.end(); ++it)
+            servers.push_back(*it);
+    }
+
+    if(servers.isEmpty())
+        PLERROR(&quot;in PLearnService::waitForResult : cannot wait for a result&quot;
+                &quot; when you are not connected to any server.&quot;);
+    int server= servers.length();
+
+    //send results from reserved servers only even if polling all servers
+    while(server &gt;= 0 &amp;&amp; server &lt; min_server || server == servers.length())
+        server= watchServers(servers, log_callback, progress_callback);
+
+    if(server &lt; 0)
+        PLERROR(&quot;in PLearnService::waitForResult : no server returned anything.&quot;);
+    return servers[server];
+}
+
+
+void PLearnService::waitForResultFrom(PP&lt;RemotePLearnServer&gt; from,
+                                      log_callback_t log_callback,
+                                      progress_callback_t progress_callback)
+{
+    PP&lt;RemotePLearnServer&gt; server= waitForResult();
+    while(server != from)
+        server= waitForResult();
+}
+
+
 /*
   void PLearnService::freeServer(RemotePLearnServer* remoteserv)
   {
@@ -218,9 +365,78 @@
 
 PLearnService::~PLearnService()
 {
+    if(reserved_servers.size() != 0)
+        PLERROR(&quot;PLearnService::~PLearnService : some servers are still reserved; free them first.&quot;);
+
+    TVec&lt;PP&lt;RemotePLearnServer&gt; &gt; servers(available_servers.length());
+    servers &lt;&lt; available_servers;
+
+    perr &lt;&lt; &quot;servers to disconnect from: &quot; &lt;&lt; servers.length() &lt;&lt; endl;
+
     disconnectFromServers();
+
+    perr &lt;&lt; &quot;start watching &quot; &lt;&lt; servers.length() &lt;&lt; endl;
+
+    //now, get what's remaining on the servers streams
+    for(int i= 0; i &lt; servers.length(); ++i)
+    {
+        try
+        {
+            for(;;) watchServers(servers, log_callback, progress_callback);
+        }
+        catch(const PLearnError&amp; e)
+        {
+            perr &lt;&lt; &quot;one dead &quot; &lt;&lt; i &lt;&lt; endl;
+        }
+    }
+
+    perr &lt;&lt; &quot;finished watching &quot; &lt;&lt; endl;
 }
 
+
+void PLearnService::log_callback(PP&lt;RemotePLearnServer&gt; server, const string&amp; module_name, int vlevel, const string&amp; msg)
+{ 
+    unsigned int server_id= reinterpret_cast&lt;unsigned int&gt;(static_cast&lt;RemotePLearnServer*&gt;(server));
+    PL_LOG(vlevel) &lt;&lt; &quot;&lt;From server &quot; &lt;&lt; server_id &lt;&lt; &quot;&gt; [&quot; &lt;&lt; module_name &lt;&lt; &quot;] &quot; &lt;&lt; msg &lt;&lt; flush; 
+}
+
+PLearnService::progress_bars_t PLearnService::progress_bars; // init
+
+void PLearnService::progress_callback(PP&lt;RemotePLearnServer&gt; server, unsigned int pbar, char action, 
+                                      unsigned int pos, const string&amp; title)
+{
+    unsigned int server_id= reinterpret_cast&lt;unsigned int&gt;(static_cast&lt;RemotePLearnServer*&gt;(server));
+    static bool need_to_set_pb_plugin= true;
+    if(need_to_set_pb_plugin)
+    {
+        ProgressBar::setPlugin(new LineOutputProgressBarPlugin(cerr));
+        need_to_set_pb_plugin= false;
+    }
+
+    switch(action)
+    {
+    case 'A': // add new progress bar
+        if(progress_bars.find(server) == progress_bars.end())
+            progress_bars[server]= map&lt;unsigned int, PP&lt;ProgressBar&gt; &gt;();
+        {//local environment for 'fulltitle'... silly c++ switch/case...
+            string fulltitle= string(&quot;&lt;server#&quot;) + tostring(server_id) 
+                + &quot;:pb#&quot; + tostring(pbar) + &quot;&gt; &quot; + title;//adjust title w/server info
+            progress_bars[server][pbar]= new ProgressBar(fulltitle, pos);
+        }
+        break;
+    case 'U': // update progress bar
+        progress_bars[server][pbar]-&gt;update(pos);
+        break;
+    case 'K': // kill progress bar
+        progress_bars[server].erase(pbar);
+        break;
+    default:
+        PLERROR(&quot;in PLearnService::progress_callback: unknown action %c&quot;, action);
+        break;
+    }
+}
+
+
 } // end of namespace PLearn
 
 

Modified: trunk/plearn/misc/PLearnService.h
===================================================================
--- trunk/plearn/misc/PLearnService.h	2007-02-21 15:49:27 UTC (rev 6675)
+++ trunk/plearn/misc/PLearnService.h	2007-02-22 21:05:50 UTC (rev 6676)
@@ -3,6 +3,7 @@
 // PLearnService.h
 //
 // Copyright (C) 2005 Pascal Vincent 
+// Copyright (C) 2007 Xavier Saint-Mleux, ApSTAT Technologies inc.
 // 
 // Redistribution and use in source and binary forms, with or without
 // modification, are permitted provided that the following conditions are met:
@@ -48,7 +49,7 @@
 #include &lt;plearn/io/PPath.h&gt;
 #include &lt;plearn/io/PStream.h&gt;
 #include &lt;plearn/math/TVec.h&gt;
-// #include &lt;map&gt;
+#include &lt;map&gt;
 #include &lt;set&gt;
 #include &lt;string&gt;
 #include &lt;plearn/misc/RemotePLearnServer.h&gt;
@@ -69,6 +70,9 @@
     TVec&lt; PP&lt;RemotePLearnServer&gt; &gt; available_servers;
     std::set&lt; PP&lt;RemotePLearnServer&gt; &gt; reserved_servers;
 
+    typedef map&lt;RemotePLearnServer*, map&lt;unsigned int, PP&lt;ProgressBar&gt; &gt; &gt; progress_bars_t;
+    static progress_bars_t progress_bars;
+
 public:
     friend class RemotePLearnServer;
 
@@ -86,6 +90,8 @@
 
     void disconnectFromServers();
 
+    void disconnectFromServer(PP&lt;RemotePLearnServer&gt; server);
+
     //! returns the number of available processing ressources
     int availableServers() const;
 
@@ -106,6 +112,26 @@
 
     int watchServers(TVec&lt; PP&lt;RemotePLearnServer&gt; &gt; servers, int timeout=0);
 
+    typedef void (*log_callback_t)(PP&lt;RemotePLearnServer&gt; server, const string&amp; module_name, int vlevel, const string&amp; msg);
+    typedef void (*progress_callback_t)(PP&lt;RemotePLearnServer&gt; server, unsigned int pbar, char action, 
+                                        unsigned int pos, const string&amp; title);
+
+    static void log_callback(PP&lt;RemotePLearnServer&gt; server, const string&amp; module_name, int vlevel, const string&amp; msg);
+    static void progress_callback(PP&lt;RemotePLearnServer&gt; server, unsigned int pbar, char action, 
+                                  unsigned int pos= 0, const string&amp; title= &quot;&quot;);
+
+    int watchServers(TVec&lt; PP&lt;RemotePLearnServer&gt; &gt; servers, 
+                     log_callback_t log_callback,
+                     progress_callback_t progress_callback);
+
+    PP&lt;RemotePLearnServer&gt; waitForResult(TVec&lt; PP&lt;RemotePLearnServer&gt; &gt; servers= TVec&lt; PP&lt;RemotePLearnServer&gt; &gt;(), 
+                                         log_callback_t log_callback= log_callback,
+                                         progress_callback_t progress_callback= progress_callback);
+
+    void waitForResultFrom(PP&lt;RemotePLearnServer&gt; from,
+                           log_callback_t log_callback= log_callback,
+                           progress_callback_t progress_callback= progress_callback);
+    
     ~PLearnService();
 };
 

Modified: trunk/plearn/misc/RemotePLearnServer.cc
===================================================================
--- trunk/plearn/misc/RemotePLearnServer.cc	2007-02-21 15:49:27 UTC (rev 6675)
+++ trunk/plearn/misc/RemotePLearnServer.cc	2007-02-22 21:05:50 UTC (rev 6676)
@@ -3,6 +3,7 @@
 // RemotePLearnServer.cc
 //
 // Copyright (C) 2005 Pascal Vincent 
+// Copyright (C) 2007 Xavier Saint-Mleux, ApSTAT Technologies inc.
 // 
 // Redistribution and use in source and binary forms, with or without
 // modification, are permitted provided that the following conditions are met:
@@ -42,6 +43,7 @@
 
 
 #include &quot;RemotePLearnServer.h&quot;
+#include &quot;PLearnService.h&quot;
 #include &lt;plearn/io/pl_log.h&gt;
 
 namespace PLearn {
@@ -80,35 +82,136 @@
     expectResults(0);
 }
 
+int RemotePLearnServer::newObject(const Object&amp; model)
+{ 
+    clearMaps();
+    io.write(&quot;!O &quot;); io &lt;&lt; model &lt;&lt; endl;
+    int objid;
+    getResults(objid);
+    return objid;
+}
+
+int RemotePLearnServer::newObject(PP&lt;Object&gt; model)
+{
+    if(model.isNull())
+        PLERROR(&quot;In RemotePLearnServer::newObject model is a Null pointer&quot;);
+    return newObject(*model);
+}
+
+int RemotePLearnServer::newObject(const string&amp; description)
+{ 
+    clearMaps();
+    io.write(&quot;!O &quot;); 
+    io.write(description);
+    io &lt;&lt; endl;
+    int objid;
+    getResults(objid);
+    return objid;
+}
+
+
+void RemotePLearnServer::newObjectAsync(int objid, const Object&amp; model)
+{ 
+    clearMaps();
+    io.write(&quot;!N &quot;); io &lt;&lt; objid &lt;&lt; model &lt;&lt; endl;
+}
+
+void RemotePLearnServer::newObjectAsync(int objid, PP&lt;Object&gt; model)
+{
+    if(model.isNull())
+        PLERROR(&quot;In RemotePLearnServer::newObject model is a Null pointer&quot;);
+    newObjectAsync(objid, *model);
+}
+
+void RemotePLearnServer::newObjectAsync(int objid, const string&amp; description)
+{ 
+    clearMaps();
+    io.write(&quot;!N &quot;); io &lt;&lt; objid; io.put(' ');
+    io.write(description);
+    io &lt;&lt; endl;
+}
+
+void RemotePLearnServer::newObjectAsync(const Object&amp; model)
+{ 
+    clearMaps();
+    io.write(&quot;!O &quot;); io &lt;&lt; model &lt;&lt; endl;
+}
+
+void RemotePLearnServer::newObjectAsync(const PP&lt;Object&gt;&amp; model)
+{
+    if(model.isNull())
+        PLERROR(&quot;In RemotePLearnServer::newObject model is a Null pointer&quot;);
+    newObjectAsync(*model);
+}
+
+void RemotePLearnServer::newObjectAsync(const string&amp; description)
+{ 
+    clearMaps();
+    io.write(&quot;!O &quot;); 
+    io.write(description);
+    io &lt;&lt; endl;
+}
+
+
+
 void RemotePLearnServer::deleteObject(int objid)
 {
-    io.write(&quot;!D &quot;); io &lt;&lt; objid &lt;&lt; endl;
+    deleteObjectAsync(objid);
     expectResults(0);
 }
 
+void RemotePLearnServer::deleteObjectAsync(int objid)
+{
+    io.write(&quot;!D &quot;); io &lt;&lt; objid &lt;&lt; endl;
+}
+
 void RemotePLearnServer::deleteAllObjects()
 {
-    io.write(&quot;!Z &quot;); 
-    io &lt;&lt; endl;
-    expectResults(0);
+    deleteAllObjectsAsync();
+    getResults();
+/*
+    if(io)
+    {
+        io.write(&quot;!Z &quot;); 
+        io &lt;&lt; endl;
+        expectResults(0);
+    }
+    else
+        DBG_LOG &lt;&lt; &quot;in RemotePLearnServer::deleteAllObjects() : stream not good.&quot; &lt;&lt; endl;
+*/
 }
 
+void RemotePLearnServer::deleteAllObjectsAsync()
+{
+    if(io)
+    {
+        io.write(&quot;!Z &quot;); 
+        io &lt;&lt; endl;
+    }
+    else
+        DBG_LOG &lt;&lt; &quot;in RemotePLearnServer::deleteAllObjectsAsync() : stream not good.&quot; &lt;&lt; endl;
+}
 
+
 void RemotePLearnServer::expectResults(int nargs_expected)
 {
-    DBG_LOG &lt;&lt; &quot;RemotePLearnServer entering expectResults&quot; &lt;&lt; endl;
+    PLearnService&amp; service= PLearnService::instance();
+    service.waitForResultFrom(this);
+
+    //DBG_LOG &lt;&lt; &quot;RemotePLearnServer entering expectResults&quot; &lt;&lt; endl;
     io.skipBlanksAndComments();
     int headchar = io.get();
     if(headchar!='!')
         PLERROR(&quot; Answers from plearn server are expected to start with a !, but I received a %c&quot;,headchar);
     int command = io.get();
-    DBG_LOG &lt;&lt; &quot;RemotePLearnServer expectResults received command: &quot; &lt;&lt; (char)command &lt;&lt; endl;
+    //DBG_LOG &lt;&lt; &quot;RemotePLearnServer expectResults received command: &quot; &lt;&lt; (char)command &lt;&lt; endl;
     int nreturned;
     string msg;
     switch(command)
     {
     case 'R':
         io &gt;&gt; nreturned;
+        //DBG_LOG &lt;&lt; &quot;RemotePLearnServer expectResults nreturned= &quot; &lt;&lt; nreturned &lt;&lt; endl;
         if(nreturned!=nargs_expected)
             PLERROR(&quot;RemotePLearnServer: expected %d return arguments, but read R %d&quot;,nargs_expected,nreturned);
         break;
@@ -123,15 +226,10 @@
 
 RemotePLearnServer::~RemotePLearnServer()
 {
-    DBG_LOG &lt;&lt; &quot;ENTERING RemotePLearnServer destructor&quot; &lt;&lt; endl;
-    deleteAllObjects();
-    //io.write(&quot;!Q&quot;);
-    //io = 0;
-    // DBG_LOG &lt;&lt; &quot;RemotePLearnServer destructor: BEFORE wait&quot; &lt;&lt; endl;
-    // prg-&gt;wait();
-    // DBG_LOG &lt;&lt; &quot;RemotePLearnServer destructor: AFTER wait&quot; &lt;&lt; endl;
-    // PLearnService::instance().freeServer(this);
-    DBG_LOG &lt;&lt; &quot;LEAVING RemotePLearnServer destructor&quot; &lt;&lt; endl;
+    // The PLearnService is responsible for RemotePLearnServer destruction 
+
+    //DBG_LOG &lt;&lt; &quot;ENTERING RemotePLearnServer destructor&quot; &lt;&lt; endl;
+    //DBG_LOG &lt;&lt; &quot;LEAVING RemotePLearnServer destructor&quot; &lt;&lt; endl;
 }
 
 

Modified: trunk/plearn/misc/RemotePLearnServer.h
===================================================================
--- trunk/plearn/misc/RemotePLearnServer.h	2007-02-21 15:49:27 UTC (rev 6675)
+++ trunk/plearn/misc/RemotePLearnServer.h	2007-02-22 21:05:50 UTC (rev 6676)
@@ -3,6 +3,7 @@
 // RemotePLearnServer.h
 //
 // Copyright (C) 2005 Pascal Vincent 
+// Copyright (C) 2007 Xavier Saint-Mleux, ApSTAT Technologies inc.
 // 
 // Redistribution and use in source and binary forms, with or without
 // modification, are permitted provided that the following conditions are met:
@@ -48,6 +49,7 @@
 #include &lt;plearn/io/PStream.h&gt;
 #include &lt;plearn/base/Object.h&gt;
 #include &lt;plearn/sys/Popen.h&gt;
+#include &lt;plearn/io/pl_log.h&gt;
 
 namespace PLearn {
 
@@ -56,11 +58,13 @@
 {    
 private:
     friend class PLearnService;
-
     PStream io; // io communication channel with remote PLearnServer
     RemotePLearnServer(const PStream&amp; serverio);
 
 public:
+
+
+    void killServer() { io &lt;&lt; &quot;!K &quot; &lt;&lt; endl; }
     
     //! Builds an object based on the given model on the remote server,
     //! assigning it the given id.
@@ -72,12 +76,42 @@
     //! in serialised form.
     void newObject(int objid, const string&amp; description);  
 
+    //! Builds an object based on the given model on the remote server,
+    //! returns an assigned id.
+    int newObject(const Object&amp; model);
+    int newObject(PP&lt;Object&gt; model);
+    //! Builds an object on the remote server, from its description
+    //! in serialised form.
+    int newObject(const string&amp; description);  
+    
+    //! Builds an object based on the given model on the remote server,
+    //! assigning it the given id.
+    void newObjectAsync(int objid, const Object&amp; model);
+    void newObjectAsync(int objid, PP&lt;Object&gt; model);
+    //! Builds an object on the remote server, from its description
+    //! in serialised form.
+    void newObjectAsync(int objid, const string&amp; description);  
+
+    //! Builds an object based on the given model on the remote server,
+    //! id is assigned by the server and returned.
+    void newObjectAsync(const Object&amp; model);
+    void newObjectAsync(const PP&lt;Object&gt;&amp; model);
+    //! Builds an object on the remote server, from its description
+    //! in serialised form.
+    void newObjectAsync(const string&amp; description);  
+
     //! Deletes an object of the remote server.
     void deleteObject(int objid);
 
+    //! Deletes an object of the remote server.
+    void deleteObjectAsync(int objid);
+
     //! Deletes all objects of the remote server.
     void deleteAllObjects();
 
+    //! Deletes all objects of the remote server.
+    void deleteAllObjectsAsync();
+
     void clearMaps();
 
     //! Users generally won't have to call this, but rather one of the callFunction methods.
@@ -210,7 +244,9 @@
     inline void getResults(Arg1&amp; arg1)
     {
         expectResults(1);
+        //DBG_LOG &lt;&lt; &quot;RemotePLearnServer getResults(Arg1&amp; arg1)&quot; &lt;&lt; endl;
         io &gt;&gt; arg1;
+        //DBG_LOG &lt;&lt; &quot;RemotePLearnServer getResults got arg1&quot; &lt;&lt; endl;
     }
     //! get results for a method with 2 output results
     //! These are the results for the just previously called method

Modified: trunk/plearn/sys/Popen.cc
===================================================================
--- trunk/plearn/sys/Popen.cc	2007-02-21 15:49:27 UTC (rev 6675)
+++ trunk/plearn/sys/Popen.cc	2007-02-22 21:05:50 UTC (rev 6676)
@@ -54,7 +54,7 @@
 namespace PLearn {
 using namespace std;
 
-void Popen::launch(const string&amp; program, const vector&lt;string&gt;&amp; arguments)
+void Popen::launch(const string&amp; program, const vector&lt;string&gt;&amp; arguments, bool redirect_stderr)
 {
     // Create pipes to communicate to/from child process.
     PRFileDesc* stdout_child;
@@ -73,10 +73,24 @@
                 getPrErrorString().c_str());
     }
 
+    PRFileDesc* stderr_child;
+    PRFileDesc* stderr_parent;
+
+    if(redirect_stderr)
+        if (PR_CreatePipe(&amp;stderr_child, &amp;stderr_parent) != PR_SUCCESS) 
+        {
+            PR_Close(stderr_child);
+            PR_Close(stderr_parent);
+            PLERROR(&quot;Popen: error creating third (err) pipe pair. (%s)&quot;,
+                    getPrErrorString().c_str());
+        }
+
     // Set up redirection of stdin/stdout for the (future) child process.
     PRProcessAttr* process_attr = PR_NewProcessAttr();
     PR_ProcessAttrSetStdioRedirect(process_attr, PR_StandardInput, stdin_child);
     PR_ProcessAttrSetStdioRedirect(process_attr, PR_StandardOutput, stdout_child);
+    if(redirect_stderr)
+        PR_ProcessAttrSetStdioRedirect(process_attr, PR_StandardError, stderr_child);
 
     // Set up argument list for the CreateProcess call. args[0] shoud be the
     // name of the program. args[1]...arg[n] hold the actual arguments,
@@ -117,11 +131,15 @@
     // Important: close unused files in the parent.
     PR_Close(stdin_child);
     PR_Close(stdout_child);
+    if(redirect_stderr)
+        PR_Close(stderr_child);
   
     delete[] args;                        
     if (!process) {
         PR_Close(stdin_parent);
         PR_Close(stdout_parent);
+        if(redirect_stderr)
+            PR_Close(stderr_parent);
         PLERROR(&quot;Popen: could not create subprocess for command '%s'. (%s)&quot;,
                 program.c_str(), getPrErrorString().c_str());
     }
@@ -130,10 +148,16 @@
     in = new PrPStreamBuf(stdout_parent, stdin_parent);
     in.setBufferCapacities(0, 0, 0);
     out = in;
+
+    if(redirect_stderr)
+    {    
+        err= new PrPStreamBuf(stderr_parent);
+        err.setBufferCapacities(0, 0, 0);
+    }
 }
 
 
-void Popen::launch(const string&amp; commandline)
+void Popen::launch(const string&amp; commandline, bool redirect_stderr)
 {
     // Parse command line into individual argments
     PStream s = openString(string(&quot;[&quot;) + commandline + &quot;]&quot;,
@@ -144,7 +168,7 @@
     const string command = command_and_args[0];
     const vector&lt;string&gt; args(command_and_args.begin()+1,
                               command_and_args.end());
-    launch(command, args);
+    launch(command, args, redirect_stderr);
 }
 
 
@@ -172,9 +196,9 @@
 }
 
   
-vector&lt;string&gt; execute(const string&amp; command)
+vector&lt;string&gt; execute(const string&amp; command, bool redirect_stderr)
 {
-    Popen p(command);
+    Popen p(command, redirect_stderr);
     vector&lt;string&gt; result;
     while(p.in)
     {

Modified: trunk/plearn/sys/Popen.h
===================================================================
--- trunk/plearn/sys/Popen.h	2007-02-21 15:49:27 UTC (rev 6675)
+++ trunk/plearn/sys/Popen.h	2007-02-22 21:05:50 UTC (rev 6676)
@@ -61,10 +61,10 @@
 protected:
     //! Multi-argument variant: the arguments are passed in a vector.
     void launch(const string&amp; command, const vector&lt;string&gt;&amp;
-                commandoptions);
+                commandoptions, bool redirect_stderr= false);
     //! Full text variant. All arguments are passed together in a string.
     //! @deprecated Use the other version of launch instead.
-    void launch(const string&amp; commandline); 
+    void launch(const string&amp; commandline, bool redirect_stderr= false); 
 
     bool verbose;
     bool process_alive;
@@ -74,14 +74,15 @@
 public:
     PStream in; //should these be only one I/O PStream? -xsm
     PStream out;
+    PStream err;
     
     Popen(const string&amp; command, 
-	  bool the_verbose = false) 
-    { verbose = the_verbose; launch(command); }
+	  bool the_verbose = false, bool redirect_stderr= false) 
+    { verbose = the_verbose; launch(command, redirect_stderr); }
 
     Popen(const string&amp; command, const vector&lt;string&gt;&amp; commandoptions, 
-	  bool the_verbose = false) 
-    { verbose = the_verbose; launch(command,commandoptions); }
+	  bool the_verbose = false, bool redirect_stderr= false) 
+    { verbose = the_verbose; launch(command,commandoptions, redirect_stderr); }
 
     /** Wait for process termination and return exit value.
         @note This must be called after all output from the program
@@ -102,7 +103,7 @@
   The command must not be waiting for input on its standard input 
   or this call will never return.
 */
-vector&lt;string&gt; execute(const string&amp; command);
+vector&lt;string&gt; execute(const string&amp; command, bool redirect_stderr= false);
 
 } // end of namespace PLearn
 

Modified: trunk/plearn/vmat/VMatrix.cc
===================================================================
--- trunk/plearn/vmat/VMatrix.cc	2007-02-21 15:49:27 UTC (rev 6675)
+++ trunk/plearn/vmat/VMatrix.cc	2007-02-22 21:05:50 UTC (rev 6676)
@@ -200,6 +200,25 @@
          ArgDoc (&quot;extra_percent&quot;, &quot;if non 0, then the box is enlarged in both ends\n&quot;
                  &quot;of every direction by that given percentage&quot;),
          RetDoc (&quot;bounding box as as a vector of (min,max) pairs&quot;)));         
+
+    declareMethod(
+        rmm, &quot;fill&quot;, &amp;VMatrix::fill,
+        (BodyDoc(&quot;Appends fills the VMatrix with a constant value.\n&quot;),
+         ArgDoc (&quot;value&quot;, &quot;The fill value.\n&quot;)));
+
+    declareMethod(
+        rmm, &quot;dot&quot;, &amp;VMatrix::dot,
+        (BodyDoc(&quot;dot product between row i1 and row i2, w/ inputsize first elements.&quot;),
+         ArgDoc (&quot;i1&quot;, &quot;First row to consider.&quot;),
+         ArgDoc (&quot;i2&quot;, &quot;Second row to consider.&quot;),
+         ArgDoc (&quot;inputsize&quot;, &quot;nb. elements to consider.&quot;),
+         RetDoc (&quot;dot product&quot;)));         
+
+    declareMethod(
+        rmm, &quot;savePMAT&quot;, &amp;VMatrix::savePMAT,
+        (BodyDoc(&quot;Saves this matrix as a .pmat file.&quot;),
+         ArgDoc (&quot;pmatfile&quot;, &quot;Path of the file to create.&quot;)));
+
 }
 
 

Modified: trunk/plearn_learners/generic/NNet.cc
===================================================================
--- trunk/plearn_learners/generic/NNet.cc	2007-02-21 15:49:27 UTC (rev 6675)
+++ trunk/plearn_learners/generic/NNet.cc	2007-02-22 21:05:50 UTC (rev 6676)
@@ -73,7 +73,7 @@
 #include &lt;plearn/var/FNetLayerVariable.h&gt;
 
 #include &lt;plearn/vmat/ConcatColumnsVMatrix.h&gt;
-//#include &quot;DisplayUtils.h&quot;
+//#include &lt;plearn/display/DisplayUtils.h&gt;
 //#include &quot;GradientOptimizer.h&quot;
 #include &quot;NNet.h&quot;
 // #include &lt;plearn/math/random.h&gt;

Modified: trunk/plearn_learners/testers/PTester.cc
===================================================================
--- trunk/plearn_learners/testers/PTester.cc	2007-02-21 15:49:27 UTC (rev 6675)
+++ trunk/plearn_learners/testers/PTester.cc	2007-02-22 21:05:50 UTC (rev 6676)
@@ -46,6 +46,8 @@
 #include &lt;assert.h&gt;
 #include &quot;PTester.h&quot;
 
+#include &lt;plearn/misc/PLearnService.h&gt;
+
 #include &lt;plearn/base/stringutils.h&gt;
 #if USING_MPI
 #include &lt;plearn/sys/PLMPI.h&gt;
@@ -282,6 +284,12 @@
          RetDoc (&quot;Vector of test statistics corresponding to the requested statnames&quot;)));
 
     declareMethod(
+        rmm, &quot;perform1Split&quot;, &amp;PTester::perform1Split,
+        (BodyDoc(&quot;Performs train/test for one split, returns splitres.&quot;),
+         ArgDoc (&quot;splitnum&quot;,&quot;Split number on which to perform train/test&quot;),
+         RetDoc (&quot;Vector of test statistics corresponding to the requested statnames&quot;)));
+
+    declareMethod(
         rmm, &quot;getStatNames&quot;, &amp;PTester::getStatNames,
         (BodyDoc(&quot;Return the statnames (potentially modified by statmask, if provided);\n&quot;
                  &quot;see the 'statnames' and 'statmask' options.&quot;),
@@ -405,7 +413,8 @@
 /////////////
 // perform //
 /////////////
-Vec PTester::perform(bool call_forget)
+// DEPRECATED -- USE PTester::perform
+Vec PTester::oldperform(bool call_forget)
 {
     if (!learner)
         PLERROR(&quot;No learner specified for PTester.&quot;);
@@ -733,6 +742,397 @@
     return global_result;
 }
 
+
+Vec PTester::perform1Split(int splitnum)
+{
+    if (!learner)
+        PLERROR(&quot;PTester::perform1Split : No learner specified for PTester.&quot;);
+    if (!splitter)
+        PLERROR(&quot;PTester::perform1Split : No splitter specified for PTester&quot;);
+
+    const int nstats = statnames_processed.length();
+
+    splitter-&gt;setDataSet(dataset);
+
+    TVec&lt;string&gt; testcostnames = learner-&gt;getTestCostNames();
+    TVec&lt;string&gt; traincostnames = learner-&gt;getTrainCostNames();
+
+    const int nsets = splitter-&gt;nSetsPerSplit();
+
+    // Stats collectors for individual sets of a split:
+    TVec&lt; PP&lt;VecStatsCollector&gt; &gt; stcol(nsets);
+    for (int setnum = 0; setnum &lt; nsets; setnum++)
+    {
+        if (template_stats_collector)
+        {
+            CopiesMap copies;
+            stcol[setnum] = template_stats_collector-&gt;deepCopy(copies);
+        }
+        else
+            stcol[setnum] = new VecStatsCollector();
+
+        if (setnum == 0)
+            stcol[setnum]-&gt;setFieldNames(traincostnames);
+        else
+            stcol[setnum]-&gt;setFieldNames(testcostnames);
+
+        stcol[setnum]-&gt;build();
+        stcol[setnum]-&gt;forget();
+    }
+
+    PP&lt;VecStatsCollector&gt; train_stats = stcol[0];
+    learner-&gt;setTrainStatsCollector(train_stats);
+
+
+    // Stat specs
+    TVec&lt;StatSpec&gt; statspecs(nstats);
+    for(int k = 0; k &lt; nstats; k++)
+    {
+        statspecs[k].init(statnames_processed[k]);
+    }
+
+    PPath splitdir;
+    bool is_splitdir = false;
+    if (!expdir.isEmpty())
+    {
+        splitdir = expdir / (&quot;Split&quot; + tostring(splitnum));
+        is_splitdir = true;
+    }
+
+    TVec&lt;VMat&gt; dsets = splitter-&gt;getSplit(splitnum);
+
+    if (should_train) {
+        VMat trainset = dsets[0];
+        if (is_splitdir &amp;&amp; save_data_sets)
+            PLearn::save(splitdir / &quot;training_set.psave&quot;, trainset);
+            
+        if (provide_learner_expdir)
+        {
+            if (is_splitdir)
+                learner-&gt;setExperimentDirectory(splitdir / &quot;LearnerExpdir/&quot;);
+            else
+                learner-&gt;setExperimentDirectory(&quot;&quot;);
+        }
+
+        learner-&gt;setTrainingSet(trainset, should_train);
+        if (dsets.size() &gt; 1)
+            learner-&gt;setValidationSet(dsets[1]);
+
+        if (is_splitdir &amp;&amp; save_initial_learners)
+            PLearn::save(splitdir / &quot;initial_learner.psave&quot;, learner);
+
+        train_stats-&gt;forget();
+        learner-&gt;train();
+        train_stats-&gt;finalize();
+
+        if (is_splitdir)
+        {
+            if (save_stat_collectors)
+                PLearn::save(splitdir / &quot;train_stats.psave&quot;, train_stats);
+            if (save_learners)
+                PLearn::save(splitdir / &quot;final_learner.psave&quot;, learner);
+        }
+    }
+    else
+        learner-&gt;build();
+
+    // This needs to be after the SetTrainingSet() / build() call to the
+    // learner.
+    const int outputsize = learner-&gt;outputsize();
+
+    // perf_eval_costs[setnum][perf_evaluator_name][costname] will contain value
+    // of the given cost returned by the given perf_evaluator on the given setnum
+    TVec&lt; map&lt;string, map&lt;string, real&gt; &gt; &gt; perf_eval_costs(dsets.length());
+
+    // Perform the test if required
+    if (should_test)
+    {
+        for (int setnum = 1; setnum &lt; dsets.length(); setnum++)
+        {
+            VMat testset = dsets[setnum];
+            VMat test_outputs;
+            VMat test_costs;
+            VMat test_confidence;
+
+            PP&lt;VecStatsCollector&gt; test_stats = stcol[setnum];
+            const string setname = &quot;test&quot; + tostring(setnum);
+            if (is_splitdir &amp;&amp; save_data_sets)
+                PLearn::save(splitdir / (setname + &quot;_set.psave&quot;), testset);
+
+            // QUESTION Why is this done so late? Can't it be moved
+            // somewhere earlier? At least before the save_data_sets?
+            if (is_splitdir)
+                force_mkdir(splitdir);
+
+            if (is_splitdir &amp;&amp; save_test_outputs)
+                test_outputs = new FileVMatrix(splitdir / (setname + &quot;_outputs.pmat&quot;),
+                                               0, learner-&gt;getOutputNames());
+            else if (!perf_evaluators.empty())
+            {
+                // We don't want to save test outputs to disk, but we
+                // need them for pef_evaluators. So let's store them in
+                // a MemoryVMatrix
+                Mat data(testset.length(), outputsize);
+                data.resize(0, outputsize);
+                test_outputs = new MemoryVMatrix(data);
+                test_outputs-&gt;declareFieldNames(learner-&gt;getOutputNames());
+            }
+
+            if (is_splitdir)
+            {
+                if (save_test_costs)
+                    test_costs = new FileVMatrix(splitdir / (setname + &quot;_costs.pmat&quot;),
+                                                 0, learner-&gt;getTestCostNames());
+                if (save_test_confidence)
+                    test_confidence = new FileVMatrix(splitdir / (setname + &quot;_confidence.pmat&quot;),
+                                                      0, 2 * outputsize);
+            }
+
+            test_stats-&gt;forget();
+                    
+            if (testset-&gt;length() == 0)
+                PLWARNING(&quot;PTester:: test set %s is of length 0, costs will be set to -1&quot;,
+                          setname.c_str());
+
+            // Before each test set, reset the internal state of the learner
+            learner-&gt;resetInternalState();
+
+            learner-&gt;test(testset, test_stats, test_outputs, test_costs);
+            //if (reset_stats)
+            test_stats-&gt;finalize();
+            if (is_splitdir &amp;&amp; save_stat_collectors)
+                PLearn::save(splitdir / (setname + &quot;_stats.psave&quot;), test_stats);
+
+            perf_evaluators_t::iterator it = perf_evaluators.begin();
+            const perf_evaluators_t::iterator itend = perf_evaluators.end();
+            while (it != itend)
+            {
+                PPath perf_eval_dir;
+                if (is_splitdir)
+                    perf_eval_dir = splitdir / setname / (&quot;perfeval_&quot; + it-&gt;first);
+                Vec perf_costvals = it-&gt;second-&gt;evaluatePerformance(learner, testset, test_outputs, perf_eval_dir);
+                TVec&lt;string&gt; perf_costnames = it-&gt;second-&gt;getCostNames();
+                if (perf_costvals.length()!=perf_costnames.length())
+                    PLERROR(&quot;vector of costs returned by performance evaluator differ in size with its vector of costnames&quot;);
+                map&lt;string, real&gt;&amp; costmap = perf_eval_costs[setnum][it-&gt;first];
+                for (int costi = 0; costi &lt; perf_costnames.length(); costi++)
+                    costmap[perf_costnames[costi]] = perf_costvals[costi];
+                ++it;
+            }
+            computeConfidence(testset, test_confidence);
+        }
+    }
+
+    Vec splitres(1 + nstats);
+    splitres[0] = splitnum;
+
+    for (int k = 0; k &lt; nstats; k++)
+    {
+        // If we ask for a test-set that's beyond what's currently
+        // available, OR we are asking for test-statistics in
+        // train-only mode, then the statistic is MISSING_VALUE.
+        StatSpec&amp; sp = statspecs[k];
+        if (sp.setnum&gt;=stcol.length() ||
+            (! should_test &amp;&amp; sp.setnum &gt; 0))
+        {
+            splitres[k+1] = MISSING_VALUE;
+        }
+        else
+        {
+            string left, right;
+            split_on_first(sp.intstatname, &quot;.&quot;,left,right);
+            if (right != &quot;&quot; &amp;&amp; perf_evaluators.find(left) != perf_evaluators.end())
+            {
+                // looks like a cost from a performance evaluator
+                map&lt;string, real&gt;&amp; costmap = perf_eval_costs[sp.setnum][left];
+                if (costmap.find(right) == costmap.end())
+                    PLERROR(&quot;No cost named %s appears to be returned by evaluator %s&quot;,
+                            right.c_str(), left.c_str());
+                splitres[k+1] = costmap[right];
+            }
+            else
+                // must be a cost from a stats collector
+                splitres[k+1] = stcol[sp.setnum]-&gt;getStat(sp.intstatname);
+        }
+    }
+
+    return splitres;
+}
+
+
+Vec PTester::perform(bool call_forget)
+{
+    if (!learner)
+        PLERROR(&quot;No learner specified for PTester.&quot;);
+    if (!splitter)
+        PLERROR(&quot;No splitter specified for PTester&quot;);
+
+    const int nstats = statnames_processed.length();
+    Vec global_result(nstats);
+
+    if (expdir != &quot;&quot;)
+    {
+        if (pathexists(expdir) &amp;&amp; enforce_clean_expdir)
+            PLERROR(&quot;Directory (or file) %s already exists.\n&quot;
+                    &quot;First move it out of the way.&quot;, expdir.c_str());
+        if (!force_mkdir(expdir))
+            PLERROR(&quot;In PTester Could not create experiment directory %s&quot;,expdir.c_str());
+        expdir = expdir.absolute() / &quot;&quot;;
+
+        // Save this tester description in the expdir
+        if (save_initial_tester)
+            PLearn::save(expdir / &quot;tester.psave&quot;, *this);
+    }
+
+    const int nsplits = splitter-&gt;nsplits();
+    if (nsplits &gt; 1)
+        call_forget = true;
+
+    TVec&lt;string&gt; testcostnames = learner-&gt;getTestCostNames();
+    TVec&lt;string&gt; traincostnames = learner-&gt;getTrainCostNames();
+
+    // Global stats collector
+    PP&lt;VecStatsCollector&gt; global_statscol;
+    if (global_template_stats_collector)
+    {
+        CopiesMap copies;
+        global_statscol = global_template_stats_collector-&gt;deepCopy(copies);
+        global_statscol-&gt;build();
+        global_statscol-&gt;forget();
+    }
+    else
+        global_statscol = new VecStatsCollector();
+
+    // Stat specs
+    TVec&lt;StatSpec&gt; statspecs(nstats);
+    for(int k = 0; k &lt; nstats; k++)
+    {
+        statspecs[k].init(statnames_processed[k]);
+    }
+
+    //no ACC stats for parallel perform
+    for (int k = 0; k &lt; nstats; k++)
+        if (statspecs[k].extstat == &quot;ACC&quot;)
+            PLERROR(&quot;ACC stats not supported anymore; please adapt PTester::perform to your needs.&quot;);
+
+
+    // The vmat in which to save global result stats specified in statnames
+    VMat global_stats_vm;
+    // The vmat in which to save per split result stats
+    VMat split_stats_vm;
+        
+    if (expdir != &quot;&quot; &amp;&amp; report_stats)
+    {
+        saveStringInFile(expdir / &quot;train_cost_names.txt&quot;, join(traincostnames, &quot;\n&quot;) + &quot;\n&quot;);
+        saveStringInFile(expdir / &quot;test_cost_names.txt&quot;, join(testcostnames, &quot;\n&quot;) + &quot;\n&quot;);
+
+        global_stats_vm = new FileVMatrix(expdir / &quot;global_stats.pmat&quot;,
+                                          1, nstats);
+        for (int k = 0; k &lt; nstats; k++)
+            global_stats_vm-&gt;declareField(k, statspecs[k].statName());
+        global_stats_vm-&gt;saveFieldInfos();
+
+        split_stats_vm = new FileVMatrix(expdir / &quot;split_stats.pmat&quot;,
+                                         0, 1 + nstats);
+        split_stats_vm-&gt;declareField(0, &quot;splitnum&quot;);
+        for (int k = 0; k &lt; nstats; k++)
+            split_stats_vm-&gt;declareField(k+1, statspecs[k].setname + &quot;.&quot; + statspecs[k].intstatname);
+        split_stats_vm-&gt;saveFieldInfos();
+    }
+
+
+    PLearnService&amp; service(PLearnService::instance());
+    TVec&lt;PP&lt;RemotePLearnServer&gt; &gt; servers= service.reserveServers(nsplits);
+    int nservers= servers.length();
+
+    if(nservers &gt; 1)
+    {
+        map&lt;PP&lt;RemotePLearnServer&gt;, int&gt; testers_ids;
+        for (int splitnum= 0; splitnum &lt; nservers &amp;&amp; splitnum &lt; nsplits; ++splitnum)
+            servers[splitnum]-&gt;newObjectAsync(*this);
+
+        int splits_called= 0;
+        //int testers_created= nservers;
+        for (int splits_done= 0; nservers &gt; 0;)//splits_done &lt; nsplits;)
+        {
+            PP&lt;RemotePLearnServer&gt; s= service.waitForResult();
+            if(testers_ids.find(s) == testers_ids.end())
+            {
+                if(splits_called &lt; nsplits)
+                {
+                    int id;
+                    s-&gt;getResults(id);
+                    testers_ids[s]= id;
+                    s-&gt;callMethod(id, &quot;perform1Split&quot;, splits_called);
+                    ++splits_called;
+                }
+                else
+                {
+                    s-&gt;getResults(); // tester deleted
+                    service.freeServer(s);
+                    --nservers;
+                }
+            }
+            else // get split result
+            {
+                Vec splitres;
+                s-&gt;getResults(splitres);
+                ++splits_done;
+                if (split_stats_vm)
+                {
+                    split_stats_vm-&gt;appendRow(splitres);
+                    split_stats_vm-&gt;flush();
+                }
+            
+                global_statscol-&gt;update(splitres.subVec(1, nstats));
+
+                if(splits_called &lt; nsplits)//call for another split
+                {
+                    s-&gt;callMethod(testers_ids[s], &quot;perform1Split&quot;, splits_called);
+                    ++splits_called;
+                }
+                else
+                {
+                    s-&gt;deleteObjectAsync(testers_ids[s]);
+                    testers_ids.erase(s);
+                }
+            }
+        }
+    }
+    else
+        for (int splitnum= 0; splitnum &lt; nsplits; ++splitnum)
+        {
+            Vec splitres= perform1Split(splitnum);
+            
+            if (split_stats_vm)
+            {
+                split_stats_vm-&gt;appendRow(splitres);
+                split_stats_vm-&gt;flush();
+            }
+            
+            global_statscol-&gt;update(splitres.subVec(1, nstats));
+        }
+
+
+    global_statscol-&gt;finalize();
+    for (int k = 0; k &lt; nstats; k++)
+        global_result[k] = global_statscol-&gt;getStats(k).getStat(statspecs[k].extstat);
+
+    if (global_stats_vm)
+        global_stats_vm-&gt;appendRow(global_result);
+
+#if USING_MPI
+    if (PLMPI::rank == 0)
+#endif
+    // Perform the final commands provided in final_commands.
+    for (int i = 0; i &lt; final_commands.length(); i++)
+    {
+        system(final_commands[i].c_str());
+    }
+
+    return global_result;
+}
+
 void PTester::computeConfidence(VMat test_set, VMat confidence)
 {
     PLASSERT(learner);

Modified: trunk/plearn_learners/testers/PTester.h
===================================================================
--- trunk/plearn_learners/testers/PTester.h	2007-02-21 15:49:27 UTC (rev 6675)
+++ trunk/plearn_learners/testers/PTester.h	2007-02-22 21:05:50 UTC (rev 6676)
@@ -189,7 +189,10 @@
      *  statnames
      */
     Vec perform(bool call_forget=true);
+    Vec perform1Split(int splitnum);
 
+    Vec oldperform(bool call_forget=true);
+
     //! Transforms a shallow copy into a deep copy
     virtual void makeDeepCopyFromShallowCopy(CopiesMap&amp; copies);
 };

Modified: trunk/python_modules/plearn/io/server.py
===================================================================
--- trunk/python_modules/plearn/io/server.py	2007-02-21 15:49:27 UTC (rev 6675)
+++ trunk/python_modules/plearn/io/server.py	2007-02-22 21:05:50 UTC (rev 6676)
@@ -36,6 +36,8 @@
 from threading import Timer
 from thread    import interrupt_main
 
+from plearn.utilities.progress import LineOutputProgressBar
+
 from plearn.pyplearn import *
 import plearn.io.serialize
 
@@ -58,6 +60,20 @@
     s.connect((hostname, port))
     io = s.makefile()
     return RemotePLearnServer(io, io, logger=logger)
+
+
+def default_log_callback(module, vlevel, message):
+    print (&quot;SERVER-LOG: [&quot; + module +&quot;] &quot;+ str(vlevel) + ' ' + message)
+    
+def default_pbar_callback(pbars, cmd, ptr, pos, title):
+    if cmd=='A':
+        pbars[ptr]= LineOutputProgressBar(title, pos)
+    else:
+        pbars[ptr].update(pos)
+        if cmd == 'K':
+            del(pbars[ptr])
+
+
         
 class RemotePLearnServer:
 
@@ -96,6 +112,7 @@
         self.clear_maps = True
         self.dbg_dump = False
         self.closed = False
+        self.pbars= {}
 
         ## Ensure that the server is responding. Otherwise raise an error
         if not self.isAlive():
@@ -264,7 +281,39 @@
         self.clearMaps()
         self.logged_write('!M '+str(objid)+' '+methodname+' '+str(nargs)+' ')
 
+
+
+    def waitForResult(self, log_callback= default_log_callback, pbar_callback= default_pbar_callback):
+        while True:
+            self.io.skip_blanks_and_comments()
+            c = self.io.peek()
+            if c=='*': #log or progress message
+                c = self.io.get()#get '*'
+                c = self.io.get()
+                if c == 'L': # Log message
+                    module= self.io.read_string()
+                    vlevel= self.io.read_int()
+                    message= self.io.read_string()
+                    log_callback(module, vlevel, message)
+                elif c == 'P': # Progress message
+                    command= self.io.get()
+                    ptr= self.io.read_int()
+                    pos= 0
+                    title= ''
+                    if command != 'K':
+                        pos= self.io.read_int()
+                    if command == 'A':
+                        title= self.io.read_string()
+                        title= '(pb#'+str(ptr)+') '+title
+                    pbar_callback(self.pbars, command, ptr, pos, title)
+                else:
+                    raise TypeError(&quot;Expected *L or *P, but read *&quot;+c)
+            else:
+                return
+        
+
     def getResultsCount(self):
+        self.waitForResult()
         self.io.skip_blanks_and_comments()
         c = self.io.get()
         if c!='!':
@@ -311,7 +360,7 @@
 
     def callMethod(self, objid, methodname, *args):
         self.sendMethodCallHeader(objid, methodname, len(args))
-        # print 'sending ARGS', args
+        #print 'sending ARGS', args
         self.logged_write_args(args)
 
         if self.dbg_dump:

Modified: trunk/python_modules/plearn/parallel/dbi.py
===================================================================
--- trunk/python_modules/plearn/parallel/dbi.py	2007-02-21 15:49:27 UTC (rev 6675)
+++ trunk/python_modules/plearn/parallel/dbi.py	2007-02-22 21:05:50 UTC (rev 6676)
@@ -10,6 +10,8 @@
 from textwrap import dedent
 import pdb
 from time import sleep
+from plearn.pymake import pymake
+
 STATUS_FINISHED = 0
 STATUS_RUNNING = 1
 STATUS_WAITING = 2
@@ -129,6 +131,26 @@
         status = get_config_value(self.log_file,'STATUS')
         return int(status)
 
+    def get_stdout(self):
+        try:
+            if isinstance(self.p.stdout, file):
+                return self.p.stdout
+            else:
+                return open(self.log_file + '.out','r')
+        except:
+            pass
+        return None
+        
+    def get_stderr(self):
+        try:
+            if isinstance(self.p.stderr, file):
+                return self.p.stderr
+            else:
+                return open(self.log_file + '.err','r')
+        except:
+            pass
+        return None
+
     def get_waiting_time(self):
         # get the string representation
         str_sched = get_config_value(self.log_file,'SCHEDULED_TIME')
@@ -399,16 +421,144 @@
 
 
 
-def clean(self):
+    def clean(self):
         pass
 
+
+
+class SshHost:
+    def __init__(self, hostname):
+        self.hostname= hostname
+        self.lastupd= -16
+        self.getAvailability()
+        
+    def getAvailability(self):
+        # simple heuristic: mips / load
+        t= time.time()
+        if t - self.lastupd &gt; 15: # min. 15 sec. before update
+            self.bogomips= self.getBogomips()
+            self.loadavg= self.getLoadavg()
+            self.lastupd= t
+            #print  self.hostname, self.bogomips, self.loadavg, (self.bogomips / (self.loadavg + 0.5))
+        return self.bogomips / (self.loadavg + 0.5)
+        
+    def getBogomips(self):
+        cmd= [&quot;ssh&quot;, self.hostname ,&quot;cat /proc/cpuinfo&quot;]
+        p= Popen(cmd, stdout=PIPE)
+        bogomips= 0.0
+        for l in p.stdout:
+            if l.startswith('bogomips'):
+                s= l.split(' ')
+                bogomips+= float(s[-1])
+        return bogomips
+
+    def getLoadavg(self):
+        cmd= [&quot;ssh&quot;, self.hostname,&quot;cat /proc/loadavg&quot;]
+        p= Popen(cmd, stdout=PIPE)
+        l= p.stdout.readline().split(' ')
+        return float(l[0])
+        
+    def addToLoadavg(self,n):
+        self.loadavg+= n
+        self.lastupd= time.time()
+
+    def __str__(self):
+        return &quot;SshHost(&quot;+self.hostname+&quot; &lt;&quot;+str(self.bogomips) \
+               +','+str(self.loadavg) +','+str(self.getAvailability()) \
+               +','+str(self.lastupd) + '&gt;)'
+
+    def __repr__(self):
+        return str(self)
+        
+def find_all_ssh_hosts():
+    return [SshHost(h) for h in set(pymake.get_distcc_hosts())]
+
+def cmp_ssh_hosts(h1, h2):
+    return cmp(h2.getAvailability(), h1.getAvailability())
+
+class DBISsh(DBIBase):
+
+    def __init__(self, commands, **args ):
+        DBIBase.__init__(self, commands, **args)
+
+        # check if log directory exists, if not create it
+        if not os.path.exists(self.log_dir):
+            os.mkdir(self.log_dir)
+
+        # create the information about the tasks
+        for command in commands:
+            self.tasks.append(Task(command, self.log_dir, self.time_format,
+                                   self.pre_tasks, self.post_tasks))
+        self.hosts= find_all_ssh_hosts()
+        
+
+    def getHost(self):
+        self.hosts.sort(cmp= cmp_ssh_hosts)
+        #print &quot;hosts= &quot;
+        #for h in self.hosts: print h
+        self.hosts[0].addToLoadavg(1.0)
+        return self.hosts[0]
+    
+    def run_one_job(self, task):
+        DBIBase.run(self)
+
+        host= self.getHost()
+
+
+        cwd= os.getcwd()
+        command = &quot;ssh &quot; + host.hostname + &quot; 'cd &quot; + cwd + &quot;; &quot; + string.join(task.commands,';') + &quot;'&quot;
+        print command
+
+        task.launch_time = time.time()
+        set_config_value(task.log_file, 'SCHEDULED_TIME',
+                time.strftime(self.time_format, time.localtime(time.time())))
+        output = PIPE
+        error = PIPE
+        if int(self.file_redirect_stdout):
+            output = file(task.log_file + '.out','w')
+        if int(self.file_redirect_stderr):
+            error = file(task.log_file + '.err','w')
+        task.p = Popen(command, shell=True,stdout=output,stderr=error)
+
+    def run(self):
+        # Execute pre-batch
+        pre_batch_command = ';'.join( self.pre_batch )
+        output = PIPE
+        error = PIPE
+        if int(self.file_redirect_stdout):
+            output = file(self.log_file + '.pre_batch.out', 'w')
+        if int(self.file_redirect_stderr):
+            error = file(self.log_file + '.pre_batch.err', 'w')
+        self.pre = Popen(pre_batch_command, shell=True, stdout=output, stderr=error)
+        print 'pre_batch_command =', pre_batch_command
+
+        # Execute all Tasks (including pre_tasks and post_tasks if any)
+        print &quot;tasks= &quot;, self.tasks
+        for task in self.tasks:
+            self.run_one_job(task)
+
+        # Execute post-batchs
+        post_batch_command = &quot;;&quot;.join( self.post_batch );
+        if int(self.file_redirect_stdout):
+            output = file(self.log_file + '.post_batch.out', 'w')
+        if int(self.file_redirect_stderr):
+            error = file(self.log_file + '.post_batch.err', 'w')
+        self.post = Popen(post_batch_command, shell=True, stdout=output, stderr=error)
+        print 'post_batch_command =', post_batch_command
+
+    def clean(self):
+        #TODO: delete all log files for the current batch
+        pass
+
+
+
 # creates an object of type ('DBI' + launch_system) if it exists
 def DBI(commands, launch_system):
     try:
         str = 'DBI'+launch_system+'(commands)'
         jobs = eval('DBI'+launch_system+'(commands)')
     except NameError:
-        print 'The launch system ',launch_system, ' does not exists. Available systems are: Cluster, bqtools and Condor'
+        print 'The launch system ',launch_system, ' does not exists. Available systems are: Cluster, Ssh, bqtools and Condor'
         sys.exit(1)
     return jobs
 

Modified: trunk/python_modules/plearn/parallel/dispatch.py
===================================================================
--- trunk/python_modules/plearn/parallel/dispatch.py	2007-02-21 15:49:27 UTC (rev 6675)
+++ trunk/python_modules/plearn/parallel/dispatch.py	2007-02-22 21:05:50 UTC (rev 6676)
@@ -15,7 +15,7 @@
     &quot;Task&quot;,
     
     # Functions
-    &quot;get_ssh_machines&quot;, &quot;launch_task&quot;, &quot;set_logdir&quot;,
+    &quot;get_ssh_machines&quot;, &quot;launch_task&quot;, &quot;launch_server&quot;, &quot;set_logdir&quot;,
 
     # Classes
     &quot;ArgumentsOracle&quot;, &quot;Dispatch&quot;
@@ -91,9 +91,14 @@
 
 def launch_task(argv, wait=False):
     assert Task is not None
-    task = Task( argv )
+    task = Task( argv)
     task.launch( wait )
 
+def launch_server(argv):
+    assert Task is not None
+    task = Task( argv)
+    task.launchServer()
+
 def set_logdir(logdir):
     &quot;&quot;&quot;Instead of writing to stdout, tasks will be logged in a file within I{logdir}.&quot;&quot;&quot;
     global LOGDIR
@@ -122,6 +127,7 @@
 
 class TaskType:
     _child_processes = {}
+    _launched_servers_info= []
 
     def count( cls ):
         &quot;&quot;&quot;Return the number of uncompleted tasks.&quot;&quot;&quot;
@@ -129,6 +135,7 @@
     count = classmethod( count )
 
     def kill_all_tasks( cls ):
+        cls.kill_launched_servers()
         task_list = cls._child_processes.values()
         for task in task_list:
             try:
@@ -143,6 +150,13 @@
         assert not cls._child_processes
     kill_all_tasks = classmethod(kill_all_tasks)
 
+    def kill_launched_servers( cls ):
+        for (host, port, pid) in cls._launched_servers_info:
+            cmd= &quot;ssh %s kill %d&quot;%(host, pid)
+            os.system(cmd)
+            logging.info(&quot;Killed process %d on %s [%s]&quot;%(pid, host, cmd))
+    kill_launched_servers= classmethod(kill_launched_servers)
+
     def availableMachinesCount( cls ):
         &quot;&quot;&quot;Returns the number of machines currently available for cluster job dispatch.&quot;&quot;&quot;
         avail = 0
@@ -151,8 +165,34 @@
         return avail
     availableMachinesCount = classmethod(availableMachinesCount)
 
+    def getLaunchedServersInfo( cls ):
+        &quot;&quot;&quot;Returns a list of triples (machine, port, pid) 
+        e.g.: [('midgard', 41492, 2677),('odin', 48972, 1830)]
+        &quot;&quot;&quot;
+        return cls._launched_servers_info
+    getLaunchedServersInfo= classmethod(getLaunchedServersInfo)
+
+    def getLaunchedServerInfo( cls, child_fd ):
+        &quot;&quot;&quot;Reads machine name, port and pid for a launched PLearn server.
+        returns a triple (machine, port, pid)
+        e.g.: ('midgard', 41492, 2677)
+        &quot;&quot;&quot;
+        got_info= False
+        while not got_info:
+            s= child_fd.readline()
+            if s=='':
+                print &quot;Cannot get info from server!&quot;
+                sys.exit()
+            ss= s.split(' ')
+            if ss[0] == &quot;PLEARN_SERVER_TCP&quot;:
+                info= (ss[1], int(ss[2]), int(ss[3]))
+                got_info= True
+        cls._launched_servers_info+= [info]
+        return info
+    getLaunchedServerInfo= classmethod(getLaunchedServerInfo)
+
     def select( cls ):
-        &quot;&quot;&quot;Finds, frees and returns ompleted tasks.&quot;&quot;&quot;
+        &quot;&quot;&quot;Finds, frees and returns completed tasks.&quot;&quot;&quot;
         if cls.count() == 0:
             logging.debug(&quot;* Raising EmptyTaskListError&quot;)
             raise EmptyTaskListError()
@@ -209,6 +249,11 @@
     def __init__(self, argv):
         self.argv = argv
         
+    def launchServer(self):
+        &quot;&quot;&quot;Launch a PLearn server&quot;&quot;&quot;
+        self.launch(wait= False)
+        Task.getLaunchedServerInfo(self.process.fromchild)
+
     def launch(self, wait=False):
         &quot;&quot;&quot;Launch process on an available machine&quot;&quot;&quot;
         try:
@@ -223,13 +268,14 @@
                 self.logfile.write( task_signature )
 
             logging.info(task_signature)            
+            self._child_processes[ self.process.fromchild ] = self
             if wait:
                 logging.debug(
                     &quot;* TaskType.launch() waits for process (id=%d)&quot;%self.process.pid )
                 self.process.wait( )
                 self.free()
             else:
-                self._child_processes[ self.process.fromchild ] = self
+                #self._child_processes[ self.process.fromchild ] = self
                 logging.debug( &quot;* children %d (%d)&quot;
                                %(self.process.pid,len(self._child_processes)) )
                 
@@ -245,6 +291,7 @@
     def free(self):
         if hasattr(self, 'process'):
             logging.debug(&quot;* Freeing task with pid=%d&quot;%self.process.pid)
+
             Self = self.__class__._child_processes.pop(self.process.fromchild)
             assert Self == self
         
@@ -259,6 +306,7 @@
     _machines = get_ssh_machines()
     _loadavg  = {}
     _available_machines = None
+    _max_load= 1.0
     
     def getLoadAvg(cls, machine):
         #print &quot;\nQuery to&quot;, machine
@@ -282,7 +330,7 @@
     def listAvailableMachines(cls):
         for m in cls._machines:
             loadavg = cls.getLoadAvg(m)
-            max_loadavg = MAX_LOADAVG.get(m, 1.0)
+            max_loadavg = MAX_LOADAVG.get(m, cls._max_load)
             #print &quot;Load %f / %f&quot;%(loadavg, max_loadavg)
             if loadavg &lt; max_loadavg:
                 # Register the load average *plus* one, taking in account

Modified: trunk/python_modules/plearn/parallel/utils.py
===================================================================
--- trunk/python_modules/plearn/parallel/utils.py	2007-02-21 15:49:27 UTC (rev 6675)
+++ trunk/python_modules/plearn/parallel/utils.py	2007-02-22 21:05:50 UTC (rev 6676)
@@ -37,7 +37,7 @@
     if len(s) &lt; length:
         return s
     else:
-        return s[:length] + etc
+        return s[:length] #+ etc
     
 def string_replace(s,c,ch=''):
     &quot;&quot;&quot;Remove any occurrences of characters in c, from string s

Modified: trunk/python_modules/plearn/utilities/progress.py
===================================================================
--- trunk/python_modules/plearn/utilities/progress.py	2007-02-21 15:49:27 UTC (rev 6675)
+++ trunk/python_modules/plearn/utilities/progress.py	2007-02-22 21:05:50 UTC (rev 6676)
@@ -50,5 +50,29 @@
             self.pos = pos
             
 
+class LineOutputProgressBar(StdoutProgressBar):
+    
+    def __init__(self, title, n):
+        self.n = n
+        self.pos = 0
+        self.title = title
+        self.closed = False
+        titlestr = ' '+title+' ('+str(n)+') '
+        StdoutProgressBar.write('In progress: '+titlestr+'\n')
+            
+    def update(self, pos):
+        if not self.closed:
+            npoints = StdoutProgressBar.npoints
+            oldcharpos = min(npoints, int(self.pos*npoints/(self.n-1)))
+            newcharpos = min(npoints, int(pos*npoints/(self.n-1)))
+            nchars = newcharpos-oldcharpos
+            if nchars&gt;0:
+                StdoutProgressBar.write(self.title + ': ' + str(pos) + '/' + str(self.n)
+                                        + '(' + str(float(pos)*100./float(self.n)) +'%)\n')
+            if pos&gt;=self.n-1:
+                StdoutProgressBar.write('Finished '+self.title+': '+str(pos)+'/'+str(self.n)+' (100%)\n')
+                self.closed = True
+            self.pos = pos
+
 PBar = StdoutProgressBar
 

Added: trunk/scripts/xdispatch
===================================================================
--- trunk/scripts/xdispatch	2007-02-21 15:49:27 UTC (rev 6675)
+++ trunk/scripts/xdispatch	2007-02-22 21:05:50 UTC (rev 6676)
@@ -0,0 +1,80 @@
+#!/usr/bin/python2.3
+#
+# xdispatch: dispatch utility for parallel PLearn
+#
+# Copyright 2007, Apstat Technologies, inc.
+# All rights reserved.
+
+from optparse import OptionParser
+from plearn.parallel.dispatch import *
+import tempfile
+import os
+import time
+
+#
+# Main
+#
+
+def main():
+    parser = OptionParser()
+    parser.add_option('-n', '--num-available-machines',
+                      help='Prints the number of available machines',
+                      action='store_true', default=False)
+
+    parser.add_option('-l', '--max-load', type= &quot;float&quot;,
+                      dest= &quot;max_load&quot;,
+                      help='Sets the default maximum load',
+                      default=2.0)
+
+    parser.add_option('-s', '--nb-servers', type=&quot;int&quot;,
+                      dest= &quot;nb_servers&quot;,
+                      help='Number of servers to launch (maximum)',
+                      default=1)
+
+    parser.add_option('-m', '--min-nb-servers', type=&quot;int&quot;,
+                      dest= &quot;min-nb_servers&quot;,
+                      help='Number of servers to launch (minimum)',
+                      default=1)
+
+    
+    (options, args) = parser.parse_args()
+
+    #print options
+    #print &quot;===&quot;
+    #print args
+
+    set_logdir('/home/saintmlx/xdispatch-log/')
+
+    Task._max_load= options.max_load
+
+    #xdispatch -l 3.0 -s 25 inslearn exp.pyplearn
+    #25x -&gt; ssh distant_machine inslearn server 0
+    #1x  -&gt; inslearn --servers serv_file exp.pyplearn
+
+    if options.num_available_machines:
+        print Task.availableMachinesCount()
+    elif args:
+        try:
+            plearn_command= args[0]
+            for i in xrange(options.nb_servers):
+                #launch_server( ['time',plearn_command, '--verbosity 999', 'server', '0'] )
+                launch_server( ['time',plearn_command, 'server', '0'] )
+
+            tf, fname= tempfile.mkstemp(suffix= '.plserv', prefix= '.plserv_', dir= '/tmp/')
+
+            for si in Task.getLaunchedServersInfo():
+                print si
+                os.write(tf, &quot;%s %d %d\n&quot;%si)
+            os.close(tf)
+
+            print &quot;Servers listed in: &quot;, fname
+            cmd= plearn_command + ' --servers ' + fname + ' ' + ' '.join(args[1:])
+            print cmd
+
+            os.system(cmd)
+
+        finally:
+            Task.kill_all_tasks()
+
+if __name__ == '__main__':
+    main()


Property changes on: trunk/scripts/xdispatch
___________________________________________________________________
Name: svn:executable
   + *


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000124.html">[Plearn-commits] r6675 - in trunk: plearn/var	plearn_learners/regressors
</A></li>
	<LI>Next message: <A HREF="000126.html">[Plearn-commits] r6677 - trunk/plearn/misc
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#125">[ date ]</a>
              <a href="thread.html#125">[ thread ]</a>
              <a href="subject.html#125">[ subject ]</a>
              <a href="author.html#125">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/plearn-commits">More information about the Plearn-commits
mailing list</a><br>
</body></html>
