<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Plearn-commits] r7741 - trunk/plearn/io
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/plearn-commits/2007-July/index.html" >
   <LINK REL="made" HREF="mailto:plearn-commits%40lists.berlios.de?Subject=Re%3A%20%5BPlearn-commits%5D%20r7741%20-%20trunk/plearn/io&In-Reply-To=%3C200707102209.l6AM9B1O029954%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001188.html">
   <LINK REL="Next"  HREF="001190.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Plearn-commits] r7741 - trunk/plearn/io</H1>
    <B>lamblin at BerliOS</B> 
    <A HREF="mailto:plearn-commits%40lists.berlios.de?Subject=Re%3A%20%5BPlearn-commits%5D%20r7741%20-%20trunk/plearn/io&In-Reply-To=%3C200707102209.l6AM9B1O029954%40sheep.berlios.de%3E"
       TITLE="[Plearn-commits] r7741 - trunk/plearn/io">lamblin at mail.berlios.de
       </A><BR>
    <I>Wed Jul 11 00:09:11 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="001188.html">[Plearn-commits] r7740 - trunk/plearn_learners_experimental
</A></li>
        <LI>Next message: <A HREF="001190.html">[Plearn-commits] r7742 - trunk/python_modules/plearn/pymake
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1189">[ date ]</a>
              <a href="thread.html#1189">[ thread ]</a>
              <a href="subject.html#1189">[ subject ]</a>
              <a href="author.html#1189">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: lamblin
Date: 2007-07-11 00:09:10 +0200 (Wed, 11 Jul 2007)
New Revision: 7741

Modified:
   trunk/plearn/io/PStream.cc
   trunk/plearn/io/PStream.h
Log:
Minor cosmetic changes


Modified: trunk/plearn/io/PStream.cc
===================================================================
--- trunk/plearn/io/PStream.cc	2007-07-10 16:40:25 UTC (rev 7740)
+++ trunk/plearn/io/PStream.cc	2007-07-10 22:09:10 UTC (rev 7741)
@@ -8,18 +8,18 @@
 //
 // Redistribution and use in source and binary forms, with or without
 // modification, are permitted provided that the following conditions are met:
-// 
+//
 //  1. Redistributions of source code must retain the above copyright
 //     notice, this list of conditions and the following disclaimer.
-// 
+//
 //  2. Redistributions in binary form must reproduce the above copyright
 //     notice, this list of conditions and the following disclaimer in the
 //     documentation and/or other materials provided with the distribution.
-// 
+//
 //  3. The name of the authors may not be used to endorse or promote
 //     products derived from this software without specific prior written
 //     permission.
-// 
+//
 // THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
 // IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 // OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
@@ -30,7 +30,7 @@
 // LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-// 
+//
 // This file is part of the PLearn library. For more information on the PLearn
 // library, go to the PLearn Web site at www.plearn.org
 
@@ -61,7 +61,7 @@
 PStream&amp; get_pnull()
 {
     static PStream pnull = new NullPStreamBuf();
-    return pnull;    
+    return pnull;
 }
 
 PStream pnull = get_pnull();
@@ -174,8 +174,8 @@
 
 PStream::PStream()
     :inherited(0),
-     inmode(plearn_ascii), 
-     outmode(plearn_ascii), 
+     inmode(plearn_ascii),
+     outmode(plearn_ascii),
      format_float (format_float_default),
      format_double(format_double_default),
      implicit_storage(true),
@@ -185,8 +185,8 @@
 
 PStream::PStream(streambuftype* sb)
     :inherited(sb),
-     inmode(plearn_ascii), 
-     outmode(plearn_ascii), 
+     inmode(plearn_ascii),
+     outmode(plearn_ascii),
      format_float (format_float_default),
      format_double(format_double_default),
      implicit_storage(true),
@@ -198,7 +198,7 @@
 //! ctor. from an istream (I)
 PStream::PStream(istream* pin_, bool own_pin_)
     :inherited(new StdPStreamBuf(pin_,own_pin_)),
-     inmode(plearn_ascii), 
+     inmode(plearn_ascii),
      outmode(plearn_ascii),
      format_float (format_float_default),
      format_double(format_double_default),
@@ -210,7 +210,7 @@
 
 PStream::PStream(ostream* pout_, bool own_pout_)
     :inherited(new StdPStreamBuf(pout_,own_pout_)),
-     inmode(plearn_ascii), 
+     inmode(plearn_ascii),
      outmode(plearn_ascii),
      format_float (format_float_default),
      format_double(format_double_default),
@@ -222,7 +222,7 @@
 //! ctor. from an iostream (IO)
 PStream::PStream(iostream* pios_, bool own_pios_)
     :inherited(new StdPStreamBuf(pios_,own_pios_)),
-     inmode(plearn_ascii), 
+     inmode(plearn_ascii),
      outmode(plearn_ascii),
      format_float (format_float_default),
      format_double(format_double_default),
@@ -234,7 +234,7 @@
 //! ctor. from an istream and an ostream (IO)
 PStream::PStream(istream* pin_, ostream* pout_, bool own_pin_, bool own_pout_)
     :inherited(new StdPStreamBuf(pin_,pout_,own_pin_,own_pout_)),
-     inmode(plearn_ascii), 
+     inmode(plearn_ascii),
      outmode(plearn_ascii),
      format_float (format_float_default),
      format_double(format_double_default),
@@ -247,8 +247,8 @@
 PStream::~PStream()
 { }
 
-PStream::mode_t PStream::switchToPLearnOutMode() 
-{ 
+PStream::mode_t PStream::switchToPLearnOutMode()
+{
     mode_t oldmode = outmode;
     switch(outmode)
     {
@@ -290,7 +290,7 @@
 
 void PStream::readExpected(char expect)
 {
-    int c = get(); 
+    int c = get();
     if(c!=expect)
         PLERROR(&quot;In readExpected : expected %c, but read %c&quot;,expect,c);
 }
@@ -298,7 +298,7 @@
 void PStream::readExpected(char* expect)
 {
     for(char c = *expect; c!=0; c=*expect++)
-        readExpected(c);    
+        readExpected(c);
 }
 
 void PStream::readExpected(const string&amp; expect)
@@ -308,13 +308,13 @@
         readExpected(expect[i]);
 }
 
-  
+
 streamsize PStream::readUntil(char* buf, streamsize n, char stop_char)
 {
     streamsize nread = 0;
 
     while(nread&lt;n)
-    {        
+    {
         int c = get();
         if(c==EOF)
             break;
@@ -335,7 +335,7 @@
     streamsize nread = 0;
 
     while(nread&lt;n)
-    {        
+    {
         int c = get();
         if(c==EOF)
             break;
@@ -365,28 +365,28 @@
             if(characters_read.length() == characters_read.capacity())
                 characters_read.reserve(characters_read.length()*2); //don't realloc&amp;copy every time a char is appended...
             characters_read+= static_cast&lt;char&gt;(c);
-          
+
             switch(c)
             {
             case '(':
                 smartReadUntilNext(&quot;)&quot;, characters_read, ignore_brackets, skip_comments);
-                characters_read+= ')';          
+                characters_read+= ')';
                 break;
             case '[':
                 if(!ignore_brackets)
                 {
                     smartReadUntilNext(&quot;]&quot;, characters_read, ignore_brackets, skip_comments);
-                    characters_read+= ']';          
+                    characters_read+= ']';
                 }
                 break;
             case '{':
                 smartReadUntilNext(&quot;}&quot;, characters_read, ignore_brackets, skip_comments);
-                characters_read+= '}';          
+                characters_read+= '}';
                 break;
             case '&quot;':
                 smartReadUntilNext(&quot;\&quot;&quot;, characters_read, ignore_brackets, false);
-                characters_read+= '&quot;';          
-                break;          
+                characters_read+= '&quot;';
+                break;
             }
         }
     }
@@ -424,9 +424,9 @@
 {
     int c = get();
     while(c!=EOF)
-    { 
+    {
         if(c=='#')
-            skipRestOfLine();     
+            skipRestOfLine();
         else if(c!=' ' &amp;&amp; c!='\t' &amp;&amp; c!='\n' &amp;&amp; c!='\r')
             break;
         c = get();
@@ -439,9 +439,9 @@
 {
     int c = get();
     while(c!=EOF)
-    { 
+    {
         if(c=='#')
-            skipRestOfLine();     
+            skipRestOfLine();
         else if(c!=' ' &amp;&amp; c!='\t' &amp;&amp; c!='\n' &amp;&amp; c!='\r' &amp;&amp; c!=';' &amp;&amp; c!=',')
             break;
         c = get();
@@ -533,7 +533,7 @@
     if(x&gt;=zero)
         writeAsciiNum((unsigned long long)x);
     else
-    {        
+    {
         put('-');
         writeAsciiNum((unsigned long long) -x);
     }
@@ -656,7 +656,7 @@
     }
     else if (c == '+')
         c = get();
-  
+
     if(!isdigit(c))
         PLERROR(&quot;In readAsciiNum: not a valid ascii number, expected a digit, but read %c (ascii code %d)&quot;,c,c);
 
@@ -697,7 +697,7 @@
     }
     else if (c == '+')
         c = get();
-  
+
     if(!isdigit(c))
         PLERROR(&quot;In readAsciiNum: not a valid ascii number, expected a digit, but read %c (ascii code %d)&quot;,c,c);
 
@@ -740,7 +740,7 @@
     skipBlanks();
     int l=0;
     bool opposite = false;
-  
+
     char c = get();
     if (c == '-') {
         tmpbuf[l++] = c;
@@ -776,11 +776,11 @@
         }
         else
             PLERROR(error_msg);
-        break ; 
+        break ;
     default:
-        while(isdigit(c) 
+        while(isdigit(c)
               || ((c=='e' || c=='E') &amp;&amp; !E_seen) //only one E
-              || ((c=='-' || c=='+') &amp;&amp; E_seen &amp;&amp; !sign_seen)//one sign, after E 
+              || ((c=='-' || c=='+') &amp;&amp; E_seen &amp;&amp; !sign_seen)//one sign, after E
               || (c=='.' &amp;&amp; !E_seen &amp;&amp; !dot_seen))//one dot, before E
         {
             if(c=='e' || c=='E') E_seen= true;
@@ -797,7 +797,7 @@
 }
 
 PStream&amp; PStream::operator=(const PStream&amp; pios)
-{ 
+{
     if(this != &amp;pios)
     {
         inherited::operator=((const inherited&amp;)pios);
@@ -841,7 +841,7 @@
     }
     return *this;
 }
- 
+
 PStream&amp; PStream::operator&gt;&gt;(signed char &amp;x)
 {
     char c;
@@ -1008,7 +1008,7 @@
     break;
     case PStream::plearn_ascii:
     case PStream::plearn_binary:
-    { 
+    {
         skipBlanksAndComments();
         int c = peek();
         if(c=='&quot;') // it's a quoted string &quot;...&quot;
@@ -1021,7 +1021,7 @@
                 if(c=='\\') // escaped character
                 {
                     c = get();
-                    switch (c)             
+                    switch (c)
                     {
                     case 'n':
                         x += '\n';
@@ -1066,7 +1066,7 @@
         }
         else // it's a single word without quotes
         {
-            x.resize(0);      
+            x.resize(0);
             c= get();
             while(c != EOF &amp;&amp; wordseparators().find(c)==string::npos) // as long as we don't meet a wordseparator (or eof)...
             {
@@ -1105,7 +1105,7 @@
         if(c==0x07 || c==0x08 || c==0x0B || c==0x0C )  // plearn_binary
         {
             read(reinterpret_cast&lt;char*&gt;(&amp;x),sizeof(int));
-            if( (c==0x07 &amp;&amp; byte_order()==BIG_ENDIAN_ORDER) 
+            if( (c==0x07 &amp;&amp; byte_order()==BIG_ENDIAN_ORDER)
                 || (c==0x08 &amp;&amp; byte_order()==LITTLE_ENDIAN_ORDER) )
                 endianswap(&amp;x);
         }
@@ -1143,7 +1143,7 @@
         if(c==0x0B || c==0x0C || c==0x07 || c==0x08)  // plearn_binary unsigned int or int
         {
             read(reinterpret_cast&lt;char*&gt;(&amp;x),sizeof(unsigned int));
-            if( (c==0x0B &amp;&amp; byte_order()==BIG_ENDIAN_ORDER) 
+            if( (c==0x0B &amp;&amp; byte_order()==BIG_ENDIAN_ORDER)
                 || (c==0x0C &amp;&amp; byte_order()==LITTLE_ENDIAN_ORDER) )
                 endianswap(&amp;x);
         }
@@ -1182,14 +1182,14 @@
         if(c==0x07 || c==0x08)  // plearn_binary
         {
             read(reinterpret_cast&lt;char*&gt;(&amp;x),sizeof(long));
-            if( (c==0x07 &amp;&amp; byte_order()==BIG_ENDIAN_ORDER) 
+            if( (c==0x07 &amp;&amp; byte_order()==BIG_ENDIAN_ORDER)
                 || (c==0x08 &amp;&amp; byte_order()==LITTLE_ENDIAN_ORDER) )
                 endianswap(&amp;x);
         }
         else if(c==0x16 || c==0x17)  // plearn_binary
         {
             read(reinterpret_cast&lt;char*&gt;(&amp;x),sizeof(long));
-            if( (c==0x16 &amp;&amp; byte_order()==BIG_ENDIAN_ORDER) 
+            if( (c==0x16 &amp;&amp; byte_order()==BIG_ENDIAN_ORDER)
                 || (c==0x17 &amp;&amp; byte_order()==LITTLE_ENDIAN_ORDER) )
                 endianswap(&amp;x);
         }
@@ -1229,7 +1229,7 @@
         {
             int32_t y;
             read(reinterpret_cast&lt;char*&gt;(&amp;y),sizeof(int32_t));
-            if( (c==0x07 &amp;&amp; byte_order()==BIG_ENDIAN_ORDER) 
+            if( (c==0x07 &amp;&amp; byte_order()==BIG_ENDIAN_ORDER)
                 || (c==0x08 &amp;&amp; byte_order()==LITTLE_ENDIAN_ORDER) )
                 endianswap(&amp;y);
             x = y;
@@ -1237,7 +1237,7 @@
         else if(c==0x16 || c==0x17)  // plearn_binary 64 bits integer
         {
             read(reinterpret_cast&lt;char*&gt;(&amp;x),sizeof(int64_t));
-            if( (c==0x16 &amp;&amp; byte_order()==BIG_ENDIAN_ORDER) 
+            if( (c==0x16 &amp;&amp; byte_order()==BIG_ENDIAN_ORDER)
                 || (c==0x17 &amp;&amp; byte_order()==LITTLE_ENDIAN_ORDER) )
                 endianswap(&amp;x);
         }
@@ -1276,7 +1276,7 @@
         if(c==0x0B || c==0x0C)  // plearn_binary
         {
             read(reinterpret_cast&lt;char*&gt;(&amp;x),sizeof(unsigned long));
-            if( (c==0x0B &amp;&amp; byte_order()==BIG_ENDIAN_ORDER) 
+            if( (c==0x0B &amp;&amp; byte_order()==BIG_ENDIAN_ORDER)
                 || (c==0x0C &amp;&amp; byte_order()==LITTLE_ENDIAN_ORDER) )
                 endianswap(&amp;x);
         }
@@ -1316,7 +1316,7 @@
         {
             uint32_t y;
             read(reinterpret_cast&lt;char*&gt;(&amp;y),sizeof(uint32_t));
-            if( (c==0x0B &amp;&amp; byte_order()==BIG_ENDIAN_ORDER) 
+            if( (c==0x0B &amp;&amp; byte_order()==BIG_ENDIAN_ORDER)
                 || (c==0x0C &amp;&amp; byte_order()==LITTLE_ENDIAN_ORDER) )
                 endianswap(&amp;y);
             x = y;
@@ -1363,7 +1363,7 @@
         if(c==0x16 || c==0x17)  // plearn_binary
         {
             read(reinterpret_cast&lt;char*&gt;(&amp;x),sizeof(long long));
-            if( (c==0x16 &amp;&amp; byte_order()==BIG_ENDIAN_ORDER) 
+            if( (c==0x16 &amp;&amp; byte_order()==BIG_ENDIAN_ORDER)
                 || (c==0x17 &amp;&amp; byte_order()==LITTLE_ENDIAN_ORDER) )
                 endianswap(&amp;x);
         }
@@ -1380,7 +1380,7 @@
     }
     return *this;
 }
-  
+
 PStream&amp; PStream::operator&gt;&gt;(unsigned long long &amp;x)
 {
     switch(inmode)
@@ -1401,7 +1401,7 @@
         if(c==0x18 || c==0x19)  // plearn_binary
         {
             read(reinterpret_cast&lt;char*&gt;(&amp;x),sizeof(unsigned long long));
-            if( (c==0x18 &amp;&amp; byte_order()==BIG_ENDIAN_ORDER) 
+            if( (c==0x18 &amp;&amp; byte_order()==BIG_ENDIAN_ORDER)
                 || (c==0x19 &amp;&amp; byte_order()==LITTLE_ENDIAN_ORDER) )
                 endianswap(&amp;x);
         }
@@ -1440,7 +1440,7 @@
         if(c==0x03 || c==0x04)  // plearn_binary
         {
             read(reinterpret_cast&lt;char*&gt;(&amp;x),sizeof(short));
-            if( (c==0x03 &amp;&amp; byte_order()==BIG_ENDIAN_ORDER) 
+            if( (c==0x03 &amp;&amp; byte_order()==BIG_ENDIAN_ORDER)
                 || (c==0x04 &amp;&amp; byte_order()==LITTLE_ENDIAN_ORDER) )
                 endianswap(&amp;x);
         }
@@ -1457,7 +1457,7 @@
     }
     return *this;
 }
-  
+
 PStream&amp; PStream::operator&gt;&gt;(unsigned short &amp;x)
 {
     switch(inmode)
@@ -1478,7 +1478,7 @@
         if(c==0x05 || c==0x06)  // plearn_binary
         {
             read(reinterpret_cast&lt;char*&gt;(&amp;x),sizeof(unsigned short));
-            if( (c==0x05 &amp;&amp; byte_order()==BIG_ENDIAN_ORDER) 
+            if( (c==0x05 &amp;&amp; byte_order()==BIG_ENDIAN_ORDER)
                 || (c==0x06 &amp;&amp; byte_order()==LITTLE_ENDIAN_ORDER) )
                 endianswap(&amp;x);
         }
@@ -1518,18 +1518,18 @@
 
         else if(c=='T')
         {
-            char r = get();        
-            char u = get();        
+            char r = get();
+            char u = get();
             char e = get();
             if ( r == 'r' &amp;&amp; u == 'u' &amp;&amp; e == 'e' )
                 parsed = 1;
         }
-      
+
         else if(c=='F')
         {
-            char a = get();        
+            char a = get();
             char l = get();
-            char s = get();        
+            char s = get();
             char e = get();
             if ( a == 'a' &amp;&amp; l == 'l' &amp;&amp; s == 's' &amp;&amp; e == 'e' )
                 parsed = 0;
@@ -1569,7 +1569,7 @@
         if(c==0x0E || c==0x0F)  // plearn_binary
         {
             read(reinterpret_cast&lt;char*&gt;(&amp;x),sizeof(float));
-            if( (c==0x0E &amp;&amp; byte_order()==BIG_ENDIAN_ORDER) 
+            if( (c==0x0E &amp;&amp; byte_order()==BIG_ENDIAN_ORDER)
                 || (c==0x0F &amp;&amp; byte_order()==LITTLE_ENDIAN_ORDER) )
                 endianswap(&amp;x);
         }
@@ -1607,7 +1607,7 @@
         if(c==0x10 || c==0x11)  // plearn_binary
         {
             read(reinterpret_cast&lt;char*&gt;(&amp;x),sizeof(double));
-            if( (c==0x10 &amp;&amp; byte_order()==BIG_ENDIAN_ORDER) 
+            if( (c==0x10 &amp;&amp; byte_order()==BIG_ENDIAN_ORDER)
                 || (c==0x11 &amp;&amp; byte_order()==LITTLE_ENDIAN_ORDER) )
                 endianswap(&amp;x);
         }
@@ -1628,8 +1628,8 @@
 
 // Implementation of operator&lt;&lt;'s
 
-PStream&amp; PStream::operator&lt;&lt;(char x) 
-{ 
+PStream&amp; PStream::operator&lt;&lt;(char x)
+{
     switch(outmode)
     {
     case raw_ascii:
@@ -1654,14 +1654,14 @@
     return *this;
 }
 
-PStream&amp; PStream::operator&lt;&lt;(signed char x) 
+PStream&amp; PStream::operator&lt;&lt;(signed char x)
 {
     operator&lt;&lt;(char(x));
     return *this;
 }
 
-PStream&amp; PStream::operator&lt;&lt;(unsigned char x) 
-{ 
+PStream&amp; PStream::operator&lt;&lt;(unsigned char x)
+{
     switch(outmode)
     {
     case raw_ascii:
@@ -1698,7 +1698,7 @@
     case PStream::pretty_ascii:
     case PStream::raw_binary:
         write(x);
-        break;      
+        break;
 
     case PStream::plearn_ascii:
     case PStream::plearn_binary:
@@ -1755,8 +1755,8 @@
     return *this;
 }
 
-PStream&amp; PStream::operator&lt;&lt;(bool x) 
-{ 
+PStream&amp; PStream::operator&lt;&lt;(bool x)
+{
     switch(outmode)
     {
     case plearn_ascii:
@@ -1774,7 +1774,7 @@
             put('1');
         else
             put('0');
-        break;    
+        break;
     default:
         PLERROR(&quot;In PStream::operator&lt;&lt;  unknown outmode!!!!!!!!!&quot;);
         break;
@@ -1782,8 +1782,8 @@
     return *this;
 }
 
-PStream&amp; PStream::operator&lt;&lt;(int x) 
-{ 
+PStream&amp; PStream::operator&lt;&lt;(int x)
+{
     switch(outmode)
     {
     case raw_binary:
@@ -1812,8 +1812,8 @@
     return *this;
 }
 
-PStream&amp; PStream::operator&lt;&lt;(unsigned int x) 
-{ 
+PStream&amp; PStream::operator&lt;&lt;(unsigned int x)
+{
     switch(outmode)
     {
     case raw_binary:
@@ -1843,8 +1843,8 @@
 }
 
 /* Commented out because &quot;long&quot; has not the same size on every platform
-PStream&amp; PStream::operator&lt;&lt;(long x) 
-{ 
+PStream&amp; PStream::operator&lt;&lt;(long x)
+{
     switch(outmode)
     {
     case raw_binary:
@@ -1883,7 +1883,7 @@
     }
     return *this;
 }
-//*/
+*/
 
 PStream&amp; PStream::operator&lt;&lt;(int64_t x)
 {
@@ -1916,8 +1916,8 @@
 }
 
 /*
-PStream&amp; PStream::operator&lt;&lt;(unsigned long x) 
-{ 
+PStream&amp; PStream::operator&lt;&lt;(unsigned long x)
+{
     switch(outmode)
     {
     case raw_binary:
@@ -1945,7 +1945,7 @@
     }
     return *this;
 }
-//*/
+*/
 
 PStream&amp; PStream::operator&lt;&lt;(uint64_t x)
 {
@@ -1978,8 +1978,8 @@
 }
 
 /*
-PStream&amp; PStream::operator&lt;&lt;(long long x) 
-{ 
+PStream&amp; PStream::operator&lt;&lt;(long long x)
+{
     switch(outmode)
     {
     case raw_binary:
@@ -2008,8 +2008,8 @@
     return *this;
 }
 
-PStream&amp; PStream::operator&lt;&lt;(unsigned long long x) 
-{ 
+PStream&amp; PStream::operator&lt;&lt;(unsigned long long x)
+{
     switch(outmode)
     {
     case raw_binary:
@@ -2039,8 +2039,8 @@
 }
 */
 
-PStream&amp; PStream::operator&lt;&lt;(short x) 
-{ 
+PStream&amp; PStream::operator&lt;&lt;(short x)
+{
     switch(outmode)
     {
     case raw_binary:
@@ -2069,8 +2069,8 @@
     return *this;
 }
 
-PStream&amp; PStream::operator&lt;&lt;(unsigned short x) 
-{ 
+PStream&amp; PStream::operator&lt;&lt;(unsigned short x)
+{
     switch(outmode)
     {
     case raw_binary:
@@ -2160,11 +2160,11 @@
 }
 
 
-void binread_(PStream&amp; in, bool* x,                
-              unsigned int n, unsigned char typecode)  
-{                                                      
-    if(typecode!=TypeTraits&lt;bool&gt;::little_endian_typecode()) 
-        PLERROR(&quot;In binread_ incompatible typecode&quot;);      
+void binread_(PStream&amp; in, bool* x,
+              unsigned int n, unsigned char typecode)
+{
+    if(typecode!=TypeTraits&lt;bool&gt;::little_endian_typecode())
+        PLERROR(&quot;In binread_ incompatible typecode&quot;);
 
     while(n--)
     {
@@ -2214,23 +2214,23 @@
 //! The binread_ for float and double are special
 
 void binread_(PStream&amp; in, double* x, unsigned int n, unsigned char typecode)
-{ 
+{
     if(typecode==TypeTraits&lt;double&gt;::little_endian_typecode())
     {
-        in.read((char*)x, streamsize(n*sizeof(double))); 
+        in.read((char*)x, streamsize(n*sizeof(double)));
 #ifdef BIGENDIAN
-        endianswap(x,n); 
-#endif      
+        endianswap(x,n);
+#endif
     }
     else if(typecode==TypeTraits&lt;double&gt;::big_endian_typecode())
     {
-        in.read((char*)x, streamsize(n*sizeof(double))); 
+        in.read((char*)x, streamsize(n*sizeof(double)));
 #ifdef LITTLEENDIAN
-        endianswap(x,n); 
+        endianswap(x,n);
 #endif
     }
     else if(typecode==TypeTraits&lt;float&gt;::little_endian_typecode())
-    {    
+    {
         float val;
         while(n--)
         {
@@ -2242,7 +2242,7 @@
         }
     }
     else if(typecode==TypeTraits&lt;float&gt;::big_endian_typecode())
-    {    
+    {
         float val;
         while(n--)
         {
@@ -2260,23 +2260,23 @@
 
 
 void binread_(PStream&amp; in, float* x, unsigned int n, unsigned char typecode)
-{ 
+{
     if(typecode==TypeTraits&lt;float&gt;::little_endian_typecode())
     {
-        in.read((char*)x, streamsize(n*sizeof(float))); 
+        in.read((char*)x, streamsize(n*sizeof(float)));
 #ifdef BIGENDIAN
-        endianswap(x,n); 
-#endif      
+        endianswap(x,n);
+#endif
     }
     else if(typecode==TypeTraits&lt;float&gt;::big_endian_typecode())
     {
-        in.read((char*)x, streamsize(n*sizeof(float))); 
+        in.read((char*)x, streamsize(n*sizeof(float)));
 #ifdef LITTLEENDIAN
-        endianswap(x,n); 
+        endianswap(x,n);
 #endif
     }
     else if(typecode==TypeTraits&lt;double&gt;::little_endian_typecode())
-    {    
+    {
         double val;
         while(n--)
         {
@@ -2288,7 +2288,7 @@
         }
     }
     else if(typecode==TypeTraits&lt;double&gt;::big_endian_typecode())
-    {    
+    {
         double val;
         while(n--)
         {

Modified: trunk/plearn/io/PStream.h
===================================================================
--- trunk/plearn/io/PStream.h	2007-07-10 16:40:25 UTC (rev 7740)
+++ trunk/plearn/io/PStream.h	2007-07-10 22:09:10 UTC (rev 7741)
@@ -1,5 +1,5 @@
 // -*- C++ -*-
- 
+
 // PStream.h
 // Copyright (C) 1998 Pascal Vincent
 // Copyright (C) 1999-2001 Pascal Vincent, Yoshua Bengio and University of Montreal
@@ -8,18 +8,18 @@
 //
 // Redistribution and use in source and binary forms, with or without
 // modification, are permitted provided that the following conditions are met:
-//   
+//
 //  1. Redistributions of source code must retain the above copyright
 //     notice, this list of conditions and the following disclaimer.
-// 
+//
 //  2. Redistributions in binary form must reproduce the above copyright
 //     notice, this list of conditions and the following disclaimer in the
 //     documentation and/or other materials provided with the distribution.
-// 
+//
 //  3. The name of the authors may not be used to endorse or promote
 //     products derived from this software without specific prior written
 //     permission.
-// 
+//
 // THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
 // IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 // OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
@@ -30,7 +30,7 @@
 // LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-// 
+//
 // This file is part of the PLearn library. For more information on the PLearn
 // library, go to the PLearn Web site at www.plearn.org
 
@@ -93,7 +93,7 @@
      *  format to write stuff.  On input however, they are equivalent, as the
      *  right format is automatically detected.
      */
-    enum mode_t 
+    enum mode_t
     {
         plearn_ascii,    //!&lt; PLearn ascii serialization format (can be mixed with plearn_binary)
         plearn_binary,   //!&lt; PLearn binary serialization format (can be mixed with plearn_ascii)
@@ -101,18 +101,18 @@
         raw_binary,      //!&lt; Simply writes the bytes as they are in memory.
         pretty_ascii     //!&lt; Ascii pretty print (in particular for Vec and Mat, formatted output without size info)
     };
-  
 
+
     //! Compression mode (mostly used by binary serialization of sequences of floats or doubles, such as TMat&lt;real&gt;)
     //! (Used on output only; autodetect on read).
-    enum compr_mode_t { 
+    enum compr_mode_t {
         compr_none,            //!&lt; No compression.
         compr_double_as_float, //!&lt; In plearn_binary mode, store doubles as float
-        compr_sparse,          //!&lt; PLearn 
-        compr_lossy_sparse     //!&lt; Also stores double as float 
+        compr_sparse,          //!&lt; PLearn
+        compr_lossy_sparse     //!&lt; Also stores double as float
     };
 
-public:  
+public:
     mode_t inmode;              //!&lt; mode for input formatting
     // bitset&lt;32&gt; pl_stream_flags_in;  //!&lt; format flags for input
     map&lt;unsigned int, void *&gt; copies_map_in; //!&lt; copies map for input
@@ -135,7 +135,7 @@
 
     //! Default format string for doubles
     static const char* format_double_default;
-    
+
 public:
     //! If true, then Mat and Vec will be serialized with their elements in place,
     //! If false, they will have an explicit pointer to a storage
@@ -144,12 +144,12 @@
     //! Determines the way data is compressed, if any.
     compr_mode_t compression_mode;
 
-    //! Should be true if this stream is used to communicate 
+    //! Should be true if this stream is used to communicate
     //! with a remote PLearn host.  Will serialize options
     //! accordingly.
     bool remote_plearn_comm;
 
-public:  
+public:
 
     PStream();
 
@@ -186,7 +186,7 @@
 
     //! if outmode is raw_ascii or raw_binary t will be switched to
     //! corresponding plearn_ascii, resp. plearn_binary.
-    //! The old mode will be returned, so that you can call setOutMode 
+    //! The old mode will be returned, so that you can call setOutMode
     //! to revert to the old mode when finished
     mode_t switchToPLearnOutMode();
 
@@ -235,7 +235,7 @@
     //! Writes the corresponding 2 hex digits (ex: 0A )
     void writeAsciiHexNum(unsigned char x);
 
-    inline bool eof() const 
+    inline bool eof() const
     { return ptr-&gt;eof(); }
 
     bool good() const
@@ -260,23 +260,23 @@
     const char* getDoubleFormat() const { return format_double; }
     void setFloatFormat(const char* f)  { format_float = f;  }
     void setDoubleFormat(const char* f) { format_double = f; }
-    
+
     /**
      * The folowing methods are 'forwarded' from {i|o}stream.
      */
-    inline int get() 
+    inline int get()
     { return ptr-&gt;get(); }
 
     //! The folowing methods are 'forwarded' from {i|o}stream.
-    inline PStream&amp; get(char&amp; c) 
-    { 
+    inline PStream&amp; get(char&amp; c)
+    {
         c = (char)ptr-&gt;get();
-        return *this; 
+        return *this;
     }
 
-    //! Delimitor is read from stream but not appended to string. 
+    //! Delimitor is read from stream but not appended to string.
     inline PStream&amp; getline(string&amp; line, char delimitor='\n')
-    { 
+    {
         line.clear();
         int c = get();
         while (c != EOF &amp;&amp; c != delimitor)
@@ -284,7 +284,7 @@
             line += (char)c;
             c = get();
         }
-        return *this; 
+        return *this;
     }
 
     inline string getline()
@@ -293,20 +293,20 @@
     //! The folowing methods are 'forwarded' from {i|o}stream.
     //! It read from the stream without advancing in it.
     //! I.E. Multiple successive peek() will return the same data.
-    inline int peek() 
+    inline int peek()
     { return ptr-&gt;peek(); }
-  
+
     //! If you put back the result of a call to get(), make sure it is not EOF.
-    inline PStream&amp; putback(char c) 
-    { 
+    inline PStream&amp; putback(char c)
+    {
         ptr-&gt;putback(c);
-        return *this; 
+        return *this;
     }
 
     //! Put back the last character read by the get() or read() methods.
     //! You can only call this method once (use the unread() method if you want
     //! to put back more than one character).
-    inline PStream&amp; unget() 
+    inline PStream&amp; unget()
     {
         ptr-&gt;unget();
         return *this;
@@ -325,13 +325,13 @@
     { return unread(s.data(), streamsize(s.length())); }
 
 
-    inline PStream&amp; read(char* s, streamsize n) 
-    { 
+    inline PStream&amp; read(char* s, streamsize n)
+    {
         ptr-&gt;read(s,n);
         return *this;
     }
 
-    inline PStream&amp; read(string&amp; s, streamsize n) 
+    inline PStream&amp; read(string&amp; s, streamsize n)
     {
         char* buf = new char[n];
         string::size_type nread = ptr-&gt;read(buf, n);
@@ -372,14 +372,14 @@
     //! The stopping character met is not extracted from the stream.
     streamsize readUntil(char* buf, streamsize n, const char* stop_chars);
 
-    inline PStream&amp; write(const char* s, streamsize n) 
-    { 
+    inline PStream&amp; write(const char* s, streamsize n)
+    {
         ptr-&gt;write(s,n);
-        return *this; 
+        return *this;
     }
 
-    inline PStream&amp; put(char c) 
-    { 
+    inline PStream&amp; put(char c)
+    {
         ptr-&gt;put(c);
         return *this;
     }
@@ -391,10 +391,10 @@
     }
     inline PStream&amp; put(int x) { return put((char)x); }
 
-    inline PStream&amp; flush() 
-    { 
+    inline PStream&amp; flush()
+    {
         ptr-&gt;flush();
-        return *this; 
+        return *this;
     }
 
     inline PStream&amp; endl()
@@ -405,16 +405,16 @@
     }
 
     // These are convenient method for writing raw strings (whatever the outmode):
-    inline PStream&amp; write(const char* s) 
-    { 
+    inline PStream&amp; write(const char* s)
+    {
         write(s, streamsize(strlen(s)));
-        return *this; 
+        return *this;
     }
 
-    inline PStream&amp; write(const string&amp; s) 
-    { 
+    inline PStream&amp; write(const string&amp; s)
+    {
         write(s.data(), streamsize(s.length()));
-        return *this; 
+        return *this;
     }
 
     // Useful skip functions
@@ -435,10 +435,10 @@
     void skipAll(const char* chars_to_skip);
 
     //! Reads characters from stream, until we meet one of the stopping symbols at the current &quot;level&quot;.
-    //! i.e. any opening parenthesis, bracket, brace or quote will open a next level and we'll 
-    //! be back to the current level only *after* we meet the corresponding closing parenthesis, 
+    //! i.e. any opening parenthesis, bracket, brace or quote will open a next level and we'll
+    //! be back to the current level only *after* we meet the corresponding closing parenthesis,
     //! bracket, brace or quote.
-    //! All characters read, except the stoppingsymbol, will be *appended* to characters_read 
+    //! All characters read, except the stoppingsymbol, will be *appended* to characters_read
     //! The stoppingsymbol is read and returned, but not appended to characters_read.
     //! Comments starting with # until the end of line may be skipped (as if they were not part of the stream)
     int smartReadUntilNext(const string&amp; stoppingsymbols, string&amp; characters_read,
@@ -453,7 +453,7 @@
     PStream&amp; operator&gt;&gt;(double &amp;x);
     PStream&amp; operator&gt;&gt;(string &amp;x);
     PStream&amp; operator&gt;&gt;(char* x); // read string in already allocated char[]
-    PStream&amp; operator&gt;&gt;(char &amp;x); 
+    PStream&amp; operator&gt;&gt;(char &amp;x);
     PStream&amp; operator&gt;&gt;(signed char &amp;x);
     PStream&amp; operator&gt;&gt;(unsigned char &amp;x);
     PStream&amp; operator&gt;&gt;(int &amp;x);
@@ -484,13 +484,13 @@
     //! (unless you're in raw_ascii or raw_binary mode!)
     PStream&amp; operator&lt;&lt;(const string &amp;x);
 
-    PStream&amp; operator&lt;&lt;(char x); 
+    PStream&amp; operator&lt;&lt;(char x);
     PStream&amp; operator&lt;&lt;(signed char x);
     PStream&amp; operator&lt;&lt;(unsigned char x);
 
     // Note: If you get mysterious mesages of problems with const bool resolutions,
     // then a workaround might be to not declare &lt;&lt;(bool) as a method, but as an inline function
-    PStream&amp; operator&lt;&lt;(bool x);  
+    PStream&amp; operator&lt;&lt;(bool x);
     PStream&amp; operator&lt;&lt;(int x);
     PStream&amp; operator&lt;&lt;(unsigned int x);
     //PStream&amp; operator&lt;&lt;(long x);
@@ -502,7 +502,7 @@
     PStream&amp; operator&lt;&lt;(short x);
     PStream&amp; operator&lt;&lt;(unsigned short x);
     PStream&amp; operator&lt;&lt;(pl_pstream_manip func) { return (*func)(*this); }
- 
+
 };
 
 /*! PStream objects to replace the standard cout, cin, ... */
@@ -534,12 +534,12 @@
 //!  after removing any trailing '\r' and/or '\n'
 string pgetline(PStream&amp; in);
 
-  
+
 /*****
  * op&gt;&gt; &amp; op&lt;&lt; for generic pointers
  */
 
-template &lt;class T&gt; 
+template &lt;class T&gt;
 inline PStream&amp; operator&gt;&gt;(PStream&amp; in, T*&amp; x)
 {
 
@@ -556,7 +556,7 @@
         else
         {
             in.skipBlanksAndCommentsAndSeparators();
-            if (in.peek() == '-') 
+            if (in.peek() == '-')
             {
                 in.get(); // Eat '-'
                 char cc = in.get();
@@ -571,8 +571,8 @@
                 //don't skip blanks before we need to read something else (read might block).
                 //in.skipBlanksAndCommentsAndSeparators();
                 in.copies_map_in[id]= x;
-            } 
-            else 
+            }
+            else
             {
                 // Find it in map and return ptr;
                 map&lt;unsigned int, void *&gt;::iterator it = in.copies_map_in.find(id);
@@ -582,25 +582,25 @@
                 x= static_cast&lt;T *&gt;(it-&gt;second);
             }
         }
-    } 
+    }
     else
     {
         in &gt;&gt; *x;
         //don't skip blanks before we need to read something else (read might block).
         //in.skipBlanksAndCommentsAndSeparators();
     }
-    
+
     return in;
 }
 
 
-template &lt;class T&gt; 
+template &lt;class T&gt;
 inline PStream&amp; operator&lt;&lt;(PStream&amp; out, T const * const &amp; x)
 {
     if(x)
     {
         map&lt;void *, unsigned int&gt;::iterator it = out.copies_map_out.find(const_cast&lt;T*&amp;&gt;(x));
-        if (it == out.copies_map_out.end()) 
+        if (it == out.copies_map_out.end())
         {
             int id = (int)out.copies_map_out.size()+1;
             out.put('*');
@@ -609,7 +609,7 @@
             out.copies_map_out[const_cast&lt;T*&amp;&gt;(x)] = id;
             out &lt;&lt; *x;
         }
-        else 
+        else
         {
             out.put('*');
             out &lt;&lt; it-&gt;second;
@@ -621,7 +621,7 @@
     return out;
 }
 
-template &lt;class T&gt; 
+template &lt;class T&gt;
 inline PStream&amp; operator&gt;&gt;(PStream&amp; in, PP&lt;T&gt; &amp;o)
 {
     T *ptr;
@@ -634,7 +634,7 @@
     return in;
 }
 
-template &lt;class T&gt; 
+template &lt;class T&gt;
 inline PStream&amp; operator&lt;&lt;(PStream&amp; out, const PP&lt;T&gt; &amp;o)
 {
     T *ptr = static_cast&lt;T *&gt;(o);
@@ -642,20 +642,20 @@
     return out;
 }
 
-template &lt;class T&gt; 
+template &lt;class T&gt;
 inline PStream&amp; operator&lt;&lt;(PStream&amp; out, T*&amp; ptr)
 {
     out &lt;&lt; const_cast&lt;T const * const &amp;&gt;(ptr);
     return out;
-}  
+}
 
 
-// Serialization of pairs in the form:   
+// Serialization of pairs in the form:
 // first : second
 
 template&lt;class A,class B&gt;
-inline PStream&amp; operator&lt;&lt;(PStream&amp; out, const pair&lt;A,B&gt;&amp; x) 
-{ 
+inline PStream&amp; operator&lt;&lt;(PStream&amp; out, const pair&lt;A,B&gt;&amp; x)
+{
     // new format (same as for tuple)
     out.put('(');
     out &lt;&lt; x.first;
@@ -687,9 +687,9 @@
     return out;
 }
 
-template &lt;typename S, typename T&gt; 
-inline PStream&amp; operator&gt;&gt;(PStream&amp; in, pair&lt;S, T&gt; &amp;x) 
-{ 
+template &lt;typename S, typename T&gt;
+inline PStream&amp; operator&gt;&gt;(PStream&amp; in, pair&lt;S, T&gt; &amp;x)
+{
     in.skipBlanksAndCommentsAndSeparators();
     int c = in.peek();
     if(c==0x16) // binary pair
@@ -724,7 +724,7 @@
 
 template&lt;class MapT&gt;
 void writeMap(PStream&amp; out, const MapT&amp; m)
-{  
+{
     typename MapT::const_iterator it = m.begin();
     typename MapT::const_iterator itend = m.end();
 
@@ -776,7 +776,7 @@
         in.skipBlanksAndCommentsAndSeparators();
         c = in.peek(); // do we have a '}' ?
     }
-    in.get(); // eat the '}'  
+    in.get(); // eat the '}'
 }
 
 template&lt;class Key, class Value, class Compare, class Alloc&gt;
@@ -828,7 +828,7 @@
         out &lt;&lt; *it;
         ++it;
     }
-    out.outmode = outmode; // restore previous outmode 
+    out.outmode = outmode; // restore previous outmode
 }
 
 inline void binwrite_(PStream&amp; out, const bool* x, unsigned int n)
@@ -842,71 +842,71 @@
     }
 }
 
-inline void binwrite_(PStream&amp; out, const char* x, unsigned int n) 
+inline void binwrite_(PStream&amp; out, const char* x, unsigned int n)
 { out.write((char*)x, streamsize(n*sizeof(char))); }
-inline void binwrite_(PStream&amp; out, char* x, unsigned int n) 
+inline void binwrite_(PStream&amp; out, char* x, unsigned int n)
 { out.write((char*)x, streamsize(n*sizeof(char))); }
 
-inline void binwrite_(PStream&amp; out, const signed char* x, unsigned int n) 
+inline void binwrite_(PStream&amp; out, const signed char* x, unsigned int n)
 { out.write((char*)x, streamsize(n*sizeof(signed char))); }
-inline void binwrite_(PStream&amp; out, signed char* x, unsigned int n) 
+inline void binwrite_(PStream&amp; out, signed char* x, unsigned int n)
 { out.write((char*)x, streamsize(n*sizeof(signed char))); }
 
-inline void binwrite_(PStream&amp; out, const unsigned char* x, unsigned int n) 
+inline void binwrite_(PStream&amp; out, const unsigned char* x, unsigned int n)
 { out.write((char*)x, streamsize(n*sizeof(unsigned char))); }
-inline void binwrite_(PStream&amp; out, unsigned char* x, unsigned int n) 
+inline void binwrite_(PStream&amp; out, unsigned char* x, unsigned int n)
 { out.write((char*)x, streamsize(n*sizeof(unsigned char))); }
 
-inline void binwrite_(PStream&amp; out, const short* x, unsigned int n) 
+inline void binwrite_(PStream&amp; out, const short* x, unsigned int n)
 { out.write((char*)x, streamsize(n*sizeof(short))); }
-inline void binwrite_(PStream&amp; out, short* x, unsigned int n) 
+inline void binwrite_(PStream&amp; out, short* x, unsigned int n)
 { out.write((char*)x, streamsize(n*sizeof(short))); }
 
-inline void binwrite_(PStream&amp; out, const unsigned short* x, unsigned int n) 
+inline void binwrite_(PStream&amp; out, const unsigned short* x, unsigned int n)
 { out.write((char*)x, streamsize(n*sizeof(unsigned short))); }
-inline void binwrite_(PStream&amp; out, unsigned short* x, unsigned int n) 
+inline void binwrite_(PStream&amp; out, unsigned short* x, unsigned int n)
 { out.write((char*)x, streamsize(n*sizeof(unsigned short))); }
 
-inline void binwrite_(PStream&amp; out, const int* x, unsigned int n) 
+inline void binwrite_(PStream&amp; out, const int* x, unsigned int n)
 { out.write((char*)x, streamsize(n*sizeof(int))); }
-inline void binwrite_(PStream&amp; out, int* x, unsigned int n) 
+inline void binwrite_(PStream&amp; out, int* x, unsigned int n)
 { out.write((char*)x, streamsize(n*sizeof(int))); }
 
-inline void binwrite_(PStream&amp; out, const unsigned int* x, unsigned int n) 
+inline void binwrite_(PStream&amp; out, const unsigned int* x, unsigned int n)
 { out.write((char*)x, streamsize(n*sizeof(unsigned int))); }
-inline void binwrite_(PStream&amp; out, unsigned int* x, unsigned int n) 
+inline void binwrite_(PStream&amp; out, unsigned int* x, unsigned int n)
 { out.write((char*)x, streamsize(n*sizeof(unsigned int))); }
 
 /*
-inline void binwrite_(PStream&amp; out, const long* x, unsigned int n) 
+inline void binwrite_(PStream&amp; out, const long* x, unsigned int n)
 { out.write((char*)x, streamsize(n*sizeof(long))); }
-inline void binwrite_(PStream&amp; out, long* x, unsigned int n) 
+inline void binwrite_(PStream&amp; out, long* x, unsigned int n)
 { out.write((char*)x, streamsize(n*sizeof(long))); }
 
-inline void binwrite_(PStream&amp; out, const unsigned long* x, unsigned int n) 
+inline void binwrite_(PStream&amp; out, const unsigned long* x, unsigned int n)
 { out.write((char*)x, streamsize(n*sizeof(unsigned long))); }
-inline void binwrite_(PStream&amp; out, unsigned long* x, unsigned int n) 
+inline void binwrite_(PStream&amp; out, unsigned long* x, unsigned int n)
 { out.write((char*)x, streamsize(n*sizeof(unsigned long))); }
 */
 
-inline void binwrite_(PStream&amp; out, const int64_t* x, unsigned int n) 
+inline void binwrite_(PStream&amp; out, const int64_t* x, unsigned int n)
 { out.write((char*)x, streamsize(n*sizeof(int64_t))); }
-inline void binwrite_(PStream&amp; out, int64_t* x, unsigned int n) 
+inline void binwrite_(PStream&amp; out, int64_t* x, unsigned int n)
 { out.write((char*)x, streamsize(n*sizeof(int64_t))); }
 
-inline void binwrite_(PStream&amp; out, const uint64_t* x, unsigned int n) 
+inline void binwrite_(PStream&amp; out, const uint64_t* x, unsigned int n)
 { out.write((char*)x, streamsize(n*sizeof(uint64_t))); }
-inline void binwrite_(PStream&amp; out, uint64_t* x, unsigned int n) 
+inline void binwrite_(PStream&amp; out, uint64_t* x, unsigned int n)
 { out.write((char*)x, streamsize(n*sizeof(uint64_t))); }
 
-inline void binwrite_(PStream&amp; out, const float* x, unsigned int n) 
+inline void binwrite_(PStream&amp; out, const float* x, unsigned int n)
 { out.write((char*)x, streamsize(n*sizeof(float))); }
-inline void binwrite_(PStream&amp; out, float* x, unsigned int n) 
+inline void binwrite_(PStream&amp; out, float* x, unsigned int n)
 { out.write((char*)x, streamsize(n*sizeof(float))); }
 
-inline void binwrite_(PStream&amp; out, const double* x, unsigned int n) 
+inline void binwrite_(PStream&amp; out, const double* x, unsigned int n)
 { out.write((char*)x, streamsize(n*sizeof(double))); }
-inline void binwrite_(PStream&amp; out, double* x, unsigned int n) 
+inline void binwrite_(PStream&amp; out, double* x, unsigned int n)
 { out.write((char*)x, streamsize(n*sizeof(double))); }
 
 // The typecode indicates the type and format of the elements in the stream
@@ -927,14 +927,14 @@
 void binread_(PStream&amp; in, bool* x, unsigned int n, unsigned char typecode);
 
 inline void binread_(PStream&amp; in, char* x,
-                     unsigned int n, unsigned char typecode)  
-{                                                      
+                     unsigned int n, unsigned char typecode)
+{
     // big endian and little endian have the same typecodes
     // so we need to check only one for consistency
 
     if(typecode!=TypeTraits&lt;char&gt;::little_endian_typecode()
-       &amp;&amp; typecode!=TypeTraits&lt;unsigned char&gt;::little_endian_typecode()) 
-        PLERROR(&quot;In binread_ incompatible typecode&quot;);      
+       &amp;&amp; typecode!=TypeTraits&lt;unsigned char&gt;::little_endian_typecode())
+        PLERROR(&quot;In binread_ incompatible typecode&quot;);
 
     in.read((char*)x, n);
 }
@@ -963,10 +963,10 @@
     // norman: added explicit cast
     unsigned int n = (unsigned int)seq.size();
     typename SequenceType::const_iterator it = seq.begin();
-  
+
     switch(out.outmode)
     {
-    case PStream::raw_ascii:      
+    case PStream::raw_ascii:
         while(n--)
         {
             out &lt;&lt; *it;
@@ -974,7 +974,7 @@
             ++it;
         }
         break;
-      
+
     case PStream::pretty_ascii:
         out.write(&quot;[ &quot;);
         while(n--)
@@ -987,7 +987,7 @@
         out.write(&quot; ] &quot;);
         break;
 
-    case PStream::raw_binary: 
+    case PStream::raw_binary:
         binwrite_(out, it, n);
         break;
 
@@ -1007,7 +1007,7 @@
         unsigned char typecode;
         if(byte_order()==LITTLE_ENDIAN_ORDER)
         {
-            out.put((char)0x12); // 1D little-endian 
+            out.put((char)0x12); // 1D little-endian
             typecode = TypeTraits&lt;typename SequenceType::value_type&gt;::little_endian_typecode();
         }
         else
@@ -1018,15 +1018,15 @@
 
         // write typecode
         out.put(typecode);
-        
-        // write length in raw_binary 
+
+        // write length in raw_binary
         out.write((char*)&amp;n, sizeof(n));
-        
+
         // write the data
         binwrite_(out, it, n);
     }
     break;
-      
+
     default:
         PLERROR(&quot;In PStream::writeSequence(Iterator&amp; it, int n)  unknown outmode!!!!!!!!!&quot;);
         break;
@@ -1036,7 +1036,7 @@
 
 //! Reads in a sequence type from a PStream.
 /*! For this to work with the current implementation, the SequenceType must have:
-  - typedefs defining (SequenceType::...) value_type, size_type, iterator 
+  - typedefs defining (SequenceType::...) value_type, size_type, iterator
   - a begin() method that returns a proper iterator,
   - a size_type size() method returning the size of the current container
   - a resize(size_type n) method that allows to change the size of the container
@@ -1056,7 +1056,7 @@
         while(n--)
         {
             in.skipBlanks();
-            in &gt;&gt; *it; 
+            in &gt;&gt; *it;
             //don't skip blanks before we need to read something else (read might block).
             //in.skipBlanks();
             ++it;
@@ -1069,7 +1069,7 @@
         typename SequenceType::iterator it = seq.begin();
         while(n--)
         {
-            in &gt;&gt; *it; 
+            in &gt;&gt; *it;
             ++it;
         }
     }
@@ -1130,11 +1130,11 @@
         else if(c==0x12 || c==0x13) // it's a generic binary 1D sequence
         {
             in.get(); // eat c
-            unsigned char typecode = in.get(); 
+            unsigned char typecode = in.get();
             unsigned int l;
             in.read((char*)&amp;l,sizeof(l));
 
-            bool inverted_byte_order = (    (c==0x12 &amp;&amp; byte_order()==BIG_ENDIAN_ORDER) 
+            bool inverted_byte_order = (    (c==0x12 &amp;&amp; byte_order()==BIG_ENDIAN_ORDER)
                                             || (c==0x13 &amp;&amp; byte_order()==LITTLE_ENDIAN_ORDER) );
 
             if(inverted_byte_order)
@@ -1151,28 +1151,28 @@
         PLERROR(&quot;In PStream::operator&gt;&gt;  unknown inmode!!!!!!!!!&quot;);
         break;
     }
-    
+
 }
 
 // Default behavior for write() and read() is
 // to call corresponding operator&lt;&lt;() or operator&gt;&gt;()
 // on PStream.
 
-template&lt;class T&gt; 
+template&lt;class T&gt;
 inline void write(ostream&amp; out_, const T&amp; o)
 {
     PStream out(&amp;out_);
     out &lt;&lt; o;
 }
 
-template&lt;class T&gt; 
+template&lt;class T&gt;
 inline void read(istream&amp; in_, T&amp; o)
 {
     PStream in(&amp;in_);
     in &gt;&gt; o;
 }
 
-template&lt;class T&gt; 
+template&lt;class T&gt;
 inline void read(const string&amp; stringval, T&amp; x)
 {
     istringstream in_(stringval);
@@ -1195,7 +1195,7 @@
 
 template&lt;class SetT&gt;
 void writeSet(PStream&amp; out, const SetT&amp; s)
-{  
+{
     typename SetT::const_iterator it = s.begin();
     typename SetT::const_iterator itend = s.end();
 
@@ -1245,7 +1245,7 @@
 {
 public:
     PIFStream(const string&amp; fname, ios_base::openmode m = ios_base::in)
-        :PStream(new ifstream(fname.c_str()),true) 
+        :PStream(new ifstream(fname.c_str()),true)
     {
         PLDEPRECATED(&quot;PIFStream is deprecated. Use the openFile function instead.&quot;);
     }
@@ -1256,7 +1256,7 @@
 {
 public:
     POFStream(const string&amp; fname, ios_base::openmode m = ios_base::out | ios_base::trunc)
-        :PStream(new ofstream(fname.c_str()),true) 
+        :PStream(new ofstream(fname.c_str()),true)
     {
         PLDEPRECATED(&quot;POFStream is deprecated. Use the openFile function instead.&quot;);
     }
@@ -1268,7 +1268,7 @@
 {
 public:
     PIStringStream(const string&amp; s)
-        :PStream(new istringstream(s), true /* own it */) 
+        :PStream(new istringstream(s), true /* own it */)
     {
         PLDEPRECATED(&quot;PIStringStream is deprecated. Use the openString function instead.&quot;);
     }


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001188.html">[Plearn-commits] r7740 - trunk/plearn_learners_experimental
</A></li>
	<LI>Next message: <A HREF="001190.html">[Plearn-commits] r7742 - trunk/python_modules/plearn/pymake
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1189">[ date ]</a>
              <a href="thread.html#1189">[ thread ]</a>
              <a href="subject.html#1189">[ subject ]</a>
              <a href="author.html#1189">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/plearn-commits">More information about the Plearn-commits
mailing list</a><br>
</body></html>
