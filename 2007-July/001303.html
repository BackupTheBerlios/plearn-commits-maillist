<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Plearn-commits] r7855 - trunk/plearn/python
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/plearn-commits/2007-July/index.html" >
   <LINK REL="made" HREF="mailto:plearn-commits%40lists.berlios.de?Subject=Re%3A%20%5BPlearn-commits%5D%20r7855%20-%20trunk/plearn/python&In-Reply-To=%3C200707280433.l6S4XYAs024881%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001302.html">
   <LINK REL="Next"  HREF="001304.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Plearn-commits] r7855 - trunk/plearn/python</H1>
    <B>lamblin at BerliOS</B> 
    <A HREF="mailto:plearn-commits%40lists.berlios.de?Subject=Re%3A%20%5BPlearn-commits%5D%20r7855%20-%20trunk/plearn/python&In-Reply-To=%3C200707280433.l6S4XYAs024881%40sheep.berlios.de%3E"
       TITLE="[Plearn-commits] r7855 - trunk/plearn/python">lamblin at mail.berlios.de
       </A><BR>
    <I>Sat Jul 28 06:33:34 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="001302.html">[Plearn-commits] r7854 - trunk/plearn/python
</A></li>
        <LI>Next message: <A HREF="001304.html">[Plearn-commits] r7856 - in trunk/python_modules/plearn: .	learners/autolr learners/online
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1303">[ date ]</a>
              <a href="thread.html#1303">[ thread ]</a>
              <a href="subject.html#1303">[ subject ]</a>
              <a href="author.html#1303">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: lamblin
Date: 2007-07-28 06:33:24 +0200 (Sat, 28 Jul 2007)
New Revision: 7855

Modified:
   trunk/plearn/python/PythonCodeSnippet.cc
   trunk/plearn/python/PythonCodeSnippet.h
   trunk/plearn/python/PythonObjectWrapper.cc
   trunk/plearn/python/PythonObjectWrapper.h
Log:
Cosmetic changes


Modified: trunk/plearn/python/PythonCodeSnippet.cc
===================================================================
--- trunk/plearn/python/PythonCodeSnippet.cc	2007-07-28 04:13:58 UTC (rev 7854)
+++ trunk/plearn/python/PythonCodeSnippet.cc	2007-07-28 04:33:24 UTC (rev 7855)
@@ -2,22 +2,22 @@
 
 // PythonCodeSnippet.cc
 //
-// Copyright (C) 2005 Nicolas Chapados 
-// 
+// Copyright (C) 2005 Nicolas Chapados
+//
 // Redistribution and use in source and binary forms, with or without
 // modification, are permitted provided that the following conditions are met:
-// 
+//
 //  1. Redistributions of source code must retain the above copyright
 //     notice, this list of conditions and the following disclaimer.
-// 
+//
 //  2. Redistributions in binary form must reproduce the above copyright
 //     notice, this list of conditions and the following disclaimer in the
 //     documentation and/or other materials provided with the distribution.
-// 
+//
 //  3. The name of the authors may not be used to endorse or promote
 //     products derived from this software without specific prior written
 //     permission.
-// 
+//
 // THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
 // IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 // OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
@@ -28,12 +28,12 @@
 // LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-// 
+//
 // This file is part of the PLearn library. For more information on the PLearn
 // library, go to the PLearn Web site at www.plearn.org
 
-/* *******************************************************      
- * $Id: PythonCodeSnippet.cc 2771 2005-08-11 22:06:13Z chapados $ 
+/* *******************************************************
+ * $Id: PythonCodeSnippet.cc 2771 2005-08-11 22:06:13Z chapados $
  ******************************************************* */
 
 // Authors: Nicolas Chapados
@@ -105,8 +105,8 @@
     &quot;thread-safe, i.e. the Python Global Interpreter Lock is always acquired\n&quot;
     &quot;before sensitive operations are carried out.\n&quot;
     );
-  
 
+
 PythonCodeSnippet::PythonCodeSnippet(const string&amp; code,
                                      bool remap_python_exceptions)
     : inherited(),
@@ -166,7 +166,7 @@
         // initialized into a STATIC VARIABLE of the translation unit!
         import_libnumarray();
         numarray_initialized = true;
-        
+
         PythonObjectWrapper::initializePython();
     }
 
@@ -181,7 +181,7 @@
                                             string(set_current_snippet)+m_code);
         resetCurrentSnippet();
     }
-    
+
     // Forget about injected functions
     m_injected_functions.purge_memory();
     m_python_methods.purge_memory();
@@ -263,7 +263,7 @@
             pFunc= PyObject_GetAttrString(m_instance.getPyObject(), fn);
         delete[] fn;
     }
-    if(pFunc) 
+    if(pFunc)
         instance_method= true;
     else
         pFunc= PyDict_GetItemString(m_compiled_code.getPyObject(),
@@ -291,7 +291,7 @@
             pFunc= PyObject_GetAttrString(m_instance.getPyObject(), fn);
         delete[] fn;
     }
-    if(pFunc) 
+    if(pFunc)
         instance_method= true;
     else
         pFunc= PyDict_GetItemString(m_compiled_code.getPyObject(),
@@ -306,7 +306,7 @@
         return_value = PyObject_CallObject(pFunc, NULL);
         if (! return_value)
         {
-            if(instance_method) 
+            if(instance_method)
                 Py_DECREF(pFunc);
             handlePythonErrors(string(&quot;Error while calling function '&quot;)
                                + function_name
@@ -347,7 +347,7 @@
             pFunc= PyObject_GetAttrString(m_instance.getPyObject(), fn);
         delete[] fn;
     }
-    if(pFunc) 
+    if(pFunc)
         instance_method= true;
     else
         pFunc= PyDict_GetItemString(m_compiled_code.getPyObject(),
@@ -356,9 +356,9 @@
     // pFunc: Borrowed reference if not instance_method
 
     PyObject* return_value = 0;
-    if (pFunc &amp;&amp; PyCallable_Check(pFunc)) {        
+    if (pFunc &amp;&amp; PyCallable_Check(pFunc)) {
         setCurrentSnippet(m_handle);
-        
+
         // Create argument tuple.  Warning: PyTuple_SetItem STEALS references.
         PyObject* pArgs = PyTuple_New(args.size());
         for (int i=0, n=args.size() ; i&lt;n ; ++i)
@@ -366,31 +366,31 @@
             PyTuple_SetItem(pArgs, i, args[i].getPyObject());
             Py_INCREF(args[i].getPyObject());
         }
-        
+
         return_value = PyObject_CallObject(pFunc, pArgs);
 
         Py_DECREF(pArgs);
         if (! return_value)
         {
-            if(instance_method) 
+            if(instance_method)
                 Py_DECREF(pFunc);
             handlePythonErrors(string(&quot;Error while calling function '&quot;)
                                + function_name
-                               + &quot;' with &quot; 
+                               + &quot;' with &quot;
                                + tostring(args.length())
                                + &quot; params.&quot;);
         }
-        resetCurrentSnippet();        
+        resetCurrentSnippet();
     }
     else
     {
-        if(instance_method) 
+        if(instance_method)
             Py_DECREF(pFunc);
         PLERROR(&quot;PythonCodeSnippet::invoke: cannot call function '%s'&quot;,
                 function_name);
     }
 
-    if(instance_method) 
+    if(instance_method)
         Py_DECREF(pFunc);
     //return PythonObjectWrapper(return_value);
     PythonObjectWrapper r(return_value);
@@ -415,10 +415,10 @@
         int size = PyTuple_GET_SIZE(args);
         TVec&lt;PythonObjectWrapper&gt; args_tvec(size);
         for (int i=0 ; i&lt;size ; ++i) {
-            args_tvec[i]= 
+            args_tvec[i]=
                 PythonObjectWrapper(PyTuple_GET_ITEM(args,i));
         }
-        
+
         // Now get the void* stored within the PyCObject of self
         StandaloneFunction* func =
             static_cast&lt;StandaloneFunction*&gt;(PyCObject_AsVoidPtr(self));
@@ -429,13 +429,13 @@
     }
     // Catch PLERROR and such
     catch (const PLearnError&amp; e) {
-        PyErr_SetString(PyExc_Exception, 
+        PyErr_SetString(PyExc_Exception,
                         (string(&quot;PLearn Error: &quot;)+e.message()).c_str());
         return NULL;
     }
     // Catch C++ stdlib exceptions
     catch (const std::exception&amp; e) {
-        PyErr_SetString(PyExc_Exception, 
+        PyErr_SetString(PyExc_Exception,
                         (string(&quot;C++ stdlib error: &quot;)+e.what()).c_str());
         return NULL;
     }
@@ -457,18 +457,18 @@
 
     // Wrap the function_ptr into a PyCObject
     PyObject* self = PyCObject_FromVoidPtr(function_ptr, NULL);
-    
+
     // Create a Python Function Object
     PyMethodDef* py_method = m_python_methods.allocate();
     py_method-&gt;ml_name  = const_cast&lt;char*&gt;(python_name);
     py_method-&gt;ml_meth  = pythonTrampoline;
     py_method-&gt;ml_flags = METH_VARARGS;
     py_method-&gt;ml_doc   = &quot;injected-function-from-PythonCodeSnippet&quot;;
-    
+
     PyObject* py_funcobj = PyCFunction_NewEx(py_method,
                                              self /* info for trampoline */,
                                              NULL /* module */);
-    
+
     if (py_funcobj) {
         // Inject into the running snippet.  Note that when a
         // PythonObjectWrapper is constructed from a PyObject, it steals the
@@ -478,7 +478,7 @@
         {
             char* fn= new char[strlen(python_name)+1];
             strcpy(fn, python_name);
-            PyObject_SetAttrString(m_instance.getPyObject(), 
+            PyObject_SetAttrString(m_instance.getPyObject(),
                                    fn, py_funcobj);
             delete[] fn;
         }
@@ -487,7 +487,7 @@
             // Publish the injection in the '__injected__' dictionary for imported modules
             PythonObjectWrapper inj_dict = this-&gt;getGlobalObject(&quot;__injected__&quot;);
             PyDict_SetItemString(inj_dict.getPyObject(), python_name, py_funcobj);
-            
+
             Py_XDECREF(self);
         }
     }
@@ -546,14 +546,14 @@
     //get the global env. as an stl map
     PythonObjectWrapper wrapped_globals(globals);
     Py_XDECREF(globals);
-    map&lt;string, PyObject*&gt; global_map= 
+    map&lt;string, PyObject*&gt; global_map=
         wrapped_globals.as&lt;map&lt;string, PyObject*&gt; &gt;();
 
     //inject global funcs, if not already done
     static bool global_funcs_injected= false;
     if(!global_funcs_injected)
     {
-        map&lt;string, PyObject*&gt;::iterator it= 
+        map&lt;string, PyObject*&gt;::iterator it=
             global_map.find(&quot;pl_global_funcs&quot;);
         if(it == global_map.end())
             PLERROR(&quot;in PythonCodeSnippet::compileGlobalCode : &quot;
@@ -564,7 +564,7 @@
 
     //try to find an EmbeddedCodeSnippet to instantiate
     PyObject* snippet_found= 0;
-    map&lt;string, PyObject*&gt;::iterator it_id= 
+    map&lt;string, PyObject*&gt;::iterator it_id=
         global_map.find(&quot;pl_embedded_code_snippet_type&quot;);
 
     if(it_id != global_map.end())
@@ -574,7 +574,7 @@
         list&lt;pair&lt;string, PyObject*&gt; &gt; classes_found;
 
         //iter (find)
-        PyTypeObject* embedded_code_snippet_type= 
+        PyTypeObject* embedded_code_snippet_type=
             (PyTypeObject*)global_map[&quot;EmbeddedCodeSnippet&quot;];
 
         //find all classes deriving from EmbeddedCodeSnippet
@@ -582,9 +582,9 @@
             it != global_map.end(); ++it)
         {
             if(PyType_Check(it-&gt;second)
-               &amp;&amp; 0 != PyObject_Compare(it-&gt;second, 
+               &amp;&amp; 0 != PyObject_Compare(it-&gt;second,
                                         (PyObject*)embedded_code_snippet_type)
-               &amp;&amp; PyType_IsSubtype((PyTypeObject*)it-&gt;second, 
+               &amp;&amp; PyType_IsSubtype((PyTypeObject*)it-&gt;second,
                                    embedded_code_snippet_type))
             {
                 classes_found.push_back(*it);
@@ -607,7 +607,7 @@
         if(nclasses == 1)
             snippet_found= jt-&gt;second;
     }
-    
+
     if(snippet_found)
     {//instantiate object of appropriate type
         PyObject* pyparams= PyDict_New();
@@ -636,8 +636,8 @@
             PLERROR(&quot;in PythonCodeSnippet::compileGlobalCode : &quot;
                     &quot;found subclass of EmbeddedCodeSnippet, but can't &quot;
                     &quot;call constructor with given params.  &quot;
-                    &quot;class='%s', params=%s&quot;, 
-                    ((PyTypeObject*)snippet_found)-&gt;tp_name, 
+                    &quot;class='%s', params=%s&quot;,
+                    ((PyTypeObject*)snippet_found)-&gt;tp_name,
                     tostring(m_instance_params).c_str());
         }
         m_instance= PythonObjectWrapper(the_obj);
@@ -665,14 +665,14 @@
 void PythonCodeSnippet::setCurrentSnippet(const void* handle) const
 {
     PythonGlobalInterpreterLock gil;         // For thread-safety
-    
+
     char set_current_snippet[100];
-    sprintf(set_current_snippet, SetCurrentSnippetVar, handle);    
-    PyObject* res= PyRun_String(set_current_snippet, 
+    sprintf(set_current_snippet, SetCurrentSnippetVar, handle);
+    PyObject* res= PyRun_String(set_current_snippet,
                                 Py_file_input /* exec code block */,
-                                m_compiled_code.getPyObject(), 
+                                m_compiled_code.getPyObject(),
                                 m_compiled_code.getPyObject());
-    
+
     Py_XDECREF(res);
     if (PyErr_Occurred()) {
         Py_XDECREF(m_compiled_code.getPyObject());
@@ -685,10 +685,10 @@
 void PythonCodeSnippet::resetCurrentSnippet() const
 {
     PythonGlobalInterpreterLock gil;         // For thread-safety
-    
-    PyObject* res= PyRun_String(ResetCurrentSnippetVar, 
+
+    PyObject* res= PyRun_String(ResetCurrentSnippetVar,
                                 Py_file_input /* exec code block */,
-                                m_compiled_code.getPyObject(), 
+                                m_compiled_code.getPyObject(),
                                 m_compiled_code.getPyObject());
     Py_XDECREF(res);
     if (PyErr_Occurred()) {
@@ -719,9 +719,9 @@
                                              &quot;exception but there is no traceback.\n&quot;)
                                       + extramsg);
             }
-            
 
-            PyObject* tbstr= 
+
+            PyObject* tbstr=
                 PyString_FromString(&quot;plearn.utilities.pltraceback&quot;);
             PyObject* tbmod= PyImport_Import(tbstr);
             Py_XDECREF(tbstr);
@@ -745,7 +745,7 @@
                                       &quot; call to cgitb.text failed&quot;);
             string str= PyString_AsString(pystr);
             Py_XDECREF(pystr);
-            
+
             PyErr_Clear();
 
             Py_XDECREF(exception);
@@ -756,10 +756,10 @@
         else {
             PyErr_Print();
             PyErr_Clear();
-            PLERROR(&quot;PythonCodeSnippet: encountered Python exception.\n%s&quot;, 
+            PLERROR(&quot;PythonCodeSnippet: encountered Python exception.\n%s&quot;,
                     extramsg.c_str());
         }
-    }  
+    }
 }
 
 
@@ -769,7 +769,7 @@
 }
 
 
-    
+
 } // end of namespace PLearn
 
 

Modified: trunk/plearn/python/PythonCodeSnippet.h
===================================================================
--- trunk/plearn/python/PythonCodeSnippet.h	2007-07-28 04:13:58 UTC (rev 7854)
+++ trunk/plearn/python/PythonCodeSnippet.h	2007-07-28 04:33:24 UTC (rev 7855)
@@ -2,22 +2,22 @@
 
 // PythonCodeSnippet.h
 //
-// Copyright (C) 2005 Nicolas Chapados 
-// 
+// Copyright (C) 2005 Nicolas Chapados
+//
 // Redistribution and use in source and binary forms, with or without
 // modification, are permitted provided that the following conditions are met:
-// 
+//
 //  1. Redistributions of source code must retain the above copyright
 //     notice, this list of conditions and the following disclaimer.
-// 
+//
 //  2. Redistributions in binary form must reproduce the above copyright
 //     notice, this list of conditions and the following disclaimer in the
 //     documentation and/or other materials provided with the distribution.
-// 
+//
 //  3. The name of the authors may not be used to endorse or promote
 //     products derived from this software without specific prior written
 //     permission.
-// 
+//
 // THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
 // IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 // OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
@@ -28,12 +28,12 @@
 // LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-// 
+//
 // This file is part of the PLearn library. For more information on the PLearn
 // library, go to the PLearn Web site at www.plearn.org
 
-/* *******************************************************      
- * $Id: PythonCodeSnippet.h 2797 2005-08-25 14:06:26Z chapados $ 
+/* *******************************************************
+ * $Id: PythonCodeSnippet.h 2797 2005-08-25 14:06:26Z chapados $
  ******************************************************* */
 
 // Authors: Nicolas Chapados
@@ -70,7 +70,7 @@
 class PythonException : public PLearnError
 {
     typedef PLearnError inherited;
-    
+
 public:
     PythonException(const string&amp; message)
         : inherited(message)
@@ -118,14 +118,14 @@
      */
     typedef boost::function&lt;PythonObjectWrapper (
         const TVec&lt;PythonObjectWrapper&gt;&amp; args)&gt; StandaloneFunction;
-    
+
     //! The snippet prepended to 'code' option for the injections to behave properly.
     static const char* InjectSetupSnippet;
 
     //! Used to (un)set CURRENT_SNIPPET in Python
     static const char* SetCurrentSnippetVar;
     static const char* ResetCurrentSnippetVar;
-    
+
 public:
     /**
      *  Python statement list that should be compiled at build time to provide
@@ -152,7 +152,7 @@
 
     //! the python object instance
     PythonObjectWrapper m_instance;
-    
+
 public:
     //! Default constructor.  Note that &quot;build&quot; IS NOT CALLED from the
     //! constructor and must be called manually after all external functions
@@ -162,7 +162,7 @@
 
     //! Default copy ctor, assignment op, dtor
 
-    
+
     //#####  Global Environment Interface  ####################################
 
     //! Return an object from the global environment.  Return None if the
@@ -180,7 +180,7 @@
     }
 
 
-    
+
     //#####  Function Call Interface  #########################################
 
     //! Checks whether the specified function name is callable
@@ -194,25 +194,25 @@
     //! 'transfer_ownership' option.
     PythonObjectWrapper invoke(const char* function_name,
                                const TVec&lt;PythonObjectWrapper&gt;&amp; args) const;
-    
+
     //! Call the specified function with 1 argument.
     template &lt;class T&gt;
     PythonObjectWrapper invoke(const char* function_name,
                                const T&amp; arg1) const;
-    
+
     //! Call the specified function with 2 arguments.
     template &lt;class T, class U&gt;
     PythonObjectWrapper invoke(const char* function_name,
                                const T&amp; arg1,
                                const U&amp; arg2) const;
-    
+
     //! Call the specified function with 3 arguments.
     template &lt;class T, class U, class V&gt;
     PythonObjectWrapper invoke(const char* function_name,
                                const T&amp; arg1,
                                const U&amp; arg2,
                                const V&amp; arg3) const;
-    
+
     //! Call the specified function with 4 arguments.
     template &lt;class T, class U, class V, class W&gt;
     PythonObjectWrapper invoke(const char* function_name,
@@ -284,7 +284,7 @@
     template &lt;class T&gt;
     void inject(const char* python_name, const T* object,
                 PythonObjectWrapper (T::*)(const TVec&lt;PythonObjectWrapper&gt;&amp;) const);
-    
+
     /**
      *  Inject a bound C++ member function into the Python code under the given
      *  name (non-const version).
@@ -299,14 +299,14 @@
      *  debugging purposes.
      */
     void dumpPythonEnvironment();
-    
 
+
     //#####  PLearn::Object Standard Functions  ###############################
 
     // Declares other standard object methods
     PLEARN_DECLARE_OBJECT(PythonCodeSnippet);
 
-    // simply calls inherited::build() then build_() 
+    // simply calls inherited::build() then build_()
     virtual void build();
 
     //! Transforms a shallow copy into a deep copy
@@ -314,7 +314,7 @@
 
     virtual void run();
 
-protected: 
+protected:
     //! Declares this class' options
     static void declareOptions(OptionList&amp; ol);
 
@@ -324,7 +324,7 @@
 
     void setCurrentSnippet(const void* handle) const;
     void resetCurrentSnippet() const;
-    
+
     //! If no Python error, do nothing.  If an error occurred, convert the
     //! Python Exception into a C++ exception if required, or otherwise print a
     //! traceback and abort
@@ -342,7 +342,7 @@
     //! The Python handle for *this* instance
     void* m_handle;
 
-public:    
+public:
     //! Compiled Python code module and global environment
     PythonObjectWrapper m_compiled_code;
 
@@ -352,8 +352,8 @@
 
     //! Injected Python method definitions
     PObjectPool&lt;PyMethodDef&gt; m_python_methods;
-    
-private: 
+
+private:
     //! This does the actual building.  This is where the Python code
     //! is in fact compiled
     void build_();
@@ -393,16 +393,16 @@
             PLERROR(&quot;PythonCodeSnippet::invoke: error during argument conversion &quot;
                     &quot;from C++ to Python for function '%s'&quot;, function_name);
         }
-        
-        PyTuple_SetItem(pArgs, 0, py_arg1);        
 
+        PyTuple_SetItem(pArgs, 0, py_arg1);
+
         return_value = PyObject_CallObject(pFunc, pArgs);
 
         Py_XDECREF(pArgs);
         if (! return_value)
             handlePythonErrors();
 
-        resetCurrentSnippet();        
+        resetCurrentSnippet();
     }
     else {
         PLERROR(&quot;PythonCodeSnippet::invoke: cannot call function '%s'&quot;,
@@ -445,10 +445,10 @@
             PLERROR(&quot;PythonCodeSnippet::invoke: error during argument conversion &quot;
                     &quot;from C++ to Python for function '%s'&quot;, function_name);
         }
-        
+
         PyTuple_SetItem(pArgs, 0, py_arg1);
         PyTuple_SetItem(pArgs, 1, py_arg2);
-        
+
         return_value = PyObject_CallObject(pFunc, pArgs);
 
         Py_XDECREF(pArgs);
@@ -502,7 +502,7 @@
             PLERROR(&quot;PythonCodeSnippet::invoke: error during argument conversion &quot;
                     &quot;from C++ to Python for function '%s'&quot;, function_name);
         }
-        
+
         PyTuple_SetItem(pArgs, 0, py_arg1);
         PyTuple_SetItem(pArgs, 1, py_arg2);
         PyTuple_SetItem(pArgs, 2, py_arg3);
@@ -563,12 +563,12 @@
             PLERROR(&quot;PythonCodeSnippet::invoke: error during argument conversion &quot;
                     &quot;from C++ to Python for function '%s'&quot;, function_name);
         }
-        
+
         PyTuple_SetItem(pArgs, 0, py_arg1);
         PyTuple_SetItem(pArgs, 1, py_arg2);
         PyTuple_SetItem(pArgs, 2, py_arg3);
         PyTuple_SetItem(pArgs, 3, py_arg4);
-        
+
         return_value = PyObject_CallObject(pFunc, pArgs);
 
         Py_XDECREF(pArgs);
@@ -628,13 +628,13 @@
             PLERROR(&quot;PythonCodeSnippet::invoke: error during argument conversion &quot;
                     &quot;from C++ to Python for function '%s'&quot;, function_name);
         }
-        
+
         PyTuple_SetItem(pArgs, 0, py_arg1);
         PyTuple_SetItem(pArgs, 1, py_arg2);
         PyTuple_SetItem(pArgs, 2, py_arg3);
         PyTuple_SetItem(pArgs, 3, py_arg4);
         PyTuple_SetItem(pArgs, 4, py_arg5);
-        
+
         return_value = PyObject_CallObject(pFunc, pArgs);
 
         Py_XDECREF(pArgs);
@@ -699,14 +699,14 @@
             PLERROR(&quot;PythonCodeSnippet::invoke: error during argument conversion &quot;
                     &quot;from C++ to Python for function '%s'&quot;, function_name);
         }
-        
+
         PyTuple_SetItem(pArgs, 0, py_arg1);
         PyTuple_SetItem(pArgs, 1, py_arg2);
         PyTuple_SetItem(pArgs, 2, py_arg3);
         PyTuple_SetItem(pArgs, 3, py_arg4);
         PyTuple_SetItem(pArgs, 4, py_arg5);
         PyTuple_SetItem(pArgs, 5, py_arg6);
-        
+
         return_value = PyObject_CallObject(pFunc, pArgs);
 
         Py_XDECREF(pArgs);
@@ -776,7 +776,7 @@
             PLERROR(&quot;PythonCodeSnippet::invoke: error during argument conversion &quot;
                     &quot;from C++ to Python for function '%s'&quot;, function_name);
         }
-        
+
         PyTuple_SetItem(pArgs, 0, py_arg1);
         PyTuple_SetItem(pArgs, 1, py_arg2);
         PyTuple_SetItem(pArgs, 2, py_arg3);
@@ -784,7 +784,7 @@
         PyTuple_SetItem(pArgs, 4, py_arg5);
         PyTuple_SetItem(pArgs, 5, py_arg6);
         PyTuple_SetItem(pArgs, 6, py_arg7);
-        
+
         return_value = PyObject_CallObject(pFunc, pArgs);
 
         Py_XDECREF(pArgs);

Modified: trunk/plearn/python/PythonObjectWrapper.cc
===================================================================
--- trunk/plearn/python/PythonObjectWrapper.cc	2007-07-28 04:13:58 UTC (rev 7854)
+++ trunk/plearn/python/PythonObjectWrapper.cc	2007-07-28 04:33:24 UTC (rev 7855)
@@ -2,23 +2,23 @@
 
 // PythonObjectWrapper.cc
 //
-// Copyright (C) 2005-2006 Nicolas Chapados 
+// Copyright (C) 2005-2006 Nicolas Chapados
 // Copyright (C) 2007 Xavier Saint-Mleux, ApSTAT Technologies inc.
-// 
+//
 // Redistribution and use in source and binary forms, with or without
 // modification, are permitted provided that the following conditions are met:
-// 
+//
 //  1. Redistributions of source code must retain the above copyright
 //     notice, this list of conditions and the following disclaimer.
-// 
+//
 //  2. Redistributions in binary form must reproduce the above copyright
 //     notice, this list of conditions and the following disclaimer in the
 //     documentation and/or other materials provided with the distribution.
-// 
+//
 //  3. The name of the authors may not be used to endorse or promote
 //     products derived from this software without specific prior written
 //     permission.
-// 
+//
 // THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
 // IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 // OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
@@ -29,12 +29,12 @@
 // LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-// 
+//
 // This file is part of the PLearn library. For more information on the PLearn
 // library, go to the PLearn Web site at www.plearn.org
 
-/* *******************************************************      
-   * $Id: .pyskeleton_header 544 2003-09-01 00:05:31Z plearner $ 
+/* *******************************************************
+   * $Id: .pyskeleton_header 544 2003-09-01 00:05:31Z plearner $
    ******************************************************* */
 
 // Authors: Nicolas Chapados
@@ -98,58 +98,6 @@
 }
 
 
-#if 0
-int ConvertFromPyObject&lt;int&gt;::convert(PyObject* pyobj, bool print_traceback)
-{
-    PLASSERT( pyobj );
-    if (! PyInt_Check(pyobj))
-        PLPythonConversionError(&quot;ConvertFromPyObject&lt;int&gt;&quot;, pyobj, print_traceback);
-    return int(PyInt_AS_LONG(pyobj));
-}
-
-unsigned int ConvertFromPyObject&lt;unsigned int&gt;::convert(PyObject* pyobj, bool print_traceback)
-{
-    PLASSERT( pyobj );
-    if (! PyInt_Check(pyobj))
-        PLPythonConversionError(&quot;ConvertFromPyObject&lt;unsigned int&gt;&quot;, pyobj, print_traceback);
-    return static_cast&lt;unsigned int&gt;(PyInt_AsUnsignedLongMask(pyobj));
-}
-
-/*
-long ConvertFromPyObject&lt;long&gt;::convert(PyObject* pyobj, bool print_traceback)
-{
-    PLASSERT( pyobj );
-    if (! PyLong_Check(pyobj))
-        PLPythonConversionError(&quot;ConvertFromPyObject&lt;long&gt;&quot;, pyobj, print_traceback);
-    return PyLong_AsLong(pyobj);
-}
-
-unsigned long ConvertFromPyObject&lt;unsigned long&gt;::convert(PyObject* pyobj, bool print_traceback)
-{
-    PLASSERT( pyobj );
-    if (! PyInt_Check(pyobj))
-        PLPythonConversionError(&quot;ConvertFromPyObject&lt;unsigned long&gt;&quot;, pyobj, print_traceback);
-    return PyInt_AsUnsignedLongMask(pyobj);
-}
-*/
-
-int64_t ConvertFromPyObject&lt;int64_t&gt;::convert(PyObject* pyobj, bool print_traceback)
-{
-    PLASSERT( pyobj );
-    if (! PyLong_Check(pyobj))
-        PLPythonConversionError(&quot;ConvertFromPyObject&lt;int64_t&gt;&quot;, pyobj, print_traceback);
-    return PyLong_AsLongLong(pyobj);
-}
-
-uint64_t ConvertFromPyObject&lt;uint64_t&gt;::convert(PyObject* pyobj, bool print_traceback)
-{
-    PLASSERT( pyobj );
-    if (! PyInt_Check(pyobj))
-        PLPythonConversionError(&quot;ConvertFromPyObject&lt;uint64_t&gt;&quot;, pyobj, print_traceback);
-    return PyInt_AsUnsignedLongLongMask(pyobj);
-}
-#endif
-
 double ConvertFromPyObject&lt;double&gt;::convert(PyObject* pyobj,
                                             bool print_traceback)
 {
@@ -180,7 +128,8 @@
     return 0;//shut up compiler
 }
 
-string ConvertFromPyObject&lt;string&gt;::convert(PyObject* pyobj, bool print_traceback)
+string ConvertFromPyObject&lt;string&gt;::convert(PyObject* pyobj,
+                                            bool print_traceback)
 {
     PLASSERT( pyobj );
     if (! PyString_Check(pyobj))
@@ -189,7 +138,8 @@
     return PyString_AsString(pyobj);
 }
 
-PPath ConvertFromPyObject&lt;PPath&gt;::convert(PyObject* pyobj, bool print_traceback)
+PPath ConvertFromPyObject&lt;PPath&gt;::convert(PyObject* pyobj,
+                                          bool print_traceback)
 {
     PLASSERT( pyobj );
     if (! PyString_Check(pyobj))
@@ -198,7 +148,8 @@
     return PPath(PyString_AsString(pyobj));
 }
 
-PPointable* ConvertFromPyObject&lt;PPointable*&gt;::convert(PyObject* pyobj, bool print_traceback)
+PPointable* ConvertFromPyObject&lt;PPointable*&gt;::convert(PyObject* pyobj,
+                                                      bool print_traceback)
 {
     PLASSERT(pyobj);
     if (! PyCObject_Check(pyobj))
@@ -207,7 +158,8 @@
     return static_cast&lt;PPointable*&gt;(PyCObject_AsVoidPtr(pyobj));
 }
 
-Object* ConvertFromPyObject&lt;Object*&gt;::convert(PyObject* pyobj, bool print_traceback)
+Object* ConvertFromPyObject&lt;Object*&gt;::convert(PyObject* pyobj,
+                                              bool print_traceback)
 {
     PLASSERT(pyobj);
     if(pyobj == Py_None)
@@ -225,19 +177,21 @@
         PLPythonConversionError(&quot;ConvertFromPyObject&lt;Object*&gt;&quot;, pyobj,
                                 print_traceback);
     Object* obj= static_cast&lt;Object*&gt;(PyCObject_AsVoidPtr(cptr));
-   
+
     Py_DECREF(cptr);
     return obj;
 }
 
-void ConvertFromPyObject&lt;Vec&gt;::convert(PyObject* pyobj, Vec&amp; v, bool print_traceback)
+void ConvertFromPyObject&lt;Vec&gt;::convert(PyObject* pyobj, Vec&amp; v,
+                                       bool print_traceback)
 {
     // NA_InputArray possibly creates a well-behaved temporary (i.e. not
     // discontinuous is memory)
     PLASSERT( pyobj );
     PyArrayObject* pyarr = NA_InputArray(pyobj, tReal, NUM_C_ARRAY);
     if (! pyarr)
-        PLPythonConversionError(&quot;ConvertFromPyObject&lt;Vec&gt;&quot;, pyobj, print_traceback);
+        PLPythonConversionError(&quot;ConvertFromPyObject&lt;Vec&gt;&quot;, pyobj,
+                                print_traceback);
     if (pyarr-&gt;nd != 1)
         PLERROR(&quot;ConvertFromPyObject&lt;Vec&gt;: Dimensionality of the returned array &quot;
                 &quot;should be 1; got %d&quot;, pyarr-&gt;nd);
@@ -254,14 +208,16 @@
     return v;
 }
 
-void ConvertFromPyObject&lt;Mat&gt;::convert(PyObject* pyobj, Mat&amp; m, bool print_traceback)
+void ConvertFromPyObject&lt;Mat&gt;::convert(PyObject* pyobj, Mat&amp; m,
+                                       bool print_traceback)
 {
     // NA_InputArray possibly creates a well-behaved temporary (i.e. not
     // discontinuous is memory)
     PLASSERT( pyobj );
     PyArrayObject* pyarr = NA_InputArray(pyobj, tReal, NUM_C_ARRAY);
     if (! pyarr)
-        PLPythonConversionError(&quot;ConvertFromPyObject&lt;Mat&gt;&quot;, pyobj, print_traceback);
+        PLPythonConversionError(&quot;ConvertFromPyObject&lt;Mat&gt;&quot;, pyobj,
+                                print_traceback);
     if (pyarr-&gt;nd != 2)
         PLERROR(&quot;ConvertFromPyObject&lt;Mat&gt;: Dimensionality of the returned array &quot;
                 &quot;should be 2; got %d&quot;, pyarr-&gt;nd);
@@ -279,8 +235,10 @@
     return m;
 }
 
-//VMat ConvertFromPyObject&lt;VMat&gt;::convert(PyObject* pyobj, bool print_traceback)
-PP&lt;VMatrix&gt; ConvertFromPyObject&lt;PP&lt;VMatrix&gt; &gt;::convert(PyObject* pyobj, bool print_traceback)
+//VMat ConvertFromPyObject&lt;VMat&gt;::convert(PyObject* pyobj,
+//                                        bool print_traceback)
+PP&lt;VMatrix&gt; ConvertFromPyObject&lt;PP&lt;VMatrix&gt; &gt;::convert(PyObject* pyobj,
+                                                       bool print_traceback)
 {
     PLASSERT(pyobj);
     if(PyObject_HasAttrString(pyobj, &quot;_cptr&quot;))
@@ -299,7 +257,8 @@
 
 //#####  Constructors+Destructors  ############################################
 PythonObjectWrapper::PythonObjectWrapper(OwnershipMode o,
-                                         bool acquire_gil /* unused in this overload */)
+                                         // unused in this overload
+                                         bool acquire_gil)
     : m_ownership(o),
       m_object(Py_None)
 {
@@ -309,10 +268,11 @@
 
 //! Constructor for pre-existing PyObject
 PythonObjectWrapper::PythonObjectWrapper(PyObject* pyobj, OwnershipMode o,
-                                         bool acquire_gil /* unused in this overload */)
+                                         // unused in this overload
+                                         bool acquire_gil)
     : m_ownership(o),
       m_object(pyobj)
-{ 
+{
     if (m_ownership == control_ownership)
         Py_XINCREF(m_object);
 }
@@ -375,8 +335,8 @@
 {
     return ! m_object || m_object == Py_None;
 }
-    
 
+
 //##### Trampoline ############################################################
 PyObject* PythonObjectWrapper::trampoline(PyObject* self, PyObject* args)
 {
@@ -387,17 +347,17 @@
 
     //perr &lt;&lt; &quot;refcnt self= &quot; &lt;&lt; self-&gt;ob_refcnt &lt;&lt; endl;
 
-    RemoteTrampoline* tramp= 
+    RemoteTrampoline* tramp=
         dynamic_cast&lt;RemoteTrampoline*&gt;(s.as&lt;PPointable*&gt;());
-    if(!tramp) 
+    if(!tramp)
         PLERROR(&quot;in PythonObjectWrapper::trampoline : &quot;
                 &quot;can't unwrap RemoteTrampoline.&quot;);
 
     //wrap args
     int size = PyTuple_GET_SIZE(args);
     TVec&lt;PythonObjectWrapper&gt; args_tvec(size);
-    for(int i= 0; i &lt; size; ++i) 
-        args_tvec[i]= 
+    for(int i= 0; i &lt; size; ++i)
+        args_tvec[i]=
             PythonObjectWrapper(PyTuple_GET_ITEM(args,i));
 
     // separate self from other params.
@@ -412,17 +372,17 @@
         Py_XINCREF(to_return);
         return to_return;
     }
-    catch(const PLearnError&amp; e) 
+    catch(const PLearnError&amp; e)
     {
         PyErr_SetString(PyExc_Exception, e.message().c_str());
         return 0;
     }
-    catch(const std::exception&amp; e) 
+    catch(const std::exception&amp; e)
     {
         PyErr_SetString(PyExc_Exception, e.what());
         return 0;
     }
-    catch(...) 
+    catch(...)
     {
         PyErr_SetString(PyExc_Exception,
                         &quot;Caught unknown C++ exception while executing injected function &quot;
@@ -433,7 +393,7 @@
 
 PyObject* PythonObjectWrapper::python_del(PyObject* self, PyObject* args)
 {
-    TVec&lt;PyObject*&gt; args_tvec= 
+    TVec&lt;PyObject*&gt; args_tvec=
         PythonObjectWrapper(args).as&lt;TVec&lt;PyObject*&gt; &gt;();
 
     Object* obj= PythonObjectWrapper(args_tvec[0]);
@@ -460,16 +420,17 @@
 
 //#####  newPyObject  #########################################################
 
-PyObject* PythonObjectWrapper::newPyObject()           //!&lt; Return None (increments refcount)
+//! Return None (increments refcount)
+PyObject* PythonObjectWrapper::newPyObject()
 {
     Py_XINCREF(Py_None);
     return Py_None;
 }
 
-PythonObjectWrapper::wrapped_objects_t 
+PythonObjectWrapper::wrapped_objects_t
     PythonObjectWrapper::m_wrapped_objects;//init.
 
-PythonObjectWrapper::pypl_classes_t 
+PythonObjectWrapper::pypl_classes_t
     PythonObjectWrapper::m_pypl_classes;//init.
 //init.
 bool PythonObjectWrapper::m_unref_injected= false;
@@ -479,7 +440,7 @@
 PyObject* ConvertToPyObject&lt;Object*&gt;::newPyObject(const Object* x)
 {
     // void ptr becomes None
-    if(!x) 
+    if(!x)
         return PythonObjectWrapper::newPyObject();
 
     PythonGlobalInterpreterLock gil;         // For thread-safety
@@ -488,7 +449,7 @@
     PythonObjectWrapper::initializePython();
 
     //see if this obj. is already wrapped
-    PythonObjectWrapper::wrapped_objects_t::iterator objit= 
+    PythonObjectWrapper::wrapped_objects_t::iterator objit=
         PythonObjectWrapper::m_wrapped_objects.find(x);
     if(objit != PythonObjectWrapper::m_wrapped_objects.end())
     {
@@ -502,9 +463,10 @@
         &quot;import *\n&quot;;
     PyObject* pyenv= PyDict_New();
     PyDict_SetItemString(pyenv, &quot;__builtins__&quot;, PyEval_GetBuiltins());
-    PyObject* res= PyRun_String(importcode.c_str(), Py_file_input, pyenv, pyenv);
+    PyObject* res= PyRun_String(importcode.c_str(), Py_file_input, pyenv,
+                                pyenv);
     Py_DECREF(res);
-    if (PyErr_Occurred()) 
+    if (PyErr_Occurred())
     {
         Py_DECREF(pyenv);
         PyErr_Print();
@@ -536,16 +498,16 @@
         py_method-&gt;ml_flags = METH_VARARGS;
         py_method-&gt;ml_doc   = &quot;Injected unref function from PythonObjectWrapper; &quot;
             &quot;DO NOT USE THIS FUNCTION! IT MAY DEALLOCATE THE PLEARN OBJECT!&quot;;
-        
+
         PyObject* py_funcobj= PyCFunction_NewEx(py_method, NULL, NULL);
         PyObject* py_methobj= PyMethod_New(py_funcobj, NULL, wrapper);
         Py_XDECREF(py_funcobj);
-        if(!py_funcobj || !py_methobj) 
+        if(!py_funcobj || !py_methobj)
         {
             Py_DECREF(pyenv);
             Py_XDECREF(py_methobj);
             PLERROR(&quot;in PythonObjectWrapper::newPyObject : &quot;
-                    &quot;can't inject method '%s' (i.e. __del__)&quot;, 
+                    &quot;can't inject method '%s' (i.e. __del__)&quot;,
                     py_method-&gt;ml_name);
         }
         PyObject_SetAttrString(wrapper, py_method-&gt;ml_name, py_methobj);
@@ -576,7 +538,7 @@
 
     // try to find existing python class
     string classname= x-&gt;classname();
-    PythonObjectWrapper::pypl_classes_t::iterator clit2= 
+    PythonObjectWrapper::pypl_classes_t::iterator clit2=
         PythonObjectWrapper::m_pypl_classes.find(classname);
     PyObject* the_pyclass= 0;
     if(clit2 == PythonObjectWrapper::m_pypl_classes.end())
@@ -595,7 +557,7 @@
         if(clit == env.end())
             PLERROR(&quot;in PythonObjectWrapper::newPyObject : &quot;
                     &quot;Cannot create new python class deriving from &quot;
-                    &quot;%s (%s).&quot;, 
+                    &quot;%s (%s).&quot;,
                     wrapper_name.c_str(),
                     classname.c_str());
 
@@ -607,11 +569,11 @@
             optionnames[i]= options[i]-&gt;optionname();
 
         the_pyclass= clit-&gt;second;
-        if(-1==PyObject_SetAttrString(the_pyclass, &quot;_optionnames&quot;, 
+        if(-1==PyObject_SetAttrString(the_pyclass, &quot;_optionnames&quot;,
                                       PythonObjectWrapper(optionnames).getPyObject()))
         {
             Py_DECREF(pyenv);
-            if (PyErr_Occurred()) 
+            if (PyErr_Occurred())
                 PyErr_Print();
             PLERROR(&quot;cannot set attr _optionnames&quot;);
         }
@@ -619,12 +581,12 @@
         // inject all declared methods
         const RemoteMethodMap* methods= &amp;x-&gt;getRemoteMethodMap();
 
-        PP&lt;PObjectPool&lt;PyMethodDef&gt; &gt; meth_def_pool= 
+        PP&lt;PObjectPool&lt;PyMethodDef&gt; &gt; meth_def_pool=
             new PObjectPool&lt;PyMethodDef&gt;(methods-&gt;size()+1);
 
         PythonObjectWrapper::m_pypl_classes.insert(
             make_pair(classname, PLPyClass(the_pyclass, meth_def_pool)));
-        TVec&lt;string&gt;&amp; methods_help= 
+        TVec&lt;string&gt;&amp; methods_help=
             PythonObjectWrapper::m_pypl_classes.find(classname)-&gt;second.methods_help;
 
         while(methods)
@@ -634,7 +596,7 @@
             {
                 //get the RemoteTrampoline
                 PyObject* tramp= PyCObject_FromVoidPtr(it-&gt;second, NULL);
-            
+
                 // Create a Python Function Object
                 PyMethodDef* py_method= meth_def_pool-&gt;allocate();
                 py_method-&gt;ml_name  = const_cast&lt;char*&gt;(it-&gt;first.first.c_str());
@@ -644,7 +606,7 @@
                                                                 it-&gt;first.first.c_str(),
                                                                 it-&gt;first.second));
                 py_method-&gt;ml_doc   = const_cast&lt;char*&gt;(methods_help.last().c_str());
-    
+
                 PyObject* py_funcobj= PyCFunction_NewEx(py_method, tramp, NULL);
 
                 // create an unbound method from the function
@@ -652,7 +614,7 @@
 
                 Py_DECREF(tramp);
                 Py_XDECREF(py_funcobj);
-                if(!py_funcobj || !py_methobj) 
+                if(!py_funcobj || !py_methobj)
                 {
                     Py_DECREF(pyenv);
                     Py_DECREF(plobj);
@@ -661,7 +623,8 @@
                             &quot;can't inject method '%s'&quot;, py_method-&gt;ml_name);
                 }
 
-                PyObject_SetAttrString(the_pyclass, py_method-&gt;ml_name, py_methobj);
+                PyObject_SetAttrString(the_pyclass, py_method-&gt;ml_name,
+                                       py_methobj);
                 Py_DECREF(py_methobj);
             }
             methods= methods-&gt;inheritedMethods();//get parent class methods
@@ -672,12 +635,12 @@
         the_pyclass= clit2-&gt;second.pyclass;
         ++clit2-&gt;second.nref;
     }
-    
+
     //create the python object itself from the_pyclass
     PyObject* args= PyTuple_New(1);
     Py_INCREF(plobj);//keep it after it is 'stolen'
     PyTuple_SetItem(args, 0, plobj);
-    
+
     PyObject* params= PyDict_New();
     PyObject* the_obj= PyObject_Call(the_pyclass, args, params);
     Py_DECREF(args);
@@ -715,40 +678,6 @@
     }
 }
 
-#if 0
-PyObject* ConvertToPyObject&lt;int&gt;::newPyObject(const int&amp; x)
-{
-    return PyInt_FromLong(long(x));
-}
-
-PyObject* ConvertToPyObject&lt;unsigned int&gt;::newPyObject(const unsigned int&amp; x)
-{
-    return PyLong_FromUnsignedLong(static_cast&lt;unsigned long&gt;(x));
-}
-
-/*
-PyObject* ConvertToPyObject&lt;long&gt;::newPyObject(const long&amp; x)
-{
-    return PyLong_FromLong(x);
-}
-
-PyObject* ConvertToPyObject&lt;unsigned long&gt;::newPyObject(const unsigned long&amp; x)
-{
-    return PyLong_FromUnsignedLong(x);
-}
-*/
-
-PyObject* ConvertToPyObject&lt;int64_t&gt;::newPyObject(const int64_t&amp; x)
-{
-    return PyLong_FromLongLong(x);
-}
-
-PyObject* ConvertToPyObject&lt;uint64_t&gt;::newPyObject(const uint64_t&amp; x)
-{
-    return PyLong_FromUnsignedLongLong(x);
-}
-#endif
-
 PyObject* ConvertToPyObject&lt;double&gt;::newPyObject(const double&amp; x)
 {
     return PyFloat_FromDouble(x);
@@ -763,7 +692,7 @@
 {
     return PyString_FromString(x);
 }
-    
+
 PyObject* ConvertToPyObject&lt;string&gt;::newPyObject(const string&amp; x)
 {
     return PyString_FromString(x.c_str());
@@ -782,7 +711,7 @@
         pyarr = NA_NewArray(NULL, tReal, 1, 0);
     else
         pyarr = NA_NewArray(data.data(), tReal, 1, data.size());
-        
+
     return (PyObject*)pyarr;
 }
 
@@ -792,7 +721,8 @@
     if (data.isNull() || data.isEmpty())
         pyarr = NA_NewArray(NULL, tReal, 2, data.length(), data.width());
     else if (data.mod() == data.width())
-        pyarr = NA_NewArray(data.data(), tReal, 2, data.length(), data.width());
+        pyarr = NA_NewArray(data.data(), tReal, 2, data.length(),
+                            data.width());
     else {
         // static PyObject* NA_NewAll( int ndim, maybelong *shape, NumarrayType
         // type, void *buffer, maybelong byteoffset, maybelong bytestride, int
@@ -810,8 +740,8 @@
         // maybelong shape[2];
         // shape[0] = data.length();
         // shape[1] = data.width();
-        // pyarr = NA_NewAll(2, shape, tReal, data.data(), 0, data.mod()*sizeof(real),
-        //                   NA_ByteOrder(), 1, 1);
+        // pyarr = NA_NewAll(2, shape, tReal, data.data(), 0,
+        //                   data.mod()*sizeof(real), NA_ByteOrder(), 1, 1);
 
         // NOTE (NC) -- I could not get the above function to work; for now,
         // simply copy the matrix to new storage before converting to Python.

Modified: trunk/plearn/python/PythonObjectWrapper.h
===================================================================
--- trunk/plearn/python/PythonObjectWrapper.h	2007-07-28 04:13:58 UTC (rev 7854)
+++ trunk/plearn/python/PythonObjectWrapper.h	2007-07-28 04:33:24 UTC (rev 7855)
@@ -2,23 +2,23 @@
 
 // PythonObjectWrapper.h
 //
-// Copyright (C) 2005-2006 Nicolas Chapados 
+// Copyright (C) 2005-2006 Nicolas Chapados
 // Copyright (C) 2007 Xavier Saint-Mleux, ApSTAT Technologies inc.
-// 
+//
 // Redistribution and use in source and binary forms, with or without
 // modification, are permitted provided that the following conditions are met:
-// 
+//
 //  1. Redistributions of source code must retain the above copyright
 //     notice, this list of conditions and the following disclaimer.
-// 
+//
 //  2. Redistributions in binary form must reproduce the above copyright
 //     notice, this list of conditions and the following disclaimer in the
 //     documentation and/or other materials provided with the distribution.
-// 
+//
 //  3. The name of the authors may not be used to endorse or promote
 //     products derived from this software without specific prior written
 //     permission.
-// 
+//
 // THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
 // IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 // OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
@@ -29,12 +29,12 @@
 // LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-// 
+//
 // This file is part of the PLearn library. For more information on the PLearn
 // library, go to the PLearn Web site at www.plearn.org
 
-/* *******************************************************      
-   * $Id: .pyskeleton_header 544 2003-09-01 00:05:31Z plearner $ 
+/* *******************************************************
+   * $Id: .pyskeleton_header 544 2003-09-01 00:05:31Z plearner $
    ******************************************************* */
 
 // Authors: Nicolas Chapados
@@ -290,21 +290,8 @@
     { return integerFromPyObject&lt;unsigned long long&gt;(pyobj, print_traceback); }
 };
 
-/*
-template &lt;&gt;
-struct ConvertFromPyObject&lt;int64_t&gt;
-{
-    static int64_t convert(PyObject*, bool print_traceback);
-};
 
 template &lt;&gt;
-struct ConvertFromPyObject&lt;uint64_t&gt;
-{
-    static uint64_t convert(PyObject*, bool print_traceback);
-};
-*/
-
-template &lt;&gt;
 struct ConvertFromPyObject&lt;double&gt;
 {
     static double convert(PyObject*, bool print_traceback);
@@ -358,7 +345,8 @@
         //      to retrieve a pointer to something that is not an Object from
         //      python.  Only Object pointers are supported.
 
-        Object* obj = ConvertFromPyObject&lt;Object*&gt;::convert(pyobj, print_traceback);
+        Object* obj = ConvertFromPyObject&lt;Object*&gt;::convert(pyobj,
+                                                            print_traceback);
         if (T* tobj = dynamic_cast&lt;T*&gt;(obj))
             return tobj;
         else
@@ -580,31 +568,31 @@
 //! @TODO  Must provide a complete Python wrapper over VMatrix objects
 template&lt;&gt; struct ConvertToPyObject&lt;PP&lt;VMatrix&gt; &gt;
 { static PyObject* newPyObject(const PP&lt;VMatrix&gt;&amp; vm); };
-    
+
 //! Generic PP: wrap pointed object
 template&lt;class T&gt; struct ConvertToPyObject&lt;PP&lt;T&gt; &gt;
 { static PyObject* newPyObject(const PP&lt;T&gt;&amp;); };
-    
+
 //! tuples (1 to 7 elts.)
-template&lt;class T&gt; 
+template&lt;class T&gt;
 struct ConvertToPyObject&lt;tuple&lt;T&gt; &gt;
 { static PyObject* newPyObject(const tuple&lt;T&gt;&amp;); };
-template &lt;class T, class U&gt; 
+template &lt;class T, class U&gt;
 struct ConvertToPyObject&lt;tuple&lt;T,U&gt; &gt;
 { static PyObject* newPyObject(const tuple&lt;T, U&gt;&amp;); };
-template &lt;class T, class U, class V&gt; 
+template &lt;class T, class U, class V&gt;
 struct ConvertToPyObject&lt;tuple&lt;T,U,V&gt; &gt;
 { static PyObject* newPyObject(const tuple&lt;T, U, V&gt;&amp;); };
-template &lt;class T, class U, class V, class W&gt; 
+template &lt;class T, class U, class V, class W&gt;
 struct ConvertToPyObject&lt;tuple&lt;T,U,V,W&gt; &gt;
 { static PyObject* newPyObject(const tuple&lt;T, U, V, W&gt;&amp;); };
-template &lt;class T, class U, class V, class W, class X&gt; 
+template &lt;class T, class U, class V, class W, class X&gt;
 struct ConvertToPyObject&lt;tuple&lt;T,U,V,W,X&gt; &gt;
 { static PyObject* newPyObject(const tuple&lt;T, U, V, W, X&gt;&amp;); };
-template &lt;class T, class U, class V, class W, class X, class Y&gt; 
+template &lt;class T, class U, class V, class W, class X, class Y&gt;
 struct ConvertToPyObject&lt;tuple&lt;T,U,V,W,X,Y&gt; &gt;
 { static PyObject* newPyObject(const tuple&lt;T, U, V, W, X, Y&gt;&amp;); };
-template &lt;class T, class U, class V, class W, class X, class Y, class Z&gt; 
+template &lt;class T, class U, class V, class W, class X, class Y, class Z&gt;
 struct ConvertToPyObject&lt;tuple&lt;T,U,V,W,X,Y,Z&gt; &gt;
 { static PyObject* newPyObject(const tuple&lt;T, U, V, W, X, Y, Z&gt;&amp;); };
 
@@ -627,7 +615,7 @@
 //! C++ stdlib pair&lt;&gt;: create a Python tuple with two elements
 template &lt;class T, class U&gt; struct ConvertToPyObject&lt;std::pair&lt;T,U&gt; &gt;
 { static PyObject* newPyObject(const std::pair&lt;T,U&gt;&amp;); };
-    
+
 //! Pointer to vector&lt;&gt;: simply dereference pointer, or None if NULL
 //!
 //! (NOTE: we don't have conversion from general pointer type since it's
@@ -702,7 +690,7 @@
     PythonGlobalInterpreterLock()
         : m_gilstate(PyGILState_Ensure())
     { }
-       
+
     ~PythonGlobalInterpreterLock()
     {
         PyGILState_Release(m_gilstate);
@@ -716,8 +704,8 @@
 
 /**
  *  @class  PythonObjectWrapper
- *  @brief  Very lightweight wrapper over a Python Object that allows conversion
- *          to/from C++ types (including those of PLearn)
+ *  @brief  Very lightweight wrapper over a Python Object that allows
+ *          conversion to/from C++ types (including those of PLearn)
  *
  *  A PythonObjectWrapper provides the ability to manage a Python Object in a
  *  fairly lightweight manner.  It supports construction from a number of C++
@@ -746,7 +734,7 @@
         control_ownership,
         transfer_ownership
     };
-    
+
 public:
     //#####  Construction and Utility  ########################################
 
@@ -757,15 +745,16 @@
     //! reference-counted just like any other object.
     PythonObjectWrapper(OwnershipMode o = control_ownership,
                         bool acquire_gil = true /* unused in this overload */);
-    
+
     //! Constructor for pre-existing PyObject
     PythonObjectWrapper(PyObject* pyobj, OwnershipMode o = control_ownership,
                         bool acquire_gil = true /* unused in this overload */);
-    
+
     //! Constructor for general type (forwarded to newPyObject)
     template &lt;class T&gt;
-    explicit PythonObjectWrapper(const T&amp; x, OwnershipMode o = control_ownership,
-                        bool acquire_gil = true)
+    explicit PythonObjectWrapper(const T&amp; x,
+                                 OwnershipMode o = control_ownership,
+                                 bool acquire_gil = true)
         : m_ownership(o)
     {
         if (acquire_gil) {
@@ -778,7 +767,7 @@
 
     //! Copy constructor: increment refcount if controlling ownership.
     PythonObjectWrapper(const PythonObjectWrapper&amp; other);
-    
+
     //! Destructor: decrement refcount if controlling ownership.
     //! Always acquire the Python Global Interpreter Lock before decrementing.
     ~PythonObjectWrapper();
@@ -791,21 +780,21 @@
 
     //! Swap *this with another instance
     void swap(PythonObjectWrapper&amp; other);
-    
+
     //! Return the bare PyObject managed by the wrapper
     PyObject* getPyObject() const
     {
         return m_object;
     }
-    
+
     //! Return true if m_object is either NULL or stands for Python's None
     bool isNull() const;
-    
+
     //! Print out the Python object to stderr for debugging purposes
     void printDebug() const;
 
-    
 
+
     //#####  Conversion Back to C++  ##########################################
 
     //! General version that relies on ConvertFromPyOBject
@@ -826,8 +815,8 @@
     {
         return ConvertFromPyObject&lt;T&gt;::convert(m_object, false);
     }
-    
 
+
     //##### Trampoline for PLearn objects #####################################
 
     static PyObject* trampoline(PyObject* self, PyObject* args);
@@ -849,11 +838,12 @@
      *  initializations related to libnumarray.
      */
     static void initializePython();
-    
+
 protected:
-    OwnershipMode m_ownership;               //!&lt; Whether we own the PyObject or not
+    //! Whether we own the PyObject or not
+    OwnershipMode m_ownership;
     PyObject* m_object;
-    
+
     //for the unique unref injected method
     static bool m_unref_injected;
     static PyMethodDef m_unref_method_def;
@@ -895,8 +885,8 @@
 
 //#####  ConvertFromPyObject Implementations  #################################
 
-template&lt;class U, bool is_enum&gt; 
-struct StaticConvertEnumFromPyObject 
+template&lt;class U, bool is_enum&gt;
+struct StaticConvertEnumFromPyObject
 {
     static U convert(PyObject* x, bool print_traceback)
     {
@@ -905,7 +895,7 @@
         return U();//to silence compiler
     }
 };
-    
+
 template&lt;class U&gt;
 struct StaticConvertEnumFromPyObject&lt;U, true&gt;
 {
@@ -924,7 +914,7 @@
     /*
     if(boost::is_enum&lt;T&gt;::value)
         return ConvertFromPyObject&lt;int&gt;::convert(x, print_traceback);
-    
+
     PLERROR(&quot;Cannot convert this object by value from python (type=%s).&quot;,
             TypeTraits&lt;T&gt;::name().c_str());
     return T();//to silence compiler
@@ -933,7 +923,8 @@
 
 
 template &lt;class T&gt;
-PP&lt;T&gt; ConvertFromPyObject&lt;PP&lt;T&gt; &gt;::convert(PyObject* pyobj, bool print_traceback)
+PP&lt;T&gt; ConvertFromPyObject&lt;PP&lt;T&gt; &gt;::convert(PyObject* pyobj,
+                                           bool print_traceback)
 {
     PLASSERT( pyobj );
     if(pyobj == Py_None)
@@ -952,10 +943,11 @@
 }
 
 template &lt;class T&gt;
-TVec&lt;T&gt; ConvertFromPyObject&lt; TVec&lt;T&gt; &gt;::convert(PyObject* pyobj, bool print_traceback)
+TVec&lt;T&gt; ConvertFromPyObject&lt; TVec&lt;T&gt; &gt;::convert(PyObject* pyobj,
+                                                bool print_traceback)
 {
     PLASSERT( pyobj );
-    
+
     // Here, we support both Python Tuples and Lists
     if (PyTuple_Check(pyobj)) {
         // Tuple case
@@ -985,19 +977,21 @@
 }
 
 template &lt;class T&gt;
-TMat&lt;T&gt; ConvertFromPyObject&lt;TMat&lt;T&gt; &gt;::convert(PyObject* pyobj, bool print_traceback)
+TMat&lt;T&gt; ConvertFromPyObject&lt;TMat&lt;T&gt; &gt;::convert(PyObject* pyobj,
+                                               bool print_traceback)
 {
     PLASSERT( pyobj );
-    
+
     // Here, we support both Python Tuples and Lists
     if (PyTuple_Check(pyobj)) {
         // Tuple case
         int len= PyTuple_GET_SIZE(pyobj);
         TMat&lt;T&gt; v;
-        for(int i= 0; i &lt; len; ++i) 
+        for(int i= 0; i &lt; len; ++i)
         {
             PyObject* row_i= PyTuple_GET_ITEM(pyobj, i);
-            TVec&lt;T&gt; r= ConvertFromPyObject&lt;TVec&lt;T&gt; &gt;::convert(row_i, print_traceback);
+            TVec&lt;T&gt; r= ConvertFromPyObject&lt;TVec&lt;T&gt; &gt;::convert(row_i,
+                                                              print_traceback);
             if(i == 0)
                 v.resize(0, r.size());
             v.appendRow(r);
@@ -1008,10 +1002,11 @@
         // List case
         int len= PyList_GET_SIZE(pyobj);
         TMat&lt;T&gt; v;
-        for(int i= 0; i &lt; len; ++i) 
+        for(int i= 0; i &lt; len; ++i)
         {
             PyObject* row_i= PyList_GET_ITEM(pyobj, i);
-            TVec&lt;T&gt; r= ConvertFromPyObject&lt;TVec&lt;T&gt; &gt;::convert(row_i, print_traceback);
+            TVec&lt;T&gt; r= ConvertFromPyObject&lt;TVec&lt;T&gt; &gt;::convert(row_i,
+                                                              print_traceback);
             if(i == 0)
                 v.resize(0, r.size());
             v.appendRow(r);
@@ -1031,7 +1026,7 @@
                                                               bool print_traceback)
 {
     PLASSERT( pyobj );
-    
+
     // Simple but inefficient implementation: create temporary TVec and copy
     // into a vector
     TVec&lt;T&gt; v = ConvertFromPyObject&lt; TVec&lt;T&gt; &gt;::convert(pyobj, print_traceback);
@@ -1046,7 +1041,7 @@
     if (! PyDict_Check(pyobj))
         PLPythonConversionError(&quot;ConvertFromPyObject&lt; std::map&lt;T,U&gt; &gt;&quot;, pyobj,
                                 print_traceback);
-    
+
     PyObject *key, *value;
 #if PL_PYTHON_VERSION&gt;=250
     Py_ssize_t pos = 0;
@@ -1088,7 +1083,7 @@
 
 //#####  newPyObject Implementations  #########################################
 
-template&lt;size_t N&gt; 
+template&lt;size_t N&gt;
 PyObject*  ConvertToPyObject&lt;char[N]&gt;::newPyObject(const char x[N])
 {
     return ConvertToPyObject&lt;char*&gt;::newPyObject(x);
@@ -1123,12 +1118,12 @@
 PyObject* ConvertToPyObject&lt;TMat&lt;T&gt; &gt;::newPyObject(const TMat&lt;T&gt;&amp; data)
 {
     PyObject* newlist = PyList_New(data.length());
-    for (int i=0, n=data.length() ; i&lt;n ; ++i) 
+    for (int i=0, n=data.length() ; i&lt;n ; ++i)
     {
         // Since PyList_SET_ITEM steals the reference to the item being set,
         // one does not need to Py_XDECREF the inserted string as was required
         // for the PyArrayObject code above...
-        PyList_SET_ITEM(newlist, i, 
+        PyList_SET_ITEM(newlist, i,
                         ConvertToPyObject&lt;TVec&lt;T&gt; &gt;::newPyObject(data(i)));
     }
     return newlist;
@@ -1146,7 +1141,7 @@
     }
     return newlist;
 }
-    
+
 template &lt;class T, class U&gt;
 PyObject* ConvertToPyObject&lt;std::map&lt;T,U&gt; &gt;::newPyObject(const std::map&lt;T,U&gt;&amp; data)
 {


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001302.html">[Plearn-commits] r7854 - trunk/plearn/python
</A></li>
	<LI>Next message: <A HREF="001304.html">[Plearn-commits] r7856 - in trunk/python_modules/plearn: .	learners/autolr learners/online
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1303">[ date ]</a>
              <a href="thread.html#1303">[ thread ]</a>
              <a href="subject.html#1303">[ subject ]</a>
              <a href="author.html#1303">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/plearn-commits">More information about the Plearn-commits
mailing list</a><br>
</body></html>
