<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Plearn-commits] r7842 - in trunk/plearn: base io
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/plearn-commits/2007-July/index.html" >
   <LINK REL="made" HREF="mailto:plearn-commits%40lists.berlios.de?Subject=Re%3A%20%5BPlearn-commits%5D%20r7842%20-%20in%20trunk/plearn%3A%20base%20io&In-Reply-To=%3C200707270342.l6R3g6HD003586%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001289.html">
   <LINK REL="Next"  HREF="001291.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Plearn-commits] r7842 - in trunk/plearn: base io</H1>
    <B>lamblin at BerliOS</B> 
    <A HREF="mailto:plearn-commits%40lists.berlios.de?Subject=Re%3A%20%5BPlearn-commits%5D%20r7842%20-%20in%20trunk/plearn%3A%20base%20io&In-Reply-To=%3C200707270342.l6R3g6HD003586%40sheep.berlios.de%3E"
       TITLE="[Plearn-commits] r7842 - in trunk/plearn: base io">lamblin at mail.berlios.de
       </A><BR>
    <I>Fri Jul 27 05:42:06 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="001289.html">[Plearn-commits] r7841 - trunk/plearn/io
</A></li>
        <LI>Next message: <A HREF="001291.html">[Plearn-commits] r7843 - trunk/plearn/io
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1290">[ date ]</a>
              <a href="thread.html#1290">[ thread ]</a>
              <a href="subject.html#1290">[ subject ]</a>
              <a href="author.html#1290">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: lamblin
Date: 2007-07-27 05:42:04 +0200 (Fri, 27 Jul 2007)
New Revision: 7842

Modified:
   trunk/plearn/base/TypeTraits.h
   trunk/plearn/base/byte_order.h
   trunk/plearn/io/PStream.cc
   trunk/plearn/io/PStream.h
Log:
Cosmetic changes.


Modified: trunk/plearn/base/TypeTraits.h
===================================================================
--- trunk/plearn/base/TypeTraits.h	2007-07-27 03:12:55 UTC (rev 7841)
+++ trunk/plearn/base/TypeTraits.h	2007-07-27 03:42:04 UTC (rev 7842)
@@ -5,18 +5,18 @@
 //
 // Redistribution and use in source and binary forms, with or without
 // modification, are permitted provided that the following conditions are met:
-// 
+//
 //  1. Redistributions of source code must retain the above copyright
 //     notice, this list of conditions and the following disclaimer.
-// 
+//
 //  2. Redistributions in binary form must reproduce the above copyright
 //     notice, this list of conditions and the following disclaimer in the
 //     documentation and/or other materials provided with the distribution.
-// 
+//
 //  3. The name of the authors may not be used to endorse or promote
 //     products derived from this software without specific prior written
 //     permission.
-// 
+//
 // THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
 // IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 // OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
@@ -27,13 +27,13 @@
 // LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-// 
+//
 // This file is part of the PLearn library. For more information on the PLearn
 // library, go to the PLearn Web site at www.plearn.org
 
 
- 
-/* *******************************************************      
+
+/* *******************************************************
  * $Id$
  * AUTHORS: Pascal Vincent
  * This file is part of the PLearn library.
@@ -65,11 +65,12 @@
  *  @li Its \c name(), returned as a string
  *
  *  @li The &quot;typecode&quot;, which is the header-byte used to indicate type of an
- *      element to follow in plearn_binary serialization. \c little_endian_typecode()
- *      and \c big_endian_typecode() respectively return the code to designate
- *      little-endian or big-endian representation.  Only the very basic C++ types
- *      have specific typecodes. For all other more complex types, these functions
- *      should always return 0xFF.
+ *      element to follow in plearn_binary serialization.
+ *      \c little_endian_typecode() and \c big_endian_typecode() respectively
+ *      return the code to designate little-endian or big-endian
+ *      representation.  Only the very basic C++ types have specific typecodes.
+ *      For all other more complex types, these functions should always
+ *      return 0xFF.
  */
 template&lt;class T&gt;
 class TypeTraits
@@ -98,7 +99,7 @@
 class TypeTraits&lt;T*&gt;
 {
 public:
-    static inline string name() 
+    static inline string name()
     { return TypeTraits&lt;T&gt;::name()+&quot;*&quot;; }
 
     static inline unsigned char little_endian_typecode()
@@ -112,7 +113,7 @@
 class TypeTraits&lt;T const&gt;
 {
 public:
-    static inline string name() 
+    static inline string name()
     { return TypeTraits&lt;T&gt;::name()+&quot; const&quot;; }
 
     static inline unsigned char little_endian_typecode()
@@ -264,7 +265,7 @@
 {
 public:
     static inline string name()
-    { return string(&quot;vector&lt; &quot;) + TypeTraits&lt;T&gt;::name()+&quot; &gt;&quot;; }
+    { return string(&quot;vector&lt; &quot;) + TypeTraits&lt;T&gt;::name() + &quot; &gt;&quot;; }
 
     static inline unsigned char little_endian_typecode()
     { return 0xFF; }
@@ -278,7 +279,7 @@
 {
 public:
     static inline string name()
-    { return string(&quot;list&lt; &quot;) + TypeTraits&lt;T&gt;::name()+&quot; &gt;&quot;; }
+    { return string(&quot;list&lt; &quot;) + TypeTraits&lt;T&gt;::name() + &quot; &gt;&quot;; }
 
     static inline unsigned char little_endian_typecode()
     { return 0xFF; }
@@ -292,7 +293,10 @@
 {
 public:
     static inline string name()
-    { return string(&quot;pair&lt; &quot;) + TypeTraits&lt;T&gt;::name()+&quot;, &quot; + TypeTraits&lt;U&gt;::name()+&quot; &gt;&quot;; }
+    {
+        return string(&quot;pair&lt; &quot;) + TypeTraits&lt;T&gt;::name()+&quot;, &quot;
+            + TypeTraits&lt;U&gt;::name() + &quot; &gt;&quot;;
+    }
 
     static inline unsigned char little_endian_typecode()
     { return 0xFF; }
@@ -306,7 +310,10 @@
 {
 public:
     static inline string name()
-    { return string(&quot;map&lt; &quot;) + TypeTraits&lt;T&gt;::name()+&quot;, &quot; + TypeTraits&lt;U&gt;::name()+&quot; &gt;&quot;; }
+    {
+        return string(&quot;map&lt; &quot;) + TypeTraits&lt;T&gt;::name()+&quot;, &quot;
+            + TypeTraits&lt;U&gt;::name() + &quot; &gt;&quot;;
+    }
 
     static inline unsigned char little_endian_typecode()
     { return 0xFF; }
@@ -320,7 +327,7 @@
 {
 public:
     static inline string name()
-    { return string(&quot;set&lt; &quot;) + TypeTraits&lt;T&gt;::name()+&quot; &gt;&quot;; }
+    { return string(&quot;set&lt; &quot;) + TypeTraits&lt;T&gt;::name() + &quot; &gt;&quot;; }
 
     static inline unsigned char little_endian_typecode()
     { return 0xFF; }

Modified: trunk/plearn/base/byte_order.h
===================================================================
--- trunk/plearn/base/byte_order.h	2007-07-27 03:12:55 UTC (rev 7841)
+++ trunk/plearn/base/byte_order.h	2007-07-27 03:42:04 UTC (rev 7842)
@@ -5,18 +5,18 @@
 //
 // Redistribution and use in source and binary forms, with or without
 // modification, are permitted provided that the following conditions are met:
-// 
+//
 //  1. Redistributions of source code must retain the above copyright
 //     notice, this list of conditions and the following disclaimer.
-// 
+//
 //  2. Redistributions in binary form must reproduce the above copyright
 //     notice, this list of conditions and the following disclaimer in the
 //     documentation and/or other materials provided with the distribution.
-// 
+//
 //  3. The name of the authors may not be used to endorse or promote
 //     products derived from this software without specific prior written
 //     permission.
-// 
+//
 // THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
 // IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 // OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
@@ -27,7 +27,7 @@
 // LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-// 
+//
 // This file is part of the PLearn library. For more information on the PLearn
 // library, go to the PLearn Web site at www.plearn.org
 
@@ -36,7 +36,8 @@
 #define byte_order_INC
 
 // norman:
-// If I don't add a definition of the namespace std .NET it does not compile (weird..)!
+// If I don't add a definition of the namespace std .NET it does not compile
+// (weird..)!
 #ifdef WIN32
 #include &lt;string&gt;
 #endif
@@ -55,7 +56,7 @@
 inline char byte_order()
 {
 #ifdef BIGENDIAN
-    return BIG_ENDIAN_ORDER; 
+    return BIG_ENDIAN_ORDER;
 #else
     return LITTLE_ENDIAN_ORDER;
 #endif
@@ -69,7 +70,8 @@
 //! swaps endians for n 8-byte elements (such as double)
 void endianswap8(void* ptr, int n);
 
-//! calls endianswap2,4, or 8 depending on elemsize (an elemsize of 1 is also valid and does nothing)
+//! calls endianswap2, 4, or 8 depending on elemsize
+//! (an elemsize of 1 is also valid and does nothing)
 inline void endianswap(void* ptr, int nelems, int elemsize)
 {
     switch(elemsize)
@@ -91,23 +93,6 @@
 }
 
 
-/*
-// Version for char and unsigned char (I know this is useless, but some code relies on it being defined)
-inline void endianswap(char* ptr, int n=1) {}
-inline void endianswap(signed char* ptr, int n=1) {}
-inline void endianswap(unsigned char* ptr, int n=1) {}
-
-// Versions for short, int, long, float and double
-inline void endianswap(short* ptr, int n=1) { endianswap(ptr,n,sizeof(short)); }
-inline void endianswap(unsigned short* ptr, int n=1) { endianswap(ptr,n,sizeof(unsigned short)); }
-inline void endianswap(int* ptr, int n=1) { endianswap(ptr,n,sizeof(int)); }
-inline void endianswap(unsigned int* ptr, int n=1) { endianswap(ptr,n,sizeof(unsigned int)); }
-inline void endianswap(long* ptr, int n=1) { endianswap(ptr,n,sizeof(long)); }
-inline void endianswap(unsigned long* ptr, int n=1) { endianswap(ptr,n,sizeof(unsigned long)); }
-inline void endianswap(float* ptr, int n=1) { endianswap(ptr,n,sizeof(float)); }
-inline void endianswap(double* ptr, int n=1) { endianswap(ptr,n,sizeof(double)); }
-*/
-
 template&lt;class T&gt;
 inline void endianswap(T* ptr, int n=1)
 { endianswap(ptr,n,sizeof(T)); }

Modified: trunk/plearn/io/PStream.cc
===================================================================
--- trunk/plearn/io/PStream.cc	2007-07-27 03:12:55 UTC (rev 7841)
+++ trunk/plearn/io/PStream.cc	2007-07-27 03:42:04 UTC (rev 7842)
@@ -2,7 +2,8 @@
 
 // PStream.cc
 // Copyright (C) 1998 Pascal Vincent
-// Copyright (C) 1999-2001 Pascal Vincent, Yoshua Bengio and University of Montreal
+// Copyright (C) 1999-2001 Pascal Vincent, Yoshua Bengio and
+//  University of Montreal
 // Copyright (C) 2002 Frederic Morin, Xavier Saint-Mleux, Pascal Vincent
 // Copyright (C) 2007 Xavier Saint-Mleux, ApSTAT Technologies inc.
 //
@@ -1918,41 +1919,6 @@
     }
 }
 
-/*
-#define IMPLEMENT_TYPICAL_BASETYPE_BINREAD_(BASETYPE)  \
-void binread_(PStream&amp; in, BASETYPE* x,                \
-              unsigned int n, unsigned char typecode)  \
-{                                                      \
-  if(typecode==TypeTraits&lt;BASETYPE&gt;::little_endian_typecode()) \
-    {                                                  \
-      in.read((char*)x, streamsize(n*sizeof(BASETYPE)));       \
-      if(byte_order()==BIG_ENDIAN_ORDER)               \
-        endianswap(x,n);                               \
-    }                                                  \
-  else if(typecode==TypeTraits&lt;BASETYPE&gt;::big_endian_typecode()) \
-    {                                                  \
-      in.read((char*)x, streamsize(n*sizeof(BASETYPE)));       \
-      if(byte_order()==LITTLE_ENDIAN_ORDER)            \
-        endianswap(x,n);                               \
-    }                                                  \
-  else                                                 \
-    PLERROR(&quot;In binread_ incompatible typecode&quot;);      \
-}
-
-
-// IMPLEMENT_TYPICAL_BASETYPE_BINREAD_(char);
-IMPLEMENT_TYPICAL_BASETYPE_BINREAD_(short)
-IMPLEMENT_TYPICAL_BASETYPE_BINREAD_(unsigned short)
-IMPLEMENT_TYPICAL_BASETYPE_BINREAD_(int)
-IMPLEMENT_TYPICAL_BASETYPE_BINREAD_(unsigned int)
-IMPLEMENT_TYPICAL_BASETYPE_BINREAD_(long)
-IMPLEMENT_TYPICAL_BASETYPE_BINREAD_(unsigned long)
-IMPLEMENT_TYPICAL_BASETYPE_BINREAD_(long)
-IMPLEMENT_TYPICAL_BASETYPE_BINREAD_(unsigned long)
-//IMPLEMENT_TYPICAL_BASETYPE_BINREAD_(int64_t)
-//IMPLEMENT_TYPICAL_BASETYPE_BINREAD_(uint64_t)
-*/
-
 #define IMPLEMENT_NUMTYPE_BINREAD_(NUMTYPE)                                 \
 void binread_(PStream&amp; in, NUMTYPE* x,                                      \
               unsigned int n, unsigned char typecode)                       \
@@ -2007,98 +1973,6 @@
 IMPLEMENT_NUMTYPE_BINREAD_(float)
 IMPLEMENT_NUMTYPE_BINREAD_(double)
 
-/*
-void binread_(PStream&amp; in, double* x, unsigned int n, unsigned char typecode)
-{
-    if(typecode==TypeTraits&lt;double&gt;::little_endian_typecode())
-    {
-        in.read((char*)x, streamsize(n*sizeof(double)));
-#ifdef BIGENDIAN
-        endianswap(x,n);
-#endif
-    }
-    else if(typecode==TypeTraits&lt;double&gt;::big_endian_typecode())
-    {
-        in.read((char*)x, streamsize(n*sizeof(double)));
-#ifdef LITTLEENDIAN
-        endianswap(x,n);
-#endif
-    }
-    else if(typecode==TypeTraits&lt;float&gt;::little_endian_typecode())
-    {
-        float val;
-        while(n--)
-        {
-            in.read((char*)&amp;val, sizeof(float));
-#ifdef BIGENDIAN
-            endianswap(&amp;val);
-#endif
-            *x++ = double(val);
-        }
-    }
-    else if(typecode==TypeTraits&lt;float&gt;::big_endian_typecode())
-    {
-        float val;
-        while(n--)
-        {
-            in.read((char*)&amp;val, sizeof(float));
-#ifdef LITTLEENDIAN
-            endianswap(&amp;val);
-#endif
-            *x++ = double(val);
-        }
-    }
-    else
-        PLERROR(&quot;In binread_ incompatible typecode&quot;);
-}
-
-
-
-void binread_(PStream&amp; in, float* x, unsigned int n, unsigned char typecode)
-{
-    if(typecode==TypeTraits&lt;float&gt;::little_endian_typecode())
-    {
-        in.read((char*)x, streamsize(n*sizeof(float)));
-#ifdef BIGENDIAN
-        endianswap(x,n);
-#endif
-    }
-    else if(typecode==TypeTraits&lt;float&gt;::big_endian_typecode())
-    {
-        in.read((char*)x, streamsize(n*sizeof(float)));
-#ifdef LITTLEENDIAN
-        endianswap(x,n);
-#endif
-    }
-    else if(typecode==TypeTraits&lt;double&gt;::little_endian_typecode())
-    {
-        double val;
-        while(n--)
-        {
-            in.read((char*)&amp;val, sizeof(double));
-#ifdef BIGENDIAN
-            endianswap(&amp;val);
-#endif
-            *x++ = float(val);
-        }
-    }
-    else if(typecode==TypeTraits&lt;double&gt;::big_endian_typecode())
-    {
-        double val;
-        while(n--)
-        {
-            in.read((char*)&amp;val, sizeof(double));
-#ifdef LITTLEENDIAN
-            endianswap(&amp;val);
-#endif
-            *x++ = float(val);
-        }
-    }
-    else
-        PLERROR(&quot;In binread_ incompatible typecode&quot;);
-}
-*/
-
 } //end of namespace PLearn
 
 

Modified: trunk/plearn/io/PStream.h
===================================================================
--- trunk/plearn/io/PStream.h	2007-07-27 03:12:55 UTC (rev 7841)
+++ trunk/plearn/io/PStream.h	2007-07-27 03:42:04 UTC (rev 7842)
@@ -2,7 +2,8 @@
 
 // PStream.h
 // Copyright (C) 1998 Pascal Vincent
-// Copyright (C) 1999-2001 Pascal Vincent, Yoshua Bengio and University of Montreal
+// Copyright (C) 1999-2001 Pascal Vincent, Yoshua Bengio and
+//  University of Montreal
 // Copyright (C) 2002 Frederic Morin, Xavier Saint-Mleux, Pascal Vincent
 // Copyright (C) 2007 Xavier Saint-Mleux, ApSTAT Technologies inc.
 //
@@ -55,17 +56,19 @@
 
 /*!
  * PStream:
- *  This class defines a type of stream that should be used for all I/O within PLearn.
- *  It supports most operations available for standard c++ streams, plus:
- *   - a set of option flags that indicate which types of Object Options should be
- *     read/written (option_flags_{in|out}; has effect only for Object's);
- *   - a set of mode flags that define format used for I/O. e.g.:  &quot;raw_ascii&quot; for
- *     standard c++ stream behaviour, &quot;plearn_ascii&quot;  for human-readable
- *     serialization format, etc. (inmode and outmode);
+ *  This class defines a type of stream that should be used for all I/O within
+ *  PLearn.
+ *  It supports most operations available for standard C++ streams, plus:
+ *   - a set of option flags that indicate which types of Object Options should
+ *     be read/written (option_flags_{in|out}; has effect only for Object's);
+ *   - a set of mode flags that define format used for I/O. e.g.:
+ *      &quot;raw_ascii&quot; for  standard C++ stream behaviour,
+ *      &quot;plearn_ascii&quot;  for human-readable serialization format,
+ *      etc. (inmode and outmode);
  *   - a copies map to allow smart serialization of pointers;
- *   - a markable stream buffer which allows to 'seek back' to a previously set mark
- *     on any type of istream;
- *   - an 'attach' function to attach the stream to a POSIX file descriptor;
+ *   - a markable stream buffer which allows to 'seek back' to a previously set
+ *     mark on any type of istream;
+ *   - an 'attach' function to attach the stream to a POSIX file descriptor.
  */
 
 class PStream : public PP&lt;PStreamBuf&gt;
@@ -95,31 +98,54 @@
      */
     enum mode_t
     {
-        plearn_ascii,    //!&lt; PLearn ascii serialization format (can be mixed with plearn_binary)
-        plearn_binary,   //!&lt; PLearn binary serialization format (can be mixed with plearn_ascii)
-        raw_ascii,       //!&lt; Raw C++ ascii output without additional separators (direct output to underlying ostream)
-        raw_binary,      //!&lt; Simply writes the bytes as they are in memory.
-        pretty_ascii     //!&lt; Ascii pretty print (in particular for Vec and Mat, formatted output without size info)
+        //! PLearn ascii serialization format (can be mixed with plearn_binary)
+        plearn_ascii,
+        //! PLearn binary serialization format (can be mixed with plearn_ascii)
+        plearn_binary,
+        //! Raw C++ ascii output without additional separators
+        //! (direct output to underlying ostream)
+        raw_ascii,
+        //! Simply writes the bytes as they are in memory.
+        raw_binary,
+        //! Ascii pretty print (in particular for Vec and Mat, formatted output
+        //! without size info)
+        pretty_ascii
     };
 
 
-    //! Compression mode (mostly used by binary serialization of sequences of floats or doubles, such as TMat&lt;real&gt;)
+    //! Compression mode (mostly used by binary serialization of sequences of
+    //! floats or doubles, such as TMat&lt;real&gt;)
     //! (Used on output only; autodetect on read).
     enum compr_mode_t {
-        compr_none,            //!&lt; No compression.
-        compr_double_as_float, //!&lt; In plearn_binary mode, store doubles as float
-        compr_sparse,          //!&lt; PLearn
-        compr_lossy_sparse     //!&lt; Also stores double as float
+        //! No compression.
+        compr_none,
+        //! In plearn_binary mode, store doubles as float
+        compr_double_as_float,
+        //! PLearn
+        compr_sparse,
+        //! Also stores double as float
+        compr_lossy_sparse
     };
 
 public:
-    mode_t inmode;              //!&lt; mode for input formatting
-    // bitset&lt;32&gt; pl_stream_flags_in;  //!&lt; format flags for input
-    map&lt;unsigned int, void *&gt; copies_map_in; //!&lt; copies map for input
-    mode_t outmode;            //!&lt; mode for output formatting
-    // bitset&lt;32&gt; pl_stream_flags_out; //!&lt; format flags for output
-    map&lt;void *, unsigned int&gt; copies_map_out; //!&lt; copies map for output
+    //! mode for input formatting
+    mode_t inmode;
 
+    //! format flags for input
+    // bitset&lt;32&gt; pl_stream_flags_in;
+
+    //! copies map for input
+    map&lt;unsigned int, void *&gt; copies_map_in;
+
+    //! mode for output formatting
+    mode_t outmode;
+
+    //! format flags for output
+    // bitset&lt;32&gt; pl_stream_flags_out;
+
+    //! copies map for output
+    map&lt;void *, unsigned int&gt; copies_map_out;
+
 private:
     //! Buffer for some formatting operations
     static char tmpbuf[100];
@@ -137,16 +163,16 @@
     static const char* format_double_default;
 
 public:
-    //! If true, then Mat and Vec will be serialized with their elements in place,
+    //! If true, then Mat and Vec will be serialized with their elements in
+    //! place,
     //! If false, they will have an explicit pointer to a storage
     bool implicit_storage;
 
     //! Determines the way data is compressed, if any.
     compr_mode_t compression_mode;
 
-    //! Should be true if this stream is used to communicate
-    //! with a remote PLearn host.  Will serialize options
-    //! accordingly.
+    //! Should be true if this stream is used to communicate with a remote
+    //! PLearn host.  Will serialize options accordingly.
     bool remote_plearn_comm;
 
 public:
@@ -166,39 +192,80 @@
     PStream(iostream* pios_, bool own_pios_=false);
 
     //! ctor. from an istream and an ostream (IO)
-    PStream(istream* pin_, ostream* pout_, bool own_pin_=false, bool own_pout_=false);
+    PStream(istream* pin_, ostream* pout_, bool own_pin_=false,
+            bool own_pout_=false);
 
     //! Default copy ctor. should be fine now.
 
     //! Destructor.
     virtual ~PStream();
 
-    inline void setBufferCapacities(streamsize inbuf_capacity, streamsize outbuf_capacity, streamsize unget_capacity)
-    { ptr-&gt;setBufferCapacities(inbuf_capacity, outbuf_capacity, unget_capacity); }
+    inline void setBufferCapacities(streamsize inbuf_capacity,
+                                    streamsize outbuf_capacity,
+                                    streamsize unget_capacity)
+    {
+        ptr-&gt;setBufferCapacities(inbuf_capacity,
+                                 outbuf_capacity,
+                                 unget_capacity);
+    }
 
-    inline mode_t setInMode(mode_t m) { mode_t oldmode = inmode; inmode = m; return oldmode; }
-    inline mode_t setOutMode(mode_t m) { mode_t oldmode = outmode; outmode = m; return oldmode; }
-    inline void setMode(mode_t m) { inmode = m; outmode = m; }
+    inline mode_t setInMode(mode_t m)
+    {
+        mode_t oldmode = inmode;
+        inmode = m;
+        return oldmode;
+    }
 
-    inline void clearOutMap() { copies_map_out.clear(); }
-    inline void clearInMap()  { copies_map_in.clear(); }
-    inline void clearInOutMaps()  { clearInMap(); clearOutMap(); }
+    inline mode_t setOutMode(mode_t m)
+    {
+        mode_t oldmode = outmode;
+        outmode = m;
+        return oldmode;
+    }
 
+    inline void setMode(mode_t m)
+    { inmode = m; outmode = m; }
+
+    inline void clearOutMap()
+    { copies_map_out.clear(); }
+
+    inline void clearInMap()
+    { copies_map_in.clear(); }
+
+    inline void clearInOutMaps()
+    {
+        clearInMap();
+        clearOutMap();
+    }
+
     //! if outmode is raw_ascii or raw_binary, it will be switched to
     //! corresponding plearn_ascii, resp. plearn_binary.
     //! The old mode will be returned, so that you can call setOutMode
     //! to revert to the old mode when finished
     mode_t switchToPLearnOutMode();
 
-    PStream&amp; operator&gt;&gt;(mode_t m) { inmode = m; return *this; }
-    PStream&amp; operator&lt;&lt;(mode_t m) { outmode = m; return *this; }
+    PStream&amp; operator&gt;&gt;(mode_t m)
+    {
+        inmode = m;
+        return *this;
+    }
 
+    PStream&amp; operator&lt;&lt;(mode_t m)
+    {
+        outmode = m;
+        return *this;
+    }
+
 public:
     //op()'s: re-init with different underlying stream(s)
 
     PStream&amp; operator=(const PStream&amp; pios);
+
     PStream&amp; operator=(streambuftype* streambuf)
-    { inherited::operator=(streambuf); return *this; }
+    {
+        inherited::operator=(streambuf);
+        return *this;
+    }
 
     bool operator==(const PStream&amp; other)
     { return PP&lt;PStreamBuf&gt;::operator==(other); }
@@ -490,7 +557,8 @@
         return *this;
     }
 
-    // These are convenient method for writing raw strings (whatever the outmode):
+    // These are convenient method for writing raw strings
+    // (whatever the outmode):
     inline PStream&amp; write(const char* s)
     {
         write(s, streamsize(strlen(s)));
@@ -520,15 +588,21 @@
     //! skips all occurences of any of the given characters
     void skipAll(const char* chars_to_skip);
 
-    //! Reads characters from stream, until we meet one of the stopping symbols at the current &quot;level&quot;.
-    //! i.e. any opening parenthesis, bracket, brace or quote will open a next level and we'll
-    //! be back to the current level only *after* we meet the corresponding closing parenthesis,
-    //! bracket, brace or quote.
-    //! All characters read, except the stoppingsymbol, will be *appended* to characters_read
-    //! The stoppingsymbol is read and returned, but not appended to characters_read.
-    //! Comments starting with # until the end of line may be skipped (as if they were not part of the stream)
-    int smartReadUntilNext(const string&amp; stoppingsymbols, string&amp; characters_read,
-                           bool ignore_brackets=false, bool skip_comments=true);
+    //! Reads characters from stream, until we meet one of the stopping symbols
+    //! at the current &quot;level&quot;. i.e. any opening parenthesis, bracket, brace or
+    //! quote will open a next level and we'll be back to the current level
+    //! only *after* we meet the corresponding closing parenthesis, bracket,
+    //! brace or quote.
+    //! All characters read, except the stoppingsymbol, will be *appended* to
+    //! characters_read.
+    //! The stoppingsymbol is read and returned, but not appended to
+    //! characters_read.
+    //! Comments starting with # until the end of line may be skipped (as if
+    //! they were not part of the stream)
+    int smartReadUntilNext(const string&amp; stoppingsymbols,
+                           string&amp; characters_read,
+                           bool ignore_brackets=false,
+                           bool skip_comments=true);
 
     //! Count the number of occurrences of a character in the stream.
     int count(char c);
@@ -537,7 +611,8 @@
     PStream&amp; operator&gt;&gt;(float &amp;x);
     PStream&amp; operator&gt;&gt;(double &amp;x);
     PStream&amp; operator&gt;&gt;(string &amp;x);
-    PStream&amp; operator&gt;&gt;(char* x); // read string in already allocated char[]
+    // read string in already allocated char[]
+    PStream&amp; operator&gt;&gt;(char* x);
     PStream&amp; operator&gt;&gt;(char &amp;x);
     PStream&amp; operator&gt;&gt;(signed char &amp;x);
     PStream&amp; operator&gt;&gt;(unsigned char &amp;x);
@@ -550,7 +625,8 @@
     PStream&amp; operator&gt;&gt;(unsigned long &amp;x);
     PStream&amp; operator&gt;&gt;(long long &amp;x);
     PStream&amp; operator&gt;&gt;(unsigned long long &amp;x);
-    PStream&amp; operator&gt;&gt;(pl_pstream_manip func) { return (*func)(*this); }
+    PStream&amp; operator&gt;&gt;(pl_pstream_manip func)
+    { return (*func)(*this); }
 
     // operator&lt;&lt;'s for base types
     PStream&amp; operator&lt;&lt;(float x);
@@ -572,8 +648,9 @@
     PStream&amp; operator&lt;&lt;(signed char x);
     PStream&amp; operator&lt;&lt;(unsigned char x);
 
-    // Note: If you get mysterious mesages of problems with const bool resolutions,
-    // then a workaround might be to not declare &lt;&lt;(bool) as a method, but as an inline function
+    // Note: If you get mysterious mesages of problems with const bool
+    // resolutions, then a workaround might be to not declare &lt;&lt;(bool) as a
+    // method, but as an inline function
     PStream&amp; operator&lt;&lt;(bool x);
     PStream&amp; operator&lt;&lt;(short x);
     PStream&amp; operator&lt;&lt;(unsigned short x);
@@ -631,7 +708,8 @@
         in.get(); // Eat '*'
         unsigned int id;
         in &gt;&gt; id;
-        //don't skip blanks before we need to read something else (read might block).
+        // don't skip blanks before we need to read something else
+        // (read might block).
         //in.skipBlanksAndCommentsAndSeparators();
         if (id==0)
             x = 0;
@@ -644,31 +722,35 @@
                 char cc = in.get();
                 if(cc != '&gt;') // Eat '&gt;'
                     PLERROR(&quot;In PStream::operator&gt;&gt;(T*&amp;)  Wrong format.  Expecting \&quot;*%d-&gt;\&quot; but got \&quot;*%d-%c\&quot;.&quot;, id, id, cc);
-                //don't skip blanks before we need to read something else (read might block).
+                // don't skip blanks before we need to read something else
+                // (read might block).
                 //in.skipBlanksAndCommentsAndSeparators();
                 if(!x)
-                    x= new T();
+                    x = new T();
                 in.skipBlanksAndCommentsAndSeparators();
                 in &gt;&gt; *x;
-                //don't skip blanks before we need to read something else (read might block).
+                // don't skip blanks before we need to read something else
+                // (read might block).
                 //in.skipBlanksAndCommentsAndSeparators();
                 in.copies_map_in[id]= x;
             }
             else
             {
                 // Find it in map and return ptr;
-                map&lt;unsigned int, void *&gt;::iterator it = in.copies_map_in.find(id);
+                map&lt;unsigned int, void *&gt;::iterator it =
+                    in.copies_map_in.find(id);
                 if (it == in.copies_map_in.end())
                     PLERROR(&quot;In PStream::operator&gt;&gt;(T*&amp;) object (ptr) to be read with id='%d' &quot;
                             &quot;has not been previously defined&quot;, id);
-                x= static_cast&lt;T *&gt;(it-&gt;second);
+                x = static_cast&lt;T *&gt;(it-&gt;second);
             }
         }
     }
     else
     {
         in &gt;&gt; *x;
-        //don't skip blanks before we need to read something else (read might block).
+        // don't skip blanks before we need to read something else
+        // (read might block).
         //in.skipBlanksAndCommentsAndSeparators();
     }
 
@@ -681,7 +763,8 @@
 {
     if(x)
     {
-        map&lt;void *, unsigned int&gt;::iterator it = out.copies_map_out.find(const_cast&lt;T*&amp;&gt;(x));
+        map&lt;void *, unsigned int&gt;::iterator it =
+            out.copies_map_out.find(const_cast&lt;T*&amp;&gt;(x));
         if (it == out.copies_map_out.end())
         {
             int id = (int)out.copies_map_out.size()+1;
@@ -869,42 +952,73 @@
 }
 
 template&lt;class Key, class Value, class Compare, class Alloc&gt;
-inline PStream&amp; operator&lt;&lt;(PStream&amp; out, const map&lt;Key, Value, Compare, Alloc&gt;&amp; m)
-{ writeMap(out, m); return out; }
+inline PStream&amp; operator&lt;&lt;(PStream&amp; out,
+                           const map&lt;Key, Value, Compare, Alloc&gt;&amp; m)
+{
+    writeMap(out, m);
+    return out;
+}
 
 template&lt;class Key, class Value, class Compare, class Alloc&gt;
 inline PStream&amp; operator&gt;&gt;(PStream&amp; in, map&lt;Key, Value, Compare, Alloc&gt;&amp; m)
-{ readMap(in, m); return in; }
+{
+    readMap(in, m);
+    return in;
+}
 
 template&lt;class Key, class Value, class Compare, class Alloc&gt;
-inline PStream&amp; operator&lt;&lt;(PStream&amp; out, const multimap&lt;Key, Value, Compare, Alloc&gt;&amp; m)
-{ writeMap(out, m); return out; }
+inline PStream&amp; operator&lt;&lt;(PStream&amp; out,
+                           const multimap&lt;Key, Value, Compare, Alloc&gt;&amp; m)
+{
+    writeMap(out, m);
+    return out;
+}
 
 template&lt;class Key, class Value, class Compare, class Alloc&gt;
-inline PStream&amp; operator&gt;&gt;(PStream&amp; in, multimap&lt;Key, Value, Compare, Alloc&gt;&amp; m)
-{ readMap(in, m); return in; }
+inline PStream&amp; operator&gt;&gt;(PStream&amp; in,
+                           multimap&lt;Key, Value, Compare, Alloc&gt;&amp; m)
+{
+    readMap(in, m);
+    return in;
+}
 
 
 template&lt;class Key, class Value, class Compare, class Alloc&gt;
-inline PStream&amp; operator&lt;&lt;(PStream&amp; out, const hash_map&lt;Key, Value, Compare, Alloc&gt;&amp; m)
-{ writeMap(out, m); return out; }
+inline PStream&amp; operator&lt;&lt;(PStream&amp; out,
+                           const hash_map&lt;Key, Value, Compare, Alloc&gt;&amp; m)
+{
+    writeMap(out, m);
+    return out;
+}
 
 template&lt;class Key, class Value, class Compare, class Alloc&gt;
-inline PStream&amp; operator&gt;&gt;(PStream&amp; in, hash_map&lt;Key, Value, Compare, Alloc&gt;&amp; m)
-{ readMap(in, m); return in; }
+inline PStream&amp; operator&gt;&gt;(PStream&amp; in,
+                           hash_map&lt;Key, Value, Compare, Alloc&gt;&amp; m)
+{
+    readMap(in, m);
+    return in;
+}
 
 template&lt;class Key, class Value, class Compare, class Alloc&gt;
-inline PStream&amp; operator&lt;&lt;(PStream&amp; out, const hash_multimap&lt;Key, Value, Compare, Alloc&gt;&amp; m)
-{ writeMap(out, m); return out; }
+inline PStream&amp; operator&lt;&lt;(PStream&amp; out,
+                           const hash_multimap&lt;Key, Value, Compare, Alloc&gt;&amp; m)
+{
+    writeMap(out, m);
+    return out;
+}
 
 template&lt;class Key, class Value, class Compare, class Alloc&gt;
-inline PStream&amp; operator&gt;&gt;(PStream&amp; in, hash_multimap&lt;Key, Value, Compare, Alloc&gt;&amp; m)
-{ readMap(in, m); return in; }
+inline PStream&amp; operator&gt;&gt;(PStream&amp; in,
+                           hash_multimap&lt;Key, Value, Compare, Alloc&gt;&amp; m)
+{
+    readMap(in, m);
+    return in;
+}
 
 
 /** Serialization of sequences **/
-/* These methods are there only to simplify the writing of operator&lt;&lt; and operator&gt;&gt; and
-   should not be called by user code directly */
+/* These methods are there only to simplify the writing of operator&lt;&lt; and
+   operator&gt;&gt; and should not be called by user code directly */
 
 template&lt;class Iterator&gt;
 void binwrite_(PStream&amp; out, Iterator&amp; it, unsigned int n)
@@ -1043,20 +1157,27 @@
     in.read((char*)x, n);
 }
 
-inline void binread_(PStream&amp; in, signed char* x, unsigned int n, unsigned char typecode)
+inline void binread_(PStream&amp; in, signed char* x, unsigned int n,
+                     unsigned char typecode)
 { binread_(in, (char *)x, n, typecode); }
 
-inline void binread_(PStream&amp; in, unsigned char* x, unsigned int n, unsigned char typecode)
+inline void binread_(PStream&amp; in, unsigned char* x, unsigned int n,
+                     unsigned char typecode)
 { binread_(in, (char *)x, n, typecode); }
 
 void binread_(PStream&amp; in, short* x, unsigned int n, unsigned char typecode);
-void binread_(PStream&amp; in, unsigned short* x, unsigned int n, unsigned char typecode);
+void binread_(PStream&amp; in, unsigned short* x, unsigned int n,
+              unsigned char typecode);
 void binread_(PStream&amp; in, int* x, unsigned int n, unsigned char typecode);
-void binread_(PStream&amp; in, unsigned int* x, unsigned int n, unsigned char typecode);
+void binread_(PStream&amp; in, unsigned int* x, unsigned int n,
+              unsigned char typecode);
 void binread_(PStream&amp; in, long* x, unsigned int n, unsigned char typecode);
-void binread_(PStream&amp; in, unsigned long* x, unsigned int n, unsigned char typecode);
-void binread_(PStream&amp; in, long long* x, unsigned int n, unsigned char typecode);
-void binread_(PStream&amp; in, unsigned long long* x, unsigned int n, unsigned char typecode);
+void binread_(PStream&amp; in, unsigned long* x, unsigned int n,
+              unsigned char typecode);
+void binread_(PStream&amp; in, long long* x, unsigned int n,
+              unsigned char typecode);
+void binread_(PStream&amp; in, unsigned long long* x, unsigned int n,
+              unsigned char typecode);
 void binread_(PStream&amp; in, float* x, unsigned int n, unsigned char typecode);
 void binread_(PStream&amp; in, double* x, unsigned int n, unsigned char typecode);
 
@@ -1112,12 +1233,14 @@
         if(byte_order()==LITTLE_ENDIAN_ORDER)
         {
             out.put((char)0x12); // 1D little-endian
-            typecode = TypeTraits&lt;typename SequenceType::value_type&gt;::little_endian_typecode();
+            typecode = TypeTraits&lt;typename SequenceType::value_type&gt;
+                ::little_endian_typecode();
         }
         else
         {
             out.put((char)0x13); // 1D big-endian
-            typecode = TypeTraits&lt;typename SequenceType::value_type&gt;::big_endian_typecode();
+            typecode = TypeTraits&lt;typename SequenceType::value_type&gt;
+                ::big_endian_typecode();
         }
 
         // write typecode
@@ -1139,13 +1262,15 @@
 
 
 //! Reads in a sequence type from a PStream.
-/*! For this to work with the current implementation, the SequenceType must have:
-  - typedefs defining (SequenceType::...) value_type, size_type, iterator
+/*! For this to work with the current implementation, the SequenceType must
+have:
+  - typedefs defining (SequenceType::...) value_type, size_type, iterator,
   - a begin() method that returns a proper iterator,
-  - a size_type size() method returning the size of the current container
-  - a resize(size_type n) method that allows to change the size of the container
-  (which should also work with resize(0) )
-  - a push_back(const value_type&amp; x) method that appends the element x at the end
+  - a size_type size() method returning the size of the current container,
+  - a resize(size_type n) method that allows to change the size of the
+  container (which should also work with resize(0)),
+  - a push_back(const value_type&amp; x) method that appends the element x at the
+  end.
 */
 template&lt;class SequenceType&gt;
 void readSequence(PStream&amp; in, SequenceType&amp; seq)
@@ -1161,7 +1286,8 @@
         {
             in.skipBlanks();
             in &gt;&gt; *it;
-            //don't skip blanks before we need to read something else (read might block).
+            // don't skip blanks before we need to read something else
+            // (read might block).
             //in.skipBlanks();
             ++it;
         }
@@ -1210,7 +1336,8 @@
             c = in.get();
             if(c!='[')
                 PLERROR(&quot;Error in readSequence(SequenceType&amp; seq), expected '[', read '%c'&quot;,c);
-            //don't skip blanks before we need to read something else (read might block).
+            // don't skip blanks before we need to read something else
+            // (read might block).
             //in.skipBlanksAndCommentsAndSeparators();
             seq.resize((typename SequenceType::size_type) n);
             if (n&gt;0)
@@ -1220,7 +1347,8 @@
                 {
                     in.skipBlanksAndCommentsAndSeparators();
                     in &gt;&gt; *it;
-                    //don't skip blanks before we need to read something else (read might block).
+                    // don't skip blanks before we need to read something else
+                    // (read might block).
                     //in.skipBlanksAndCommentsAndSeparators();
                     ++it;
                 }
@@ -1238,8 +1366,9 @@
             unsigned int l;
             in.read((char*)&amp;l,sizeof(l));
 
-            bool inverted_byte_order = (    (c==0x12 &amp;&amp; byte_order()==BIG_ENDIAN_ORDER)
-                                            || (c==0x13 &amp;&amp; byte_order()==LITTLE_ENDIAN_ORDER) );
+            bool inverted_byte_order =
+                ((c==0x12 &amp;&amp; byte_order()==BIG_ENDIAN_ORDER)
+                 || (c==0x13 &amp;&amp; byte_order()==LITTLE_ENDIAN_ORDER) );
 
             if(inverted_byte_order)
                 endianswap(&amp;l);
@@ -1359,7 +1488,8 @@
 class POFStream: public PStream
 {
 public:
-    POFStream(const string&amp; fname, ios_base::openmode m = ios_base::out | ios_base::trunc)
+    POFStream(const string&amp; fname,
+              ios_base::openmode m = ios_base::out | ios_base::trunc)
         :PStream(new ofstream(fname.c_str()),true)
     {
         PLDEPRECATED(&quot;POFStream is deprecated. Use the openFile function instead.&quot;);


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001289.html">[Plearn-commits] r7841 - trunk/plearn/io
</A></li>
	<LI>Next message: <A HREF="001291.html">[Plearn-commits] r7843 - trunk/plearn/io
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1290">[ date ]</a>
              <a href="thread.html#1290">[ thread ]</a>
              <a href="subject.html#1290">[ subject ]</a>
              <a href="author.html#1290">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/plearn-commits">More information about the Plearn-commits
mailing list</a><br>
</body></html>
