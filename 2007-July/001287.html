<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Plearn-commits] r7839 - in trunk/plearn: base io
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/plearn-commits/2007-July/index.html" >
   <LINK REL="made" HREF="mailto:plearn-commits%40lists.berlios.de?Subject=Re%3A%20%5BPlearn-commits%5D%20r7839%20-%20in%20trunk/plearn%3A%20base%20io&In-Reply-To=%3C200707270230.l6R2UDmY032512%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001286.html">
   <LINK REL="Next"  HREF="001288.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Plearn-commits] r7839 - in trunk/plearn: base io</H1>
    <B>lamblin at BerliOS</B> 
    <A HREF="mailto:plearn-commits%40lists.berlios.de?Subject=Re%3A%20%5BPlearn-commits%5D%20r7839%20-%20in%20trunk/plearn%3A%20base%20io&In-Reply-To=%3C200707270230.l6R2UDmY032512%40sheep.berlios.de%3E"
       TITLE="[Plearn-commits] r7839 - in trunk/plearn: base io">lamblin at mail.berlios.de
       </A><BR>
    <I>Fri Jul 27 04:30:13 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="001286.html">[Plearn-commits] r7838 - trunk/python_modules/plearn/learners/autolr
</A></li>
        <LI>Next message: <A HREF="001288.html">[Plearn-commits] r7840 - in trunk/plearn: base io
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1287">[ date ]</a>
              <a href="thread.html#1287">[ thread ]</a>
              <a href="subject.html#1287">[ subject ]</a>
              <a href="author.html#1287">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: lamblin
Date: 2007-07-27 04:30:10 +0200 (Fri, 27 Jul 2007)
New Revision: 7839

Modified:
   trunk/plearn/base/TypeTraits.h
   trunk/plearn/io/PStream.cc
   trunk/plearn/io/PStream.h
Log:
Hopefully better solution to the binary serialization/deserialization
problems across architectures.
It also allows &quot;real&quot; variables saved as &quot;double&quot; to be read as &quot;float&quot;,
and vice-versa.


Modified: trunk/plearn/base/TypeTraits.h
===================================================================
--- trunk/plearn/base/TypeTraits.h	2007-07-27 02:26:52 UTC (rev 7838)
+++ trunk/plearn/base/TypeTraits.h	2007-07-27 02:30:10 UTC (rev 7839)
@@ -136,6 +136,92 @@
   { return BIG_ENDIAN_TYPECODE; }                                                       \
 }
 
+#define DECLARE_TYPE_TRAITS_FOR_INTTYPE(T)                  \
+template&lt;&gt;                                                  \
+class TypeTraits&lt;T&gt;                                         \
+{                                                           \
+public:                                                     \
+    static inline string name()                             \
+    { return #T; }                                          \
+                                                            \
+    static inline unsigned char little_endian_typecode()    \
+    {                                                       \
+        switch(sizeof(T))                                   \
+        {                                                   \
+        case sizeof(int8_t):                                \
+            return 0x01;                                    \
+        case sizeof(int16_t):                               \
+            return 0x03;                                    \
+        case sizeof(int32_t):                               \
+            return 0x07;                                    \
+        case sizeof(int64_t):                               \
+            return 0x16;                                    \
+        default:                                            \
+            return 0xFF;                                    \
+        }                                                   \
+    }                                                       \
+                                                            \
+    static inline unsigned char big_endian_typecode()       \
+    {                                                       \
+        switch(sizeof(T))                                   \
+        {                                                   \
+        case sizeof(int8_t):                                \
+            return 0x01;                                    \
+        case sizeof(int16_t):                               \
+            return 0x04;                                    \
+        case sizeof(int32_t):                               \
+            return 0x08;                                    \
+        case sizeof(int64_t):                               \
+            return 0x17;                                    \
+        default:                                            \
+            return 0xFF;                                    \
+        }                                                   \
+    }                                                       \
+}
+
+#define DECLARE_TYPE_TRAITS_FOR_UINTTYPE(T)                 \
+template&lt;&gt;                                                  \
+class TypeTraits&lt;T&gt;                                         \
+{                                                           \
+public:                                                     \
+    static inline string name()                             \
+    { return #T; }                                          \
+                                                            \
+    static inline unsigned char little_endian_typecode()    \
+    {                                                       \
+        switch(sizeof(T))                                   \
+        {                                                   \
+        case sizeof(uint8_t):                               \
+            return 0x02;                                    \
+        case sizeof(uint16_t):                              \
+            return 0x05;                                    \
+        case sizeof(uint32_t):                              \
+            return 0x0B;                                    \
+        case sizeof(uint64_t):                              \
+            return 0x18;                                    \
+        default:                                            \
+            return 0xFF;                                    \
+        }                                                   \
+    }                                                       \
+                                                            \
+    static inline unsigned char big_endian_typecode()       \
+    {                                                       \
+        switch(sizeof(T))                                   \
+        {                                                   \
+        case sizeof(uint8_t):                               \
+            return 0x02;                                    \
+        case sizeof(uint16_t):                              \
+            return 0x06;                                    \
+        case sizeof(uint32_t):                              \
+            return 0x0C;                                    \
+        case sizeof(uint64_t):                              \
+            return 0x19;                                    \
+        default:                                            \
+            return 0xFF;                                    \
+        }                                                   \
+    }                                                       \
+}
+
 #define DECLARE_TYPE_TRAITS(T)                          \
 template&lt;&gt;                                              \
 class TypeTraits&lt;T&gt;                                     \
@@ -153,21 +239,23 @@
 
 // DECLARE_TYPE_TRAITS_FOR_BASETYPE(bool, ??, ??);
 DECLARE_TYPE_TRAITS_FOR_BASETYPE(void,               0xFF, 0xFF);
-DECLARE_TYPE_TRAITS_FOR_BASETYPE(char,               0x01, 0x01);
-DECLARE_TYPE_TRAITS_FOR_BASETYPE(signed char,        0x01, 0x01);
-DECLARE_TYPE_TRAITS_FOR_BASETYPE(unsigned char,      0x02, 0x02);
-DECLARE_TYPE_TRAITS_FOR_BASETYPE(short,              0x03, 0x04);
-DECLARE_TYPE_TRAITS_FOR_BASETYPE(unsigned short,     0x05, 0x06);
-DECLARE_TYPE_TRAITS_FOR_BASETYPE(int,                0x07, 0x08);
-DECLARE_TYPE_TRAITS_FOR_BASETYPE(unsigned int,       0x0B, 0x0C);
-DECLARE_TYPE_TRAITS_FOR_BASETYPE(long,               0x07, 0x08);
-DECLARE_TYPE_TRAITS_FOR_BASETYPE(unsigned long,      0x0B, 0x0C);
-DECLARE_TYPE_TRAITS_FOR_BASETYPE(long long,          0x16, 0x17);
-DECLARE_TYPE_TRAITS_FOR_BASETYPE(unsigned long long, 0x18, 0x19);
 DECLARE_TYPE_TRAITS_FOR_BASETYPE(float,              0x0E, 0x0F);
 DECLARE_TYPE_TRAITS_FOR_BASETYPE(double,             0x10, 0x11);
 DECLARE_TYPE_TRAITS_FOR_BASETYPE(bool,               0x30, 0x30);
 
+DECLARE_TYPE_TRAITS_FOR_INTTYPE(char);
+DECLARE_TYPE_TRAITS_FOR_INTTYPE(signed char);
+DECLARE_TYPE_TRAITS_FOR_INTTYPE(short);
+DECLARE_TYPE_TRAITS_FOR_INTTYPE(int);
+DECLARE_TYPE_TRAITS_FOR_INTTYPE(long);
+DECLARE_TYPE_TRAITS_FOR_INTTYPE(long long);
+
+DECLARE_TYPE_TRAITS_FOR_UINTTYPE(unsigned char);
+DECLARE_TYPE_TRAITS_FOR_UINTTYPE(unsigned short);
+DECLARE_TYPE_TRAITS_FOR_UINTTYPE(unsigned int);
+DECLARE_TYPE_TRAITS_FOR_UINTTYPE(unsigned long);
+DECLARE_TYPE_TRAITS_FOR_UINTTYPE(unsigned long long);
+
 DECLARE_TYPE_TRAITS(string);
 
 template&lt;class T&gt;

Modified: trunk/plearn/io/PStream.cc
===================================================================
--- trunk/plearn/io/PStream.cc	2007-07-27 02:26:52 UTC (rev 7838)
+++ trunk/plearn/io/PStream.cc	2007-07-27 02:30:10 UTC (rev 7839)
@@ -799,6 +799,7 @@
     }
 }
 
+
 PStream&amp; PStream::operator=(const PStream&amp; pios)
 {
     if(this != &amp;pios)
@@ -1088,75 +1089,52 @@
     return *this;
 }
 
-PStream&amp; PStream::operator&gt;&gt;(int &amp;x)
+PStream&amp; PStream::operator&gt;&gt;(bool &amp;x)
 {
+    int parsed = -1;
+
+    char c;
     switch(inmode)
     {
     case raw_ascii:
     case pretty_ascii:
-        skipBlanks();
-        readAsciiNum(x);
-        break;
     case raw_binary:
-        read(reinterpret_cast&lt;char *&gt;(&amp;x), sizeof(int));
-        break;
     case plearn_ascii:
     case plearn_binary:
-    {
         skipBlanksAndCommentsAndSeparators();
-        int c = get();
-        if(c==0x07 || c==0x08 || c==0x0B || c==0x0C )  // plearn_binary
+        c = get();
+        if(c=='1')
+            parsed = 1;
+
+        else if(c=='0')
+            parsed = 0;
+
+        else if(c=='T')
         {
-            read(reinterpret_cast&lt;char*&gt;(&amp;x),sizeof(int));
-            if( (c==0x07 &amp;&amp; byte_order()==BIG_ENDIAN_ORDER)
-                || (c==0x08 &amp;&amp; byte_order()==LITTLE_ENDIAN_ORDER) )
-                endianswap(&amp;x);
+            char r = get();
+            char u = get();
+            char e = get();
+            if ( r == 'r' &amp;&amp; u == 'u' &amp;&amp; e == 'e' )
+                parsed = 1;
         }
-        else  // plearn_ascii
+
+        else if(c=='F')
         {
-            unget();
-            readAsciiNum(x);
+            char a = get();
+            char l = get();
+            char s = get();
+            char e = get();
+            if ( a == 'a' &amp;&amp; l == 'l' &amp;&amp; s == 's' &amp;&amp; e == 'e' )
+                parsed = 0;
         }
-        break;
-    }
-    default:
-        PLERROR(&quot;In PStream::operator&gt;&gt;  unknown inmode!!!!!!!!!&quot;);
-        break;
-    }
-    return *this;
-}
 
-PStream&amp; PStream::operator&gt;&gt;(unsigned int &amp;x)
-{
-    switch(inmode)
-    {
-    case raw_ascii:
-    case pretty_ascii:
-        skipBlanks();
-        readAsciiNum(x);
+        if ( parsed == -1 )
+            PLERROR(&quot;In PStream::operator&gt;&gt;(bool &amp;x) wrong format for bool, must be one &quot;
+                    &quot;of characters 0 or 1 or unquoted strings True or False&quot; );
+        else
+            x = (parsed != 0);
         break;
-    case raw_binary:
-        read(reinterpret_cast&lt;char *&gt;(&amp;x), sizeof(unsigned int));
-        break;
-    case plearn_ascii:
-    case plearn_binary:
-    {
-        skipBlanksAndCommentsAndSeparators();
-        int c = get();
-        if(c==0x0B || c==0x0C || c==0x07 || c==0x08)  // plearn_binary unsigned int or int
-        {
-            read(reinterpret_cast&lt;char*&gt;(&amp;x),sizeof(unsigned int));
-            if( (c==0x0B &amp;&amp; byte_order()==BIG_ENDIAN_ORDER)
-                || (c==0x0C &amp;&amp; byte_order()==LITTLE_ENDIAN_ORDER) )
-                endianswap(&amp;x);
-        }
-        else  // plearn_ascii
-        {
-            unget();
-            readAsciiNum(x);
-        }
-        break;
-    }
+
     default:
         PLERROR(&quot;In PStream::operator&gt;&gt;  unknown inmode!!!!!!!!!&quot;);
         break;
@@ -1164,8 +1142,7 @@
     return *this;
 }
 
-/* Commented out because &quot;long&quot; has not the same size on every platform
-PStream&amp; PStream::operator&gt;&gt;(long &amp;x)
+PStream&amp; PStream::operator&gt;&gt;(short &amp;x)
 {
     switch(inmode)
     {
@@ -1175,27 +1152,17 @@
         readAsciiNum(x);
         break;
     case raw_binary:
-        read(reinterpret_cast&lt;char *&gt;(&amp;x), sizeof(long));
+        read(reinterpret_cast&lt;char *&gt;(&amp;x), sizeof(short));
         break;
     case plearn_ascii:
     case plearn_binary:
     {
         skipBlanksAndCommentsAndSeparators();
         int c = get();
-        if(c==0x07 || c==0x08)  // plearn_binary
+        if(c&gt;0x00 &amp;&amp; c&lt;0x20)  // plearn_binary
         {
-            read(reinterpret_cast&lt;char*&gt;(&amp;x),sizeof(long));
-            if( (c==0x07 &amp;&amp; byte_order()==BIG_ENDIAN_ORDER)
-                || (c==0x08 &amp;&amp; byte_order()==LITTLE_ENDIAN_ORDER) )
-                endianswap(&amp;x);
+            readBinaryNum(x, c);
         }
-        else if(c==0x16 || c==0x17)  // plearn_binary
-        {
-            read(reinterpret_cast&lt;char*&gt;(&amp;x),sizeof(long));
-            if( (c==0x16 &amp;&amp; byte_order()==BIG_ENDIAN_ORDER)
-                || (c==0x17 &amp;&amp; byte_order()==LITTLE_ENDIAN_ORDER) )
-                endianswap(&amp;x);
-        }
         else  // plearn_ascii
         {
             unget();
@@ -1209,9 +1176,8 @@
     }
     return *this;
 }
-*/
 
-PStream&amp; PStream::operator&gt;&gt;(int64_t &amp;x)
+PStream&amp; PStream::operator&gt;&gt;(unsigned short &amp;x)
 {
     switch(inmode)
     {
@@ -1221,29 +1187,17 @@
         readAsciiNum(x);
         break;
     case raw_binary:
-        read(reinterpret_cast&lt;char *&gt;(&amp;x), sizeof(int64_t));
+        read(reinterpret_cast&lt;char *&gt;(&amp;x), sizeof(unsigned short));
         break;
     case plearn_ascii:
     case plearn_binary:
     {
         skipBlanksAndCommentsAndSeparators();
         int c = get();
-        if(c==0x07 || c==0x08)  // plearn_binary 32 bits integer
+        if(c&gt;0x00 &amp;&amp; c&lt;0x20)  // plearn_binary
         {
-            int32_t y;
-            read(reinterpret_cast&lt;char*&gt;(&amp;y),sizeof(int32_t));
-            if( (c==0x07 &amp;&amp; byte_order()==BIG_ENDIAN_ORDER)
-                || (c==0x08 &amp;&amp; byte_order()==LITTLE_ENDIAN_ORDER) )
-                endianswap(&amp;y);
-            x = y;
+            readBinaryNum(x, c);
         }
-        else if(c==0x16 || c==0x17)  // plearn_binary 64 bits integer
-        {
-            read(reinterpret_cast&lt;char*&gt;(&amp;x),sizeof(int64_t));
-            if( (c==0x16 &amp;&amp; byte_order()==BIG_ENDIAN_ORDER)
-                || (c==0x17 &amp;&amp; byte_order()==LITTLE_ENDIAN_ORDER) )
-                endianswap(&amp;x);
-        }
         else  // plearn_ascii
         {
             unget();
@@ -1258,8 +1212,7 @@
     return *this;
 }
 
-/*
-PStream&amp; PStream::operator&gt;&gt;(unsigned long &amp;x)
+PStream&amp; PStream::operator&gt;&gt;(int &amp;x)
 {
     switch(inmode)
     {
@@ -1269,19 +1222,16 @@
         readAsciiNum(x);
         break;
     case raw_binary:
-        read(reinterpret_cast&lt;char *&gt;(&amp;x), sizeof(unsigned long));
+        read(reinterpret_cast&lt;char *&gt;(&amp;x), sizeof(int));
         break;
     case plearn_ascii:
     case plearn_binary:
     {
         skipBlanksAndCommentsAndSeparators();
         int c = get();
-        if(c==0x0B || c==0x0C)  // plearn_binary
+        if(c&gt;0x00 &amp;&amp; c&lt;0x20)  // plearn_binary
         {
-            read(reinterpret_cast&lt;char*&gt;(&amp;x),sizeof(unsigned long));
-            if( (c==0x0B &amp;&amp; byte_order()==BIG_ENDIAN_ORDER)
-                || (c==0x0C &amp;&amp; byte_order()==LITTLE_ENDIAN_ORDER) )
-                endianswap(&amp;x);
+            readBinaryNum(x, c);
         }
         else  // plearn_ascii
         {
@@ -1296,9 +1246,8 @@
     }
     return *this;
 }
-*/
 
-PStream&amp; PStream::operator&gt;&gt;(uint64_t &amp;x)
+PStream&amp; PStream::operator&gt;&gt;(unsigned int &amp;x)
 {
     switch(inmode)
     {
@@ -1308,29 +1257,17 @@
         readAsciiNum(x);
         break;
     case raw_binary:
-        read(reinterpret_cast&lt;char *&gt;(&amp;x), sizeof(uint64_t));
+        read(reinterpret_cast&lt;char *&gt;(&amp;x), sizeof(unsigned int));
         break;
     case plearn_ascii:
     case plearn_binary:
     {
         skipBlanksAndCommentsAndSeparators();
         int c = get();
-        if(c==0x0B || c==0x0C)  // plearn_binary 32 bits unsigned integer
+        if(c&gt;0x00 &amp;&amp; c&lt;0x20)  // plearn_binary
         {
-            uint32_t y;
-            read(reinterpret_cast&lt;char*&gt;(&amp;y),sizeof(uint32_t));
-            if( (c==0x0B &amp;&amp; byte_order()==BIG_ENDIAN_ORDER)
-                || (c==0x0C &amp;&amp; byte_order()==LITTLE_ENDIAN_ORDER) )
-                endianswap(&amp;y);
-            x = y;
+            readBinaryNum(x, c);
         }
-        else if(c==0x18 || c==0x19) // plearn_binary 64 bits unsigned integer
-        {
-            read(reinterpret_cast&lt;char*&gt;(&amp;x), sizeof(uint64_t));
-            if( (c==0x18 &amp;&amp; byte_order()==BIG_ENDIAN_ORDER)
-                || (c==0x19 &amp;&amp; byte_order()==LITTLE_ENDIAN_ORDER) )
-                endianswap(&amp;x);
-        }
         else  // plearn_ascii
         {
             unget();
@@ -1345,8 +1282,7 @@
     return *this;
 }
 
-/*
-PStream&amp; PStream::operator&gt;&gt;(long long &amp;x)
+PStream&amp; PStream::operator&gt;&gt;(long &amp;x)
 {
     switch(inmode)
     {
@@ -1356,19 +1292,16 @@
         readAsciiNum(x);
         break;
     case raw_binary:
-        read(reinterpret_cast&lt;char *&gt;(&amp;x), sizeof(long long));
+        read(reinterpret_cast&lt;char *&gt;(&amp;x), sizeof(long));
         break;
     case plearn_ascii:
     case plearn_binary:
     {
         skipBlanksAndCommentsAndSeparators();
         int c = get();
-        if(c==0x16 || c==0x17)  // plearn_binary
+        if(c&gt;0x00 &amp;&amp; c&lt;0x20)  // plearn_binary
         {
-            read(reinterpret_cast&lt;char*&gt;(&amp;x),sizeof(long long));
-            if( (c==0x16 &amp;&amp; byte_order()==BIG_ENDIAN_ORDER)
-                || (c==0x17 &amp;&amp; byte_order()==LITTLE_ENDIAN_ORDER) )
-                endianswap(&amp;x);
+            readBinaryNum(x, c);
         }
         else  // plearn_ascii
         {
@@ -1384,7 +1317,7 @@
     return *this;
 }
 
-PStream&amp; PStream::operator&gt;&gt;(unsigned long long &amp;x)
+PStream&amp; PStream::operator&gt;&gt;(unsigned long &amp;x)
 {
     switch(inmode)
     {
@@ -1394,19 +1327,16 @@
         readAsciiNum(x);
         break;
     case raw_binary:
-        read(reinterpret_cast&lt;char *&gt;(&amp;x), sizeof(unsigned long long));
+        read(reinterpret_cast&lt;char *&gt;(&amp;x), sizeof(unsigned long));
         break;
     case plearn_ascii:
     case plearn_binary:
     {
         skipBlanksAndCommentsAndSeparators();
         int c = get();
-        if(c==0x18 || c==0x19)  // plearn_binary
+        if(c&gt;0x00 &amp;&amp; c&lt;0x20)  // plearn_binary
         {
-            read(reinterpret_cast&lt;char*&gt;(&amp;x),sizeof(unsigned long long));
-            if( (c==0x18 &amp;&amp; byte_order()==BIG_ENDIAN_ORDER)
-                || (c==0x19 &amp;&amp; byte_order()==LITTLE_ENDIAN_ORDER) )
-                endianswap(&amp;x);
+            readBinaryNum(x, c);
         }
         else  // plearn_ascii
         {
@@ -1421,9 +1351,8 @@
     }
     return *this;
 }
-*/
 
-PStream&amp; PStream::operator&gt;&gt;(short &amp;x)
+PStream&amp; PStream::operator&gt;&gt;(long long &amp;x)
 {
     switch(inmode)
     {
@@ -1433,19 +1362,16 @@
         readAsciiNum(x);
         break;
     case raw_binary:
-        read(reinterpret_cast&lt;char *&gt;(&amp;x), sizeof(short));
+        read(reinterpret_cast&lt;char *&gt;(&amp;x), sizeof(long long));
         break;
     case plearn_ascii:
     case plearn_binary:
     {
         skipBlanksAndCommentsAndSeparators();
         int c = get();
-        if(c==0x03 || c==0x04)  // plearn_binary
+        if(c&gt;0x00 &amp;&amp; c&lt;0x20)  // plearn_binary
         {
-            read(reinterpret_cast&lt;char*&gt;(&amp;x),sizeof(short));
-            if( (c==0x03 &amp;&amp; byte_order()==BIG_ENDIAN_ORDER)
-                || (c==0x04 &amp;&amp; byte_order()==LITTLE_ENDIAN_ORDER) )
-                endianswap(&amp;x);
+            readBinaryNum(x, c);
         }
         else  // plearn_ascii
         {
@@ -1461,7 +1387,7 @@
     return *this;
 }
 
-PStream&amp; PStream::operator&gt;&gt;(unsigned short &amp;x)
+PStream&amp; PStream::operator&gt;&gt;(unsigned long long &amp;x)
 {
     switch(inmode)
     {
@@ -1471,19 +1397,16 @@
         readAsciiNum(x);
         break;
     case raw_binary:
-        read(reinterpret_cast&lt;char *&gt;(&amp;x), sizeof(unsigned short));
+        read(reinterpret_cast&lt;char *&gt;(&amp;x), sizeof(unsigned long long));
         break;
     case plearn_ascii:
     case plearn_binary:
     {
         skipBlanksAndCommentsAndSeparators();
         int c = get();
-        if(c==0x05 || c==0x06)  // plearn_binary
+        if(c&gt;0x00 &amp;&amp; c&lt;0x20)  // plearn_binary
         {
-            read(reinterpret_cast&lt;char*&gt;(&amp;x),sizeof(unsigned short));
-            if( (c==0x05 &amp;&amp; byte_order()==BIG_ENDIAN_ORDER)
-                || (c==0x06 &amp;&amp; byte_order()==LITTLE_ENDIAN_ORDER) )
-                endianswap(&amp;x);
+            readBinaryNum(x, c);
         }
         else  // plearn_ascii
         {
@@ -1499,59 +1422,6 @@
     return *this;
 }
 
-PStream&amp; PStream::operator&gt;&gt;(bool &amp;x)
-{
-    int parsed = -1;
-
-    char c;
-    switch(inmode)
-    {
-    case raw_ascii:
-    case pretty_ascii:
-    case raw_binary:
-    case plearn_ascii:
-    case plearn_binary:
-        skipBlanksAndCommentsAndSeparators();
-        c = get();
-        if(c=='1')
-            parsed = 1;
-
-        else if(c=='0')
-            parsed = 0;
-
-        else if(c=='T')
-        {
-            char r = get();
-            char u = get();
-            char e = get();
-            if ( r == 'r' &amp;&amp; u == 'u' &amp;&amp; e == 'e' )
-                parsed = 1;
-        }
-
-        else if(c=='F')
-        {
-            char a = get();
-            char l = get();
-            char s = get();
-            char e = get();
-            if ( a == 'a' &amp;&amp; l == 'l' &amp;&amp; s == 's' &amp;&amp; e == 'e' )
-                parsed = 0;
-        }
-
-        if ( parsed == -1 )
-            PLERROR(&quot;In PStream::operator&gt;&gt;(bool &amp;x) wrong format for bool, must be one &quot;
-                    &quot;of characters 0 or 1 or unquoted strings True or False&quot; );
-        else
-            x = (parsed != 0);
-        break;
-
-    default:
-        PLERROR(&quot;In PStream::operator&gt;&gt;  unknown inmode!!!!!!!!!&quot;);
-        break;
-    }
-    return *this;
-}
-
 PStream&amp; PStream::operator&gt;&gt;(float &amp;x)
 {
     switch(inmode)
@@ -1569,12 +1439,9 @@
     {
         skipBlanksAndCommentsAndSeparators();
         int c = get();
-        if(c==0x0E || c==0x0F)  // plearn_binary
+        if(c&gt;0x00 &amp;&amp; c&lt;0x20)  // plearn_binary
         {
-            read(reinterpret_cast&lt;char*&gt;(&amp;x),sizeof(float));
-            if( (c==0x0E &amp;&amp; byte_order()==BIG_ENDIAN_ORDER)
-                || (c==0x0F &amp;&amp; byte_order()==LITTLE_ENDIAN_ORDER) )
-                endianswap(&amp;x);
+            readBinaryNum(x, c);
         }
         else  // plearn_ascii
         {
@@ -1607,12 +1474,9 @@
     {
         skipBlanksAndCommentsAndSeparators();
         int c = get();
-        if(c==0x10 || c==0x11)  // plearn_binary
+        if(c&gt;0x00 &amp;&amp; c&lt;0x20)  // plearn_binary
         {
-            read(reinterpret_cast&lt;char*&gt;(&amp;x),sizeof(double));
-            if( (c==0x10 &amp;&amp; byte_order()==BIG_ENDIAN_ORDER)
-                || (c==0x11 &amp;&amp; byte_order()==LITTLE_ENDIAN_ORDER) )
-                endianswap(&amp;x);
+            readBinaryNum(x, c);
         }
         else  // ascii
         {
@@ -1647,8 +1511,7 @@
         put(' ');
         break;
     case plearn_binary:
-        put((char)0x01);
-        put(x);
+        writeBinaryNum(x);
         break;
     default:
         PLERROR(&quot;In PStream::operator&lt;&lt;  unknown outmode!!!!!!!!!&quot;);
@@ -1682,8 +1545,7 @@
         put(' ');
         break;
     case plearn_binary:
-        put((char)0x02);
-        put(x);
+        writeBinaryNum(x);
         break;
     default:
         PLERROR(&quot;In PStream::operator&lt;&lt;  unknown outmode!!!!!!!!!&quot;);
@@ -1785,12 +1647,12 @@
     return *this;
 }
 
-PStream&amp; PStream::operator&lt;&lt;(int x)
+PStream&amp; PStream::operator&lt;&lt;(short x)
 {
     switch(outmode)
     {
     case raw_binary:
-        write(reinterpret_cast&lt;char *&gt;(&amp;x), sizeof(int));
+        write(reinterpret_cast&lt;char *&gt;(&amp;x), sizeof(short));
         break;
     case raw_ascii:
     case pretty_ascii:
@@ -1801,12 +1663,7 @@
         put(' ');
         break;
     case plearn_binary:
-#ifdef BIGENDIAN
-        put((char)0x08);
-#else
-        put((char)0x07);
-#endif
-        write((char*)&amp;x,sizeof(int));
+        writeBinaryNum(x);
         break;
     default:
         PLERROR(&quot;In PStream::operator&lt;&lt;  unknown outmode!!!!!!!!!&quot;);
@@ -1815,12 +1672,12 @@
     return *this;
 }
 
-PStream&amp; PStream::operator&lt;&lt;(unsigned int x)
+PStream&amp; PStream::operator&lt;&lt;(unsigned short x)
 {
     switch(outmode)
     {
     case raw_binary:
-        write(reinterpret_cast&lt;char *&gt;(&amp;x), sizeof(unsigned int));
+        write(reinterpret_cast&lt;char *&gt;(&amp;x), sizeof(unsigned short));
         break;
     case raw_ascii:
     case pretty_ascii:
@@ -1831,12 +1688,7 @@
         put(' ');
         break;
     case plearn_binary:
-#ifdef BIGENDIAN
-        put((char)0x0C);
-#else
-        put((char)0x0B);
-#endif
-        write((char*)&amp;x,sizeof(unsigned int));
+        writeBinaryNum(x);
         break;
     default:
         PLERROR(&quot;In PStream::operator&lt;&lt;  unknown outmode!!!!!!!!!&quot;);
@@ -1845,13 +1697,12 @@
     return *this;
 }
 
-/* Commented out because &quot;long&quot; has not the same size on every platform
-PStream&amp; PStream::operator&lt;&lt;(long x)
+PStream&amp; PStream::operator&lt;&lt;(int x)
 {
     switch(outmode)
     {
     case raw_binary:
-        write(reinterpret_cast&lt;char *&gt;(&amp;x), sizeof(long));
+        write(reinterpret_cast&lt;char *&gt;(&amp;x), sizeof(int));
         break;
     case raw_ascii:
     case pretty_ascii:
@@ -1862,23 +1713,7 @@
         put(' ');
         break;
     case plearn_binary:
-        if(sizeof(long)==4)
-        {
-#ifdef BIGENDIAN
-        put((char)0x08);
-#else
-        put((char)0x07);
-#endif
-        }
-        else if(sizeof(long)==8)
-        {
-#ifdef BIGENDIAN
-        put((char)0x17);
-#else
-        put((char)0x16);
-#endif
-        }
-        write((char*)&amp;x,sizeof(long));
+        writeBinaryNum(x);
         break;
     default:
         PLERROR(&quot;In PStream::operator&lt;&lt;  unknown outmode!!!!!!!!!&quot;);
@@ -1886,14 +1721,13 @@
     }
     return *this;
 }
-*/
 
-PStream&amp; PStream::operator&lt;&lt;(int64_t x)
+PStream&amp; PStream::operator&lt;&lt;(unsigned int x)
 {
     switch(outmode)
     {
     case raw_binary:
-        write(reinterpret_cast&lt;char *&gt;(&amp;x), sizeof(int64_t));
+        write(reinterpret_cast&lt;char *&gt;(&amp;x), sizeof(unsigned int));
         break;
     case raw_ascii:
     case pretty_ascii:
@@ -1904,12 +1738,7 @@
         put(' ');
         break;
     case plearn_binary:
-#ifdef BIGENDIAN
-        put((char)0x17);
-#else
-        put((char)0x16);
-#endif
-        write((char*)&amp;x, sizeof(int64_t));
+        writeBinaryNum(x);
         break;
     default:
         PLERROR(&quot;In PStream::operator&lt;&lt;  unknown outmode!!!!!!!!!&quot;);
@@ -1918,13 +1747,12 @@
     return *this;
 }
 
-/*
-PStream&amp; PStream::operator&lt;&lt;(unsigned long x)
+PStream&amp; PStream::operator&lt;&lt;(long x)
 {
     switch(outmode)
     {
     case raw_binary:
-        write(reinterpret_cast&lt;char *&gt;(&amp;x), sizeof(unsigned long));
+        write(reinterpret_cast&lt;char *&gt;(&amp;x), sizeof(long));
         break;
     case raw_ascii:
     case pretty_ascii:
@@ -1935,12 +1763,7 @@
         put(' ');
         break;
     case plearn_binary:
-#ifdef BIGENDIAN
-        put((char)0x0C);
-#else
-        put((char)0x0B);
-#endif
-        write((char*)&amp;x,sizeof(unsigned long));
+        writeBinaryNum(x);
         break;
     default:
         PLERROR(&quot;In PStream::operator&lt;&lt;  unknown outmode!!!!!!!!!&quot;);
@@ -1948,14 +1771,13 @@
     }
     return *this;
 }
-*/
 
-PStream&amp; PStream::operator&lt;&lt;(uint64_t x)
+PStream&amp; PStream::operator&lt;&lt;(unsigned long x)
 {
     switch(outmode)
     {
     case raw_binary:
-        write(reinterpret_cast&lt;char *&gt;(&amp;x), sizeof(uint64_t));
+        write(reinterpret_cast&lt;char *&gt;(&amp;x), sizeof(unsigned long));
         break;
     case raw_ascii:
     case pretty_ascii:
@@ -1966,12 +1788,7 @@
         put(' ');
         break;
     case plearn_binary:
-#ifdef BIGENDIAN
-        put((char)0x19);
-#else
-        put((char)0x18);
-#endif
-        write((char*)&amp;x, sizeof(uint64_t));
+        writeBinaryNum(x);
         break;
     default:
         PLERROR(&quot;In PStream::operator&lt;&lt;  unknown outmode!!!!!!!!!&quot;);
@@ -1980,7 +1797,6 @@
     return *this;
 }
 
-/*
 PStream&amp; PStream::operator&lt;&lt;(long long x)
 {
     switch(outmode)
@@ -1997,12 +1813,7 @@
         put(' ');
         break;
     case plearn_binary:
-#ifdef BIGENDIAN
-        put((char)0x17);
-#else
-        put((char)0x16);
-#endif
-        write((char*)&amp;x,sizeof(long long));
+        writeBinaryNum(x);
         break;
     default:
         PLERROR(&quot;In PStream::operator&lt;&lt;  unknown outmode!!!!!!!!!&quot;);
@@ -2027,12 +1838,7 @@
         put(' ');
         break;
     case plearn_binary:
-#ifdef BIGENDIAN
-        put((char)0x19);
-#else
-        put((char)0x18);
-#endif
-        write((char*)&amp;x,sizeof(unsigned long long));
+        writeBinaryNum(x);
         break;
     default:
         PLERROR(&quot;In PStream::operator&lt;&lt;  unknown outmode!!!!!!!!!&quot;);
@@ -2040,68 +1846,7 @@
     }
     return *this;
 }
-*/
 
-PStream&amp; PStream::operator&lt;&lt;(short x)
-{
-    switch(outmode)
-    {
-    case raw_binary:
-        write(reinterpret_cast&lt;char *&gt;(&amp;x), sizeof(short));
-        break;
-    case raw_ascii:
-    case pretty_ascii:
-        writeAsciiNum(x);
-        break;
-    case plearn_ascii:
-        writeAsciiNum(x);
-        put(' ');
-        break;
-    case plearn_binary:
-#ifdef BIGENDIAN
-        put((char)0x04);
-#else
-        put((char)0x03);
-#endif
-        write((char*)&amp;x,sizeof(short));
-        break;
-    default:
-        PLERROR(&quot;In PStream::operator&lt;&lt;  unknown outmode!!!!!!!!!&quot;);
-        break;
-    }
-    return *this;
-}
-
-PStream&amp; PStream::operator&lt;&lt;(unsigned short x)
-{
-    switch(outmode)
-    {
-    case raw_binary:
-        write(reinterpret_cast&lt;char *&gt;(&amp;x), sizeof(unsigned short));
-        break;
-    case raw_ascii:
-    case pretty_ascii:
-        writeAsciiNum(x);
-        break;
-    case plearn_ascii:
-        writeAsciiNum(x);
-        put(' ');
-        break;
-    case plearn_binary:
-#ifdef BIGENDIAN
-        put((char)0x06);
-#else
-        put((char)0x05);
-#endif
-        write((char*)&amp;x,sizeof(unsigned short));
-        break;
-    default:
-        PLERROR(&quot;In PStream::operator&lt;&lt;  unknown outmode!!!!!!!!!&quot;);
-        break;
-    }
-    return *this;
-}
-
 PStream&amp; PStream::operator&lt;&lt;(float x)
 {
     switch(outmode)
@@ -2118,12 +1863,7 @@
         put(' ');
         break;
     case plearn_binary:
-#ifdef BIGENDIAN
-        put((char)0x0F);
-#else
-        put((char)0x0E);
-#endif
-        write((char*)&amp;x,sizeof(float));
+        writeBinaryNum(x);
         break;
     default:
         PLERROR(&quot;In PStream::operator&lt;&lt;  unknown outmode!!!!!!!!!&quot;);
@@ -2148,12 +1888,7 @@
         put(' ');
         break;
     case plearn_binary:
-#ifdef BIGENDIAN
-        put((char)0x11);
-#else
-        put((char)0x10);
-#endif
-        write((char*)&amp;x,sizeof(double));
+        writeBinaryNum(x);
         break;
     default:
         PLERROR(&quot;In PStream::operator&lt;&lt;  unknown outmode!!!!!!!!!&quot;);
@@ -2183,6 +1918,7 @@
     }
 }
 
+/*
 #define IMPLEMENT_TYPICAL_BASETYPE_BINREAD_(BASETYPE)  \
 void binread_(PStream&amp; in, BASETYPE* x,                \
               unsigned int n, unsigned char typecode)  \
@@ -2206,16 +1942,72 @@
 
 // IMPLEMENT_TYPICAL_BASETYPE_BINREAD_(char);
 IMPLEMENT_TYPICAL_BASETYPE_BINREAD_(short)
-    IMPLEMENT_TYPICAL_BASETYPE_BINREAD_(unsigned short)
-    IMPLEMENT_TYPICAL_BASETYPE_BINREAD_(int)
-    IMPLEMENT_TYPICAL_BASETYPE_BINREAD_(unsigned int)
-    //IMPLEMENT_TYPICAL_BASETYPE_BINREAD_(long)
-    //IMPLEMENT_TYPICAL_BASETYPE_BINREAD_(unsigned long)
-    IMPLEMENT_TYPICAL_BASETYPE_BINREAD_(int64_t)
-    IMPLEMENT_TYPICAL_BASETYPE_BINREAD_(uint64_t)
+IMPLEMENT_TYPICAL_BASETYPE_BINREAD_(unsigned short)
+IMPLEMENT_TYPICAL_BASETYPE_BINREAD_(int)
+IMPLEMENT_TYPICAL_BASETYPE_BINREAD_(unsigned int)
+IMPLEMENT_TYPICAL_BASETYPE_BINREAD_(long)
+IMPLEMENT_TYPICAL_BASETYPE_BINREAD_(unsigned long)
+IMPLEMENT_TYPICAL_BASETYPE_BINREAD_(long)
+IMPLEMENT_TYPICAL_BASETYPE_BINREAD_(unsigned long)
+//IMPLEMENT_TYPICAL_BASETYPE_BINREAD_(int64_t)
+//IMPLEMENT_TYPICAL_BASETYPE_BINREAD_(uint64_t)
+*/
 
-//! The binread_ for float and double are special
+#define IMPLEMENT_NUMTYPE_BINREAD_(NUMTYPE)                                 \
+void binread_(PStream&amp; in, NUMTYPE* x,                                      \
+              unsigned int n, unsigned char typecode)                       \
+{                                                                           \
+    /* If typecode corresponds to NUMTYPE's typecode */                     \
+    if (typecode==TypeTraits&lt;NUMTYPE&gt;::little_endian_typecode())            \
+    {                                                                       \
+        in.read(reinterpret_cast&lt;char*&gt;(x), streamsize(n*sizeof(NUMTYPE))); \
+        if (byte_order()==BIG_ENDIAN_ORDER)                                 \
+            endianswap(x,n);                                                \
+    }                                                                       \
+    else if (typecode==TypeTraits&lt;NUMTYPE&gt;::big_endian_typecode())          \
+    {                                                                       \
+        in.read(reinterpret_cast&lt;char*&gt;(x), streamsize(n*sizeof(NUMTYPE))); \
+        if (byte_order()==LITTLE_ENDIAN_ORDER)                              \
+            endianswap(x,n);                                                \
+    }                                                                       \
+    /* Else, we need to try all the different types */                      \
+    else if (typecode==TypeTraits&lt;int8_t&gt;::little_endian_typecode())        \
+        binread_as&lt;int8_t&gt;(in, x, n, false);                                \
+    else if (typecode==TypeTraits&lt;uint8_t&gt;::little_endian_typecode())       \
+        binread_as&lt;uint8_t&gt;(in, x, n, false);                               \
+    else if (typecode==TypeTraits&lt;int16_t&gt;::little_endian_typecode())       \
+        binread_as&lt;int16_t&gt;(in, x, n, false);                               \
+    else if (typecode==TypeTraits&lt;uint16_t&gt;::little_endian_typecode())      \
+        binread_as&lt;uint16_t&gt;(in, x, n, false);                              \
+    else if (typecode==TypeTraits&lt;int32_t&gt;::little_endian_typecode())       \
+        binread_as&lt;int32_t&gt;(in, x, n, false);                               \
+    else if (typecode==TypeTraits&lt;uint32_t&gt;::little_endian_typecode())      \
+        binread_as&lt;uint32_t&gt;(in, x, n, false);                              \
+    else if (typecode==TypeTraits&lt;int64_t&gt;::little_endian_typecode())       \
+        binread_as&lt;int64_t&gt;(in, x, n, false);                               \
+    else if (typecode==TypeTraits&lt;uint64_t&gt;::little_endian_typecode())      \
+        binread_as&lt;uint64_t&gt;(in, x, n, false);                              \
+    else if (typecode==TypeTraits&lt;float&gt;::little_endian_typecode())         \
+        binread_as&lt;float&gt;(in, x, n, false);                                 \
+    else if (typecode==TypeTraits&lt;double&gt;::little_endian_typecode())        \
+        binread_as&lt;double&gt;(in, x, n, false);                                \
+    else                                                                    \
+        PLERROR(&quot;In binread_: Unknown typecode '%c' (%x)&quot;,                  \
+                typecode, typecode);                                        \
+}
 
+IMPLEMENT_NUMTYPE_BINREAD_(short)
+IMPLEMENT_NUMTYPE_BINREAD_(unsigned short)
+IMPLEMENT_NUMTYPE_BINREAD_(int)
+IMPLEMENT_NUMTYPE_BINREAD_(unsigned int)
+IMPLEMENT_NUMTYPE_BINREAD_(long)
+IMPLEMENT_NUMTYPE_BINREAD_(unsigned long)
+IMPLEMENT_NUMTYPE_BINREAD_(long long)
+IMPLEMENT_NUMTYPE_BINREAD_(unsigned long long)
+IMPLEMENT_NUMTYPE_BINREAD_(float)
+IMPLEMENT_NUMTYPE_BINREAD_(double)
+
+/*
 void binread_(PStream&amp; in, double* x, unsigned int n, unsigned char typecode)
 {
     if(typecode==TypeTraits&lt;double&gt;::little_endian_typecode())
@@ -2305,6 +2097,7 @@
     else
         PLERROR(&quot;In binread_ incompatible typecode&quot;);
 }
+*/
 
 } //end of namespace PLearn
 

Modified: trunk/plearn/io/PStream.h
===================================================================
--- trunk/plearn/io/PStream.h	2007-07-27 02:26:52 UTC (rev 7838)
+++ trunk/plearn/io/PStream.h	2007-07-27 02:30:10 UTC (rev 7839)
@@ -195,7 +195,7 @@
     inline void clearInMap()  { copies_map_in.clear(); }
     inline void clearInOutMaps()  { clearInMap(); clearOutMap(); }
 
-    //! if outmode is raw_ascii or raw_binary t will be switched to
+    //! if outmode is raw_ascii or raw_binary, it will be switched to
     //! corresponding plearn_ascii, resp. plearn_binary.
     //! The old mode will be returned, so that you can call setOutMode
     //! to revert to the old mode when finished
@@ -246,6 +246,92 @@
     //! Writes the corresponding 2 hex digits (ex: 0A )
     void writeAsciiHexNum(unsigned char x);
 
+    //! Writes base types to PLearn binary format
+    //! TODO: forbid this mechanism for arbitrary classes?
+    template&lt;class I&gt;
+    void writeBinaryNum(I x)
+    {
+#ifdef BIGENDIAN
+        put(TypeTraits&lt;I&gt;::big_endian_typecode());
+#else
+        put(TypeTraits&lt;I&gt;::little_endian_typecode());
+#endif
+        write((char*)&amp;x, sizeof(I));
+    }
+
+    //! Reads a J element, optionnally swaps its endianness, and returns an I
+    template&lt;class I, class J&gt;
+    void readBinaryNumAs(J&amp; x, bool inverted_byte_order)
+    {
+        I y;
+        read(reinterpret_cast&lt;char*&gt;(&amp;y), sizeof(I));
+        if (inverted_byte_order)
+            endianswap(&amp;y);
+        x = y;
+    }
+
+    //! Reads base types from PLearn binary format
+    //! TODO: forbid this mechanism for arbitrary classes?
+    template&lt;class I&gt;
+    void readBinaryNum(I &amp;x, unsigned char typecode)
+    {
+        // If typecode corresponds to I's typecode
+        if (typecode==TypeTraits&lt;I&gt;::little_endian_typecode())
+        {
+            read(reinterpret_cast&lt;char*&gt;(&amp;x), sizeof(I));
+#ifdef BIGENDIAN
+            endianswap(&amp;x);
+#endif
+        }
+        else if (typecode==TypeTraits&lt;I&gt;::big_endian_typecode())
+        {
+            read(reinterpret_cast&lt;char*&gt;(&amp;x), sizeof(I));
+#ifdef LITTLEENDIAN
+            endianswap(&amp;x);
+#endif
+        }
+        // Else, we need to try all the different types
+        else if (typecode==TypeTraits&lt;int8_t&gt;::little_endian_typecode())
+            readBinaryNumAs&lt;int8_t&gt;(x, false);
+        else if (typecode==TypeTraits&lt;uint8_t&gt;::little_endian_typecode())
+            readBinaryNumAs&lt;uint8_t&gt;(x, false);
+        else if (typecode==TypeTraits&lt;int16_t&gt;::little_endian_typecode())
+            readBinaryNumAs&lt;int16_t&gt;(x, byte_order()==BIG_ENDIAN_ORDER);
+        else if (typecode==TypeTraits&lt;int16_t&gt;::big_endian_typecode())
+            readBinaryNumAs&lt;int16_t&gt;(x, byte_order()==LITTLE_ENDIAN_ORDER);
+        else if (typecode==TypeTraits&lt;uint16_t&gt;::little_endian_typecode())
+            readBinaryNumAs&lt;uint16_t&gt;(x, byte_order()==BIG_ENDIAN_ORDER);
+        else if (typecode==TypeTraits&lt;uint16_t&gt;::big_endian_typecode())
+            readBinaryNumAs&lt;uint16_t&gt;(x, byte_order()==LITTLE_ENDIAN_ORDER);
+        else if (typecode==TypeTraits&lt;int32_t&gt;::little_endian_typecode())
+            readBinaryNumAs&lt;int32_t&gt;(x, byte_order()==BIG_ENDIAN_ORDER);
+        else if (typecode==TypeTraits&lt;int32_t&gt;::big_endian_typecode())
+            readBinaryNumAs&lt;int32_t&gt;(x, byte_order()==LITTLE_ENDIAN_ORDER);
+        else if (typecode==TypeTraits&lt;uint32_t&gt;::little_endian_typecode())
+            readBinaryNumAs&lt;uint32_t&gt;(x, byte_order()==BIG_ENDIAN_ORDER);
+        else if (typecode==TypeTraits&lt;uint32_t&gt;::big_endian_typecode())
+            readBinaryNumAs&lt;uint32_t&gt;(x, byte_order()==LITTLE_ENDIAN_ORDER);
+        else if (typecode==TypeTraits&lt;int64_t&gt;::little_endian_typecode())
+            readBinaryNumAs&lt;int64_t&gt;(x, byte_order()==BIG_ENDIAN_ORDER);
+        else if (typecode==TypeTraits&lt;int64_t&gt;::big_endian_typecode())
+            readBinaryNumAs&lt;int64_t&gt;(x, byte_order()==LITTLE_ENDIAN_ORDER);
+        else if (typecode==TypeTraits&lt;uint64_t&gt;::little_endian_typecode())
+            readBinaryNumAs&lt;uint64_t&gt;(x, byte_order()==BIG_ENDIAN_ORDER);
+        else if (typecode==TypeTraits&lt;uint64_t&gt;::big_endian_typecode())
+            readBinaryNumAs&lt;uint64_t&gt;(x, byte_order()==LITTLE_ENDIAN_ORDER);
+        else if (typecode==TypeTraits&lt;float&gt;::little_endian_typecode())
+            readBinaryNumAs&lt;float&gt;(x, byte_order()==BIG_ENDIAN_ORDER);
+        else if (typecode==TypeTraits&lt;float&gt;::big_endian_typecode())
+            readBinaryNumAs&lt;float&gt;(x, byte_order()==LITTLE_ENDIAN_ORDER);
+        else if (typecode==TypeTraits&lt;double&gt;::little_endian_typecode())
+            readBinaryNumAs&lt;double&gt;(x, byte_order()==BIG_ENDIAN_ORDER);
+        else if (typecode==TypeTraits&lt;double&gt;::big_endian_typecode())
+            readBinaryNumAs&lt;double&gt;(x, byte_order()==LITTLE_ENDIAN_ORDER);
+        else
+            PLERROR(&quot;In PStream readBinaryNum: Unknown typecode '%c' (%x)&quot;,
+                    typecode, typecode);
+    }
+
     inline bool eof() const
     { return ptr-&gt;eof(); }
 
@@ -459,7 +545,6 @@
     int count(char c);
 
     // operator&gt;&gt;'s for base types
-    PStream&amp; operator&gt;&gt;(bool &amp;x);
     PStream&amp; operator&gt;&gt;(float &amp;x);
     PStream&amp; operator&gt;&gt;(double &amp;x);
     PStream&amp; operator&gt;&gt;(string &amp;x);
@@ -467,16 +552,15 @@
     PStream&amp; operator&gt;&gt;(char &amp;x);
     PStream&amp; operator&gt;&gt;(signed char &amp;x);
     PStream&amp; operator&gt;&gt;(unsigned char &amp;x);
+    PStream&amp; operator&gt;&gt;(bool &amp;x);
+    PStream&amp; operator&gt;&gt;(short &amp;x);
+    PStream&amp; operator&gt;&gt;(unsigned short &amp;x);
     PStream&amp; operator&gt;&gt;(int &amp;x);
     PStream&amp; operator&gt;&gt;(unsigned int &amp;x);
-    //PStream&amp; operator&gt;&gt;(long &amp;x);
-    //PStream&amp; operator&gt;&gt;(unsigned long &amp;x);
-    PStream&amp; operator&gt;&gt;(int64_t &amp;x);
-    PStream&amp; operator&gt;&gt;(uint64_t &amp;x);
-    PStream&amp; operator&gt;&gt;(short &amp;x);
-    PStream&amp; operator&gt;&gt;(unsigned short &amp;x);
-    //PStream&amp; operator&gt;&gt;(long long &amp;x);
-    //PStream&amp; operator&gt;&gt;(unsigned long long &amp;x);
+    PStream&amp; operator&gt;&gt;(long &amp;x);
+    PStream&amp; operator&gt;&gt;(unsigned long &amp;x);
+    PStream&amp; operator&gt;&gt;(long long &amp;x);
+    PStream&amp; operator&gt;&gt;(unsigned long long &amp;x);
     PStream&amp; operator&gt;&gt;(pl_pstream_manip func) { return (*func)(*this); }
 
     // operator&lt;&lt;'s for base types
@@ -502,16 +586,14 @@
     // Note: If you get mysterious mesages of problems with const bool resolutions,
     // then a workaround might be to not declare &lt;&lt;(bool) as a method, but as an inline function
     PStream&amp; operator&lt;&lt;(bool x);
+    PStream&amp; operator&lt;&lt;(short x);
+    PStream&amp; operator&lt;&lt;(unsigned short x);
     PStream&amp; operator&lt;&lt;(int x);
     PStream&amp; operator&lt;&lt;(unsigned int x);
-    //PStream&amp; operator&lt;&lt;(long x);
-    //PStream&amp; operator&lt;&lt;(unsigned long x);
-    PStream&amp; operator&lt;&lt;(int64_t x);
-    PStream&amp; operator&lt;&lt;(uint64_t x);
-    //PStream&amp; operator&lt;&lt;(long long x);
-    //PStream&amp; operator&lt;&lt;(unsigned long long x);
-    PStream&amp; operator&lt;&lt;(short x);
-    PStream&amp; operator&lt;&lt;(unsigned short x);
+    PStream&amp; operator&lt;&lt;(long x);
+    PStream&amp; operator&lt;&lt;(unsigned long x);
+    PStream&amp; operator&lt;&lt;(long long x);
+    PStream&amp; operator&lt;&lt;(unsigned long long x);
     PStream&amp; operator&lt;&lt;(pl_pstream_manip func) { return (*func)(*this); }
 
 };
@@ -895,7 +977,6 @@
 inline void binwrite_(PStream&amp; out, unsigned int* x, unsigned int n)
 { out.write((char*)x, streamsize(n*sizeof(unsigned int))); }
 
-/*
 inline void binwrite_(PStream&amp; out, const long* x, unsigned int n)
 { out.write((char*)x, streamsize(n*sizeof(long))); }
 inline void binwrite_(PStream&amp; out, long* x, unsigned int n)
@@ -905,17 +986,16 @@
 { out.write((char*)x, streamsize(n*sizeof(unsigned long))); }
 inline void binwrite_(PStream&amp; out, unsigned long* x, unsigned int n)
 { out.write((char*)x, streamsize(n*sizeof(unsigned long))); }
-*/
 
-inline void binwrite_(PStream&amp; out, const int64_t* x, unsigned int n)
-{ out.write((char*)x, streamsize(n*sizeof(int64_t))); }
-inline void binwrite_(PStream&amp; out, int64_t* x, unsigned int n)
-{ out.write((char*)x, streamsize(n*sizeof(int64_t))); }
+inline void binwrite_(PStream&amp; out, const long long* x, unsigned int n)
+{ out.write((char*)x, streamsize(n*sizeof(long long))); }
+inline void binwrite_(PStream&amp; out, long long* x, unsigned int n)
+{ out.write((char*)x, streamsize(n*sizeof(long long))); }
 
-inline void binwrite_(PStream&amp; out, const uint64_t* x, unsigned int n)
-{ out.write((char*)x, streamsize(n*sizeof(uint64_t))); }
-inline void binwrite_(PStream&amp; out, uint64_t* x, unsigned int n)
-{ out.write((char*)x, streamsize(n*sizeof(uint64_t))); }
+inline void binwrite_(PStream&amp; out, const unsigned long long* x, unsigned int n)
+{ out.write((char*)x, streamsize(n*sizeof(unsigned long long))); }
+inline void binwrite_(PStream&amp; out, unsigned long long* x, unsigned int n)
+{ out.write((char*)x, streamsize(n*sizeof(unsigned long long))); }
 
 inline void binwrite_(PStream&amp; out, const float* x, unsigned int n)
 { out.write((char*)x, streamsize(n*sizeof(float))); }
@@ -942,6 +1022,22 @@
     }
 }
 
+
+//! Auxiliary function that reads n elements of type I, optionally swaps
+//! their endianness, then converts them into J, and puts them in a J array.
+template&lt;class I, class J&gt;
+void binread_as(PStream&amp; in, J* x, unsigned int n, bool inverted_byte_order)
+{
+    I y;
+    while(n--)
+    {
+        in.read(reinterpret_cast&lt;char*&gt;(&amp;y), sizeof(I));
+        if (inverted_byte_order)
+            endianswap(&amp;y);
+        *x++ = y;
+    }
+}
+
 void binread_(PStream&amp; in, bool* x, unsigned int n, unsigned char typecode);
 
 inline void binread_(PStream&amp; in, char* x,
@@ -967,10 +1063,10 @@
 void binread_(PStream&amp; in, unsigned short* x, unsigned int n, unsigned char typecode);
 void binread_(PStream&amp; in, int* x, unsigned int n, unsigned char typecode);
 void binread_(PStream&amp; in, unsigned int* x, unsigned int n, unsigned char typecode);
-//void binread_(PStream&amp; in, long* x, unsigned int n, unsigned char typecode);
-//void binread_(PStream&amp; in, unsigned long* x, unsigned int n, unsigned char typecode);
-void binread_(PStream&amp; in, int64_t* x, unsigned int n, unsigned char typecode);
-void binread_(PStream&amp; in, uint64_t* x, unsigned int n, unsigned char typecode);
+void binread_(PStream&amp; in, long* x, unsigned int n, unsigned char typecode);
+void binread_(PStream&amp; in, unsigned long* x, unsigned int n, unsigned char typecode);
+void binread_(PStream&amp; in, long long* x, unsigned int n, unsigned char typecode);
+void binread_(PStream&amp; in, unsigned long long* x, unsigned int n, unsigned char typecode);
 void binread_(PStream&amp; in, float* x, unsigned int n, unsigned char typecode);
 void binread_(PStream&amp; in, double* x, unsigned int n, unsigned char typecode);
 
@@ -979,7 +1075,7 @@
 void writeSequence(PStream&amp; out, const SequenceType&amp; seq)
 {
     // norman: added explicit cast
-    unsigned int n = (unsigned int)seq.size();
+    uint32_t n = (uint32_t)seq.size();
     typename SequenceType::const_iterator it = seq.begin();
 
     switch(out.outmode)


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001286.html">[Plearn-commits] r7838 - trunk/python_modules/plearn/learners/autolr
</A></li>
	<LI>Next message: <A HREF="001288.html">[Plearn-commits] r7840 - in trunk/plearn: base io
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1287">[ date ]</a>
              <a href="thread.html#1287">[ thread ]</a>
              <a href="subject.html#1287">[ subject ]</a>
              <a href="author.html#1287">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/plearn-commits">More information about the Plearn-commits
mailing list</a><br>
</body></html>
