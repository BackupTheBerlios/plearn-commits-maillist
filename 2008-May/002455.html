<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Plearn-commits] r9007 - trunk/plearn_learners_experimental
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/plearn-commits/2008-May/index.html" >
   <LINK REL="made" HREF="mailto:plearn-commits%40lists.berlios.de?Subject=Re%3A%20%5BPlearn-commits%5D%20r9007%20-%20trunk/plearn_learners_experimental&In-Reply-To=%3C200805150130.m4F1UO5Y016354%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002454.html">
   <LINK REL="Next"  HREF="002456.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Plearn-commits] r9007 - trunk/plearn_learners_experimental</H1>
    <B>larocheh at BerliOS</B> 
    <A HREF="mailto:plearn-commits%40lists.berlios.de?Subject=Re%3A%20%5BPlearn-commits%5D%20r9007%20-%20trunk/plearn_learners_experimental&In-Reply-To=%3C200805150130.m4F1UO5Y016354%40sheep.berlios.de%3E"
       TITLE="[Plearn-commits] r9007 - trunk/plearn_learners_experimental">larocheh at mail.berlios.de
       </A><BR>
    <I>Thu May 15 03:30:24 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="002454.html">[Plearn-commits] r9006 - trunk/plearn_learners_experimental
</A></li>
        <LI>Next message: <A HREF="002456.html">[Plearn-commits] r9008 - trunk/plearn/vmat
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2455">[ date ]</a>
              <a href="thread.html#2455">[ thread ]</a>
              <a href="subject.html#2455">[ subject ]</a>
              <a href="author.html#2455">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: larocheh
Date: 2008-05-15 03:30:22 +0200 (Thu, 15 May 2008)
New Revision: 9007

Modified:
   trunk/plearn_learners_experimental/DynamicallyLinkedRBMsModel.cc
   trunk/plearn_learners_experimental/DynamicallyLinkedRBMsModel.h
Log:
GETTING CLOSER!!!!!


Modified: trunk/plearn_learners_experimental/DynamicallyLinkedRBMsModel.cc
===================================================================
--- trunk/plearn_learners_experimental/DynamicallyLinkedRBMsModel.cc	2008-05-15 00:51:25 UTC (rev 9006)
+++ trunk/plearn_learners_experimental/DynamicallyLinkedRBMsModel.cc	2008-05-15 01:30:22 UTC (rev 9007)
@@ -61,12 +61,15 @@
 // - make sure gradient descent is proper (change some vectors into matrices, etc.)
 // - make sure end_of_sequence_symbol is used appropriately
 // - make sure declareOption includes everything, including saved variable
-// - implement deepcopy appropriately
-// - recurrent_nstages doesn't exist anymore
 // - verify use of mask is proper
-// - verify code works with and without hidden_layer2
 // - do proper resize of recurrent internal variables
+// - implement deepcopy appropriately
+// - corriger bug avec activation (faut additionner les biais!!!)
 
+// - commiter mse
+// - add dynamic_activations_list and use it in recurrent_update
+// - verify code works with and without hidden_layer2
+
 namespace PLearn {
 using namespace std;
 
@@ -372,53 +375,39 @@
 {
     inherited::makeDeepCopyFromShallowCopy(copies);
 
-    deepCopyField(visible_layer, copies);
-    deepCopyField( hidden_layer , copies);
+    deepCopyField( input_layer, copies);
+    deepCopyField( target_layers , copies);
+    deepCopyField( hidden_layer, copies);
+    deepCopyField( hidden_layer2 , copies);
     deepCopyField( dynamic_connections , copies);
-    deepCopyField( dynamic_connections_copy , copies);
-    deepCopyField( visible_connections , copies);
-    deepCopyField( connections , copies);
-    deepCopyField( connections_idem , copies);
-    deepCopyField( connections_idem_t , copies);
-    deepCopyField( connections_transpose, copies);
-    deepCopyField( connections_transpose_copy, copies);
-    deepCopyField( symbol_sizes , copies);
-    deepCopyField( cond_bias , copies);
-    deepCopyField( visi_cond_bias , copies);
+    deepCopyField( hidden_connections , copies);
+    deepCopyField( input_connections , copies);
+    deepCopyField( target_connections , copies);
+    deepCopyField( target_layers_n_of_target_elements, copies);
+    deepCopyField( input_symbol_sizes, copies);
+    deepCopyField( target_symbol_sizes, copies);
+    
+
     deepCopyField( bias_gradient , copies);
-    deepCopyField( visi_bias_gradient , copies);
-    deepCopyField( hidden_layer_target , copies);
-    deepCopyField( input_gradient , copies);
     deepCopyField( hidden_gradient , copies);
-    deepCopyField( hidden_gradient2 , copies);
     deepCopyField( hidden_temporal_gradient , copies);
-    deepCopyField( previous_input , copies);
-    deepCopyField( previous_target , copies);
-    deepCopyField( previous_hidden_layer , copies);
-    deepCopyField( previous_hidden_layer_activation , copies);
-    deepCopyField( previous_visible_layer , copies);
-    deepCopyField( hidden_layer_sample , copies);
-    deepCopyField( hidden_layer_expectation , copies);
-    deepCopyField( visible_layer_sample , copies);
-    deepCopyField( visible_layer_input , copies);
-    deepCopyField( pos_down_values , copies);
-    deepCopyField( pos_up_values , copies);
-    deepCopyField( alpha , copies);
     deepCopyField( hidden_list , copies);
-    deepCopyField( hidden_activations_list , copies);
+    deepCopyField( hidden_act_no_bias_list , copies);
     deepCopyField( hidden2_list , copies);
-    deepCopyField( hidden2_activations_list , copies);
-    deepCopyField( input_prediction_list , copies);
-    deepCopyField( input_prediction_activations_list , copies);
+    deepCopyField( hidden2_act_no_bias_list , copies);
+    deepCopyField( target_prediction_list , copies);
+    deepCopyField( target_prediction_act_no_bias_list , copies);
     deepCopyField( input_list , copies);
-    deepCopyField( target_list , copies);
+    deepCopyField( targets_list , copies);
     deepCopyField( nll_list , copies);
-    deepCopyField( input_expectation , copies);
+    deepCopyField( masks_list , copies);
+    deepCopyField( dynamic_activation_contribution, copies);
 
+
     // deepCopyField(, copies);
 
-    PLERROR(&quot;DynamicallyLinkedRBMsModel::makeDeepCopyFromShallowCopy(): &quot;
-    &quot;not implemented yet&quot;);
+    //PLERROR(&quot;DynamicallyLinkedRBMsModel::makeDeepCopyFromShallowCopy(): &quot;
+    //&quot;not implemented yet&quot;);
 }
 
 
@@ -536,11 +525,11 @@
                     
                     ith_sample_in_sequence = 0;
                     hidden_list.clear();
-                    hidden_activations_list.clear();
+                    hidden_act_no_bias_list.clear();
                     hidden2_list.clear();
-                    hidden2_activations_list.clear();
+                    hidden2_act_no_bias_list.clear();
                     target_prediction_list.clear();
-                    target_prediction_activations_list.clear();
+                    target_prediction_act_no_bias_list.clear();
                     input_list.clear();
                     targets_list.clear();
                     nll_list.clear();
@@ -550,13 +539,13 @@
 
                 // Resize internal variables
                 hidden_list.resize(ith_sample_in_sequence+1,hidden_layer-&gt;size);
-                hidden_activations_list.resize(ith_sample_in_sequence+1,
+                hidden_act_no_bias_list.resize(ith_sample_in_sequence+1,
                                                hidden_layer-&gt;size);
                 if( hidden_layer2 )
                 {
                     hidden2_list.resize(ith_sample_in_sequence+1,
                                         hidden_layer2-&gt;size);
-                    hidden2_activations_list.resize(ith_sample_in_sequence+1,
+                    hidden2_act_no_bias_list.resize(ith_sample_in_sequence+1,
                                                     hidden_layer2-&gt;size);
                 }
                  
@@ -564,14 +553,14 @@
 
                 targets_list.resize( target_layers.length() );
                 target_prediction_list.resize( target_layers.length() );
-                target_prediction_activations_list.resize( target_layers.length() );
+                target_prediction_act_no_bias_list.resize( target_layers.length() );
                 for( int tar=0; tar &lt; target_layers.length(); tar++ )
                 {
                     targets_list[tar].resize( ith_sample_in_sequence+1,
                                               target_layers[tar]-&gt;size );
                     target_prediction_list[tar].resize(
                         ith_sample_in_sequence+1, target_layers[tar]-&gt;size);
-                    target_prediction_activations_list[tar].resize(
+                    target_prediction_act_no_bias_list[tar].resize(
                         ith_sample_in_sequence+1, target_layers[tar]-&gt;size);
 
                 }
@@ -615,46 +604,46 @@
                                     target_layers[tar],
                                     target_symbol_sizes[tar]);
                     sum_target_elements += target_layers_n_of_target_elements[tar];
-                    target_list[tar](ith_sample_in_sequence) &lt;&lt; 
+                    targets_list[tar](ith_sample_in_sequence) &lt;&lt; 
                         target_layers[tar]-&gt;expectation;
                 }
                 
                 input_connections-&gt;fprop( input_list(ith_sample_in_sequence), 
-                                          hidden_activations_list(ith_sample_in_sequence));
+                                          hidden_act_no_bias_list(ith_sample_in_sequence));
                 
                 if( ith_sample_in_sequence &gt; 0 )
                 {
                     dynamic_connections-&gt;fprop( 
                         hidden_list(ith_sample_in_sequence-1),
-                        dynamic_activation_contribution );
+                        dynamic_act_no_bias_contribution );
 
-                    hidden_activations_list(ith_sample_in_sequence) += 
+                    hidden_act_no_bias_list(ith_sample_in_sequence) += 
                         dynamic_actvation_contribution;
                 }
                  
-                hidden_layer-&gt;fprop( hidden_activations_list(ith_sample_in_sequence) 
+                hidden_layer-&gt;fprop( hidden_act_no_bias_list(ith_sample_in_sequence) 
                                      hidden_list(ith_sample_in_sequence) );
                  
                 if( hidden_layer2 )
                 {
                     hidden_connections-&gt;fprop( 
                         hidden_list(ith_sample_in_sequence),
-                        hidden2_activations_list(ith_sample_in_sequence));
+                        hidden2_act_no_bias_list(ith_sample_in_sequence));
 
                     hidden_layer2-&gt;fprop( 
-                        hidden2_activations_list(ith_sample_in_sequence) 
+                        hidden2_act_no_bias_list(ith_sample_in_sequence) 
                         hidden2_list(ith_sample_in_sequence) 
                         );
 
                     for( int tar=0; tar &lt; target_layers.length(); tar++ )
                     {
-                        targets_connections[tar]-&gt;fprop(
+                        target_connections[tar]-&gt;fprop(
                             hidden2_list(ith_sample_in_sequence),
-                            target_prediction_activations_list[tar](
+                            target_prediction_act_no_bias_list[tar](
                                 ith_sample_in_sequence)
                             );
                         target_layers[tar]-&gt;fprop(
-                            target_prediction_activations_list[tar](
+                            target_prediction_act_no_bias_list[tar](
                                 ith_sample_in_sequence),
                             target_prediction_list[tar](
                                 ith_sample_in_sequence) );
@@ -667,13 +656,13 @@
                 {
                     for( int tar=0; tar &lt; target_layers.length(); tar++ )
                     {
-                        targets_connections[tar]-&gt;fprop(
+                        target_connections[tar]-&gt;fprop(
                             hidden_list(ith_sample_in_sequence),
-                            target_prediction_activations_list[tar](
+                            target_prediction_act_no_bias_list[tar](
                                 ith_sample_in_sequence)
                             );
                         target_layers[tar]-&gt;fprop(
-                            target_prediction_activations_list[tar](
+                            target_prediction_act_no_bias_list[tar](
                                 ith_sample_in_sequence),
                             target_prediction_list[tar](
                                 ith_sample_in_sequence) );
@@ -687,8 +676,9 @@
                 for( int tar=0; tar &lt; target_layers.length(); tar++ )
                 {
                     target_layers[tar]-&gt;activation &lt;&lt; 
-                        target_prediction_activations_list[tar](
+                        target_prediction_act_no_bias_list[tar](
                             ith_sample_in_sequence);
+                    target_layers[tar]-&gt;activation += target_layers[tar]-&gt;bias;
                     target_layers[tar]-&gt;setExpectation(
                         target_prediction_list[tar](
                             ith_sample_in_sequence));
@@ -817,46 +807,50 @@
 
 void DynamicallyLinkedRBMsModel::recurrent_update()
 {
-   
+    
         hidden_temporal_gradient.clear();
-        for(int i=hidden_list.length()-2; i&gt;=0; i--){   
+        for(int i=hidden_list.length()-1; i&gt;=0; i--){   
 
             hidden_gradient.clear();
             if(use_target_layers_masks)
             {
                 for( int tar=0; tar&lt;target_layers.length(); tar++)
                 {
+                    target_layer[tar]-&gt;activation &lt;&lt; targets_prediction_act_no_bias_list[tar](i);
+                    target_layer[tar]-&gt;activation += target_layer[tar]-&gt;bias;
                     target_layer[tar]-&gt;setExpectation(targets_prediction_list[tar](i));
-                    target_layers[tar]-&gt;bpropNLL(targets_list[tar](i+1),nll_list(i,tar),target_bias_gradient[tar]);
-                    target_bias_gradient[tar] *= target_layers_weights[tar];
-                    target_bias_gradient[tar] *= mask_list[tar](i);
-                    target_layers[tar]-&gt;update(target_bias_gradient[tar]);
-                    target_connections[tar]-&gt;bpropUpdate(hidden2_list(i),target_prediction_activations_list[tar](i),
-                                                         hidden_gradient, target_bias_gradient[tar],true);
+                    target_layers[tar]-&gt;bpropNLL(targets_list[tar](i),nll_list(i,tar),bias_gradient);
+                    bias_gradient *= target_layers_weights[tar];
+                    bias_gradient *= mask_list[tar](i);
+                    target_layers[tar]-&gt;update(bias_gradient);
+                    target_connections[tar]-&gt;bpropUpdate(hidden2_list(i),target_prediction_act_no_bias_list[tar](i),
+                                                         hidden_gradient, bias_gradient,true);
                 }
             }
             else
             {
                 for( int tar=0; tar&lt;target_layers.length(); tar++)
                 {
+                    target_layer[tar]-&gt;activation &lt;&lt; targets_prediction_act_no_bias_list[tar](i);
+                    target_layer[tar]-&gt;activation += target_layer[tar]-&gt;bias;
                     target_layer[tar]-&gt;setExpectation(targets_prediction_list[tar](i));
-                    target_layers[tar]-&gt;bpropNLL(targets_list[tar](i+1),nll_list(i,tar),target_bias_gradient[tar]);
-                    target_bias_gradient[tar] *= target_layers_weights[tar];
-                    target_layers[tar]-&gt;update(target_bias_gradient[tar]);
-                    target_connections[tar]-&gt;bpropUpdate(hidden2_list(i),target_prediction_activations_list[tar](i),
-                                                         hidden_gradient, target_bias_gradient[tar],true); 
+                    target_layers[tar]-&gt;bpropNLL(targets_list[tar](i),nll_list(i,tar),bias_gradient);
+                    bias_gradient *= target_layers_weights[tar];
+                    target_layers[tar]-&gt;update(bias_gradient);
+                    target_connections[tar]-&gt;bpropUpdate(hidden2_list(i),target_prediction_act_no_bias_list[tar](i),
+                                                         hidden_gradient, bias_gradient,true); 
                 }
             }
 
             if (hidden_layer2)
             {
                 hidden_layer2-&gt;bpropUpdate(
-                    hidden2_activations_list(i), hidden2_list(i),
+                    hidden2_act_no_bias_list(i), hidden2_list(i),
                     bias_gradient, hidden_gradient);
                 
                 hidden_connections-&gt;bpropUpdate(
                     hidden_list(i),
-                    hidden2_activations_list(i), 
+                    hidden2_act_no_bias_list(i), 
                     hidden_gradient, bias_gradient);
             }
             
@@ -865,130 +859,38 @@
                 hidden_gradient += hidden_temporal_gradient;
                 
                 hidden_layer-&gt;bpropUpdate(
-                    hidden_activations_list(i), hidden_list(i),
+                    hidden_act_no_bias_list(i), hidden_list(i),
                     hidden_temporal_gradient, hidden_gradient);
                 
                 dynamic_connections-&gt;bpropUpdate(
                     hidden_list(i-1),
-                    hidden_activations_list(i), // Here, it should be cond_bias, but doesn't matter
+                    hidden_act_no_bias_list(i), // Here, it should be cond_bias, but doesn't matter
                     hidden_gradient, hidden_temporal_gradient);
                 
                 hidden_temporal_gradient &lt;&lt; hidden_gradient;
                 
                 connections-&gt;bpropUpdate(
                     input_list(i),
-                    hidden_activations_list(i), 
+                    hidden_act_no_bias_list(i), 
                     visi_bias_gradient, hidden_temporal_gradient);// Here, it should be activations - cond_bias, but doesn't matter
                 
             }
             else
             {
-                // Could learn initial value for h_{-1}
-            }
-        }
-    
-}
-
-
-void DynamicallyLinkedRBMsModel::recurrent_update()
-{
-    // Notes: 
-    //    - not all lists are useful (some *_activations_* are not)
-    //int segment = hidden_list.length()/2;
-    //int seg =0;
-    //for(int k=hidden_list.length()-3; k&gt;=-segment; k-=segment){ 
-    //  seg = k;
-    //  if(seg &lt; 0)
-    //      seg = 0;
-        //cout &lt;&lt; &quot;segment: &quot; &lt;&lt; seg &lt;&lt; endl;
-        hidden_temporal_gradient.clear();
-        for(int i=hidden_list.length()-2; i&gt;=0; i--){  
-            // for(int i=hidden_list.length()-2; i&gt;=seg; i--){     
-            
-            //visible_layer-&gt;expectation &lt;&lt; input_prediction_list(i);
-            //visible_layer-&gt;activation &lt;&lt; ?????;
-            
-            
-            
-            
-            
-
-            hidden_gradient.clear();
-            for( int tar=0; tar&lt;target_layers.length(); tar++)
-            {
-                target_layer[tar]-&gt;setExpectation(input_prediction_list[tar](i));
-                target_layers[tar]-&gt;bpropNLL(targets_list[tar](i+1),nll_list(i,tar),target_bias_gradient[tar]);
-                target_bias_gradient[tar] *= target_layers_weights[tar];
-                target_layers[tar]-&gt;update(target_bias_gradient[tar]);
-                target_connections[tar]-&gt;bpropUpdate(hidden2_list(i),target_prediction_activations_list[tar](i),
-                                                     hidden_gradient, target_bias_gradient[tar],true);
-            }
-            //visible_layer-&gt;setExpectation(input_prediction_list(i));
-            //visible_layer-&gt;bpropNLL(input_list(i+1),nll_list[i],visi_bias_gradient);
-            //visible_layer-&gt;update(visi_bias_gradient);
-            //connections_transpose-&gt;bpropUpdate(hidden2_list(i),input_prediction_activations_list(i),hidden_gradient, visi_bias_gradient);
-            
-            
-            //hidden_layer-&gt;setExpectation(hidden_list(i+1));//////////////////////////////
-            //hidden_layer-&gt;bpropNLL(hidden2_list(i),nll_list[i], hidden_gradient2);////////////////////////////////
-            
-           
-            hidden_layer2-&gt;bpropUpdate(
-                hidden2_activations_list(i), hidden2_list(i),
-                bias_gradient, hidden_gradient);
-            
-
-
-
-            //hidden_layer-&gt;update(hidden_gradient2);/////////////////////////////////////
-            
-            
-            //bias_gradient += hidden_gradient2;///////////////////////////////////
-            
-            
-            
-            if(dynamic_connections_copy)
-                dynamic_connections_copy-&gt;bpropUpdate(
-                    hidden_list(i),
-                    hidden2_activations_list(i), 
-                    hidden_gradient, bias_gradient);        
-            else
-                dynamic_connections-&gt;bpropUpdate(
-                    hidden_list(i),
-                    hidden2_activations_list(i), 
-                    hidden_gradient, bias_gradient);
-            
-            if(i!=0)
-            {
-                
-                hidden_gradient += hidden_temporal_gradient;
-                
                 hidden_layer-&gt;bpropUpdate(
-                    hidden_activations_list(i), hidden_list(i),
-                    hidden_temporal_gradient, hidden_gradient);
-                
-                dynamic_connections-&gt;bpropUpdate(
-                    hidden_list(i-1),
-                    hidden_activations_list(i), // Here, it should be cond_bias, but doesn't matter
-                    hidden_gradient, hidden_temporal_gradient);
-                
-                hidden_temporal_gradient &lt;&lt; hidden_gradient;
-                
+                    hidden_act_no_bias_list(i), hidden_list(i),
+                    hidden_temporal_gradient, hidden_gradient); // Not really temporal gradient, but this is the final iteration...
                 connections-&gt;bpropUpdate(
                     input_list(i),
-                    hidden_activations_list(i), 
+                    hidden_act_no_bias_list(i), 
                     visi_bias_gradient, hidden_temporal_gradient);// Here, it should be activations - cond_bias, but doesn't matter
-                
-            }
-            else
-            {
+
                 // Could learn initial value for h_{-1}
             }
         }
     
 }
 
-
 void DynamicallyLinkedRBMsModel::computeOutput(const Vec&amp; input, Vec&amp; output) const
 {
     PLERROR(&quot;DynamicallyLinkedRBMsModel::computeOutput(): this is a dynamic, &quot;
@@ -1037,11 +939,11 @@
         {                    
             ith_sample_in_sequence = 0;
             hidden_list.clear();
-            hidden_activations_list.clear();
+            hidden_act_no_bias_list.clear();
             hidden2_list.clear();
-            hidden2_activations_list.clear();
+            hidden2_act_no_bias_list.clear();
             target_prediction_list.clear();
-            target_prediction_activations_list.clear();
+            target_prediction_act_no_bias_list.clear();
             input_list.clear();
             targets_list.clear();
             nll_list.clear();
@@ -1051,13 +953,13 @@
 
         // Resize internal variables
         hidden_list.resize(ith_sample_in_sequence+1,hidden_layer-&gt;size);
-        hidden_activations_list.resize(ith_sample_in_sequence+1,
+        hidden_act_no_bias_list.resize(ith_sample_in_sequence+1,
                                        hidden_layer-&gt;size);
         if( hidden_layer2 )
         {
             hidden2_list.resize(ith_sample_in_sequence+1,
                                 hidden_layer2-&gt;size);
-            hidden2_activations_list.resize(ith_sample_in_sequence+1,
+            hidden2_act_no_bias_list.resize(ith_sample_in_sequence+1,
                                             hidden_layer2-&gt;size);
         }
         
@@ -1065,14 +967,14 @@
         
         targets_list.resize( target_layers.length() );
         target_prediction_list.resize( target_layers.length() );
-        target_prediction_activations_list.resize( target_layers.length() );
+        target_prediction_act_no_bias_list.resize( target_layers.length() );
         for( int tar=0; tar &lt; target_layers.length(); tar++ )
         {
             targets_list[tar].resize( ith_sample_in_sequence+1,
                                       target_layers[tar]-&gt;size );
             target_prediction_list[tar].resize(
                 ith_sample_in_sequence+1, target_layers[tar]-&gt;size);
-            target_prediction_activations_list[tar].resize(
+            target_prediction_act_no_bias_list[tar].resize(
                 ith_sample_in_sequence+1, target_layers[tar]-&gt;size);
             
         }
@@ -1116,46 +1018,46 @@
                             target_layers[tar],
                             target_symbol_sizes[tar]);
             sum_target_elements += target_layers_n_of_target_elements[tar];
-            target_list[tar](ith_sample_in_sequence) &lt;&lt; 
+            targets_list[tar](ith_sample_in_sequence) &lt;&lt; 
                 target_layers[tar]-&gt;expectation;
         }
         
         input_connections-&gt;fprop( input_list(ith_sample_in_sequence), 
-                                  hidden_activations_list(ith_sample_in_sequence));
+                                  hidden_act_no_bias_list(ith_sample_in_sequence));
         
         if( ith_sample_in_sequence &gt; 0 )
         {
             dynamic_connections-&gt;fprop( 
                 hidden_list(ith_sample_in_sequence-1),
-                dynamic_activation_contribution );
+                dynamic_act_no_bias_contribution );
             
-            hidden_activations_list(ith_sample_in_sequence) += 
+            hidden_act_no_bias_list(ith_sample_in_sequence) += 
                 dynamic_actvation_contribution;
         }
         
-        hidden_layer-&gt;fprop( hidden_activations_list(ith_sample_in_sequence) 
+        hidden_layer-&gt;fprop( hidden_act_no_bias_list(ith_sample_in_sequence) 
                              hidden_list(ith_sample_in_sequence) );
         
         if( hidden_layer2 )
         {
             hidden_connections-&gt;fprop( 
                 hidden_list(ith_sample_in_sequence),
-                hidden2_activations_list(ith_sample_in_sequence));
+                hidden2_act_no_bias_list(ith_sample_in_sequence));
             
             hidden_layer2-&gt;fprop( 
-                hidden2_activations_list(ith_sample_in_sequence) 
+                hidden2_act_no_bias_list(ith_sample_in_sequence) 
                 hidden2_list(ith_sample_in_sequence) 
                 );
             
             for( int tar=0; tar &lt; target_layers.length(); tar++ )
             {
-                targets_connections[tar]-&gt;fprop(
+                target_connections[tar]-&gt;fprop(
                     hidden2_list(ith_sample_in_sequence),
-                    target_prediction_activations_list[tar](
+                    target_prediction_act_no_bias_list[tar](
                         ith_sample_in_sequence)
                     );
                 target_layers[tar]-&gt;fprop(
-                    target_prediction_activations_list[tar](
+                    target_prediction_act_no_bias_list[tar](
                         ith_sample_in_sequence),
                     target_prediction_list[tar](
                         ith_sample_in_sequence) );
@@ -1168,13 +1070,13 @@
         {
             for( int tar=0; tar &lt; target_layers.length(); tar++ )
             {
-                targets_connections[tar]-&gt;fprop(
+                target_connections[tar]-&gt;fprop(
                     hidden_list(ith_sample_in_sequence),
-                    target_prediction_activations_list[tar](
+                    target_prediction_act_no_bias_list[tar](
                         ith_sample_in_sequence)
                     );
                 target_layers[tar]-&gt;fprop(
-                    target_prediction_activations_list[tar](
+                    target_prediction_act_no_bias_list[tar](
                         ith_sample_in_sequence),
                     target_prediction_list[tar](
                         ith_sample_in_sequence) );
@@ -1200,8 +1102,9 @@
         for( int tar=0; tar &lt; target_layers.length(); tar++ )
         {
             target_layers[tar]-&gt;activation &lt;&lt; 
-                target_prediction_activations_list[tar](
+                target_prediction_act_no_bias_list[tar](
                     ith_sample_in_sequence);
+            target_layers[tar]-&gt;activation += target_layers[tar]-&gt;bias;
             target_layers[tar]-&gt;setExpectation(
                 target_prediction_list[tar](
                     ith_sample_in_sequence));
@@ -1240,11 +1143,11 @@
     
     ith_sample_in_sequence = 0;
     hidden_list.clear();
-    hidden_activations_list.clear();
+    hidden_act_no_bias_list.clear();
     hidden2_list.clear();
-    hidden2_activations_list.clear();
+    hidden2_act_no_bias_list.clear();
     target_prediction_list.clear();
-    target_prediction_activations_list.clear();
+    target_prediction_act_no_bias_list.clear();
     input_list.clear();
     targets_list.clear();
     nll_list.clear();
@@ -1266,257 +1169,257 @@
     return getTestCostNames();
 }
 
-void DynamicallyLinkedRBMsModel::gen()
-{
-    //PPath* the_filename = &quot;/home/stan/Documents/recherche_maitrise/DDBN_bosendorfer/data/generate/scoreGen.amat&quot;;
-    data = new AutoVMatrix();
-    data-&gt;filename = &quot;/home/stan/Documents/recherche_maitrise/DDBN_bosendorfer/data/generate/scoreGen.amat&quot;;
-    data-&gt;defineSizes(21,0,0);
-    //data-&gt;inputsize = 21;
-    //data-&gt;targetsize = 0;
-    //data-&gt;weightsize = 0;
-    data-&gt;build();
+//void DynamicallyLinkedRBMsModel::gen()
+//{
+//    //PPath* the_filename = &quot;/home/stan/Documents/recherche_maitrise/DDBN_bosendorfer/data/generate/scoreGen.amat&quot;;
+//    data = new AutoVMatrix();
+//    data-&gt;filename = &quot;/home/stan/Documents/recherche_maitrise/DDBN_bosendorfer/data/generate/scoreGen.amat&quot;;
+//    data-&gt;defineSizes(21,0,0);
+//    //data-&gt;inputsize = 21;
+//    //data-&gt;targetsize = 0;
+//    //data-&gt;weightsize = 0;
+//    data-&gt;build();
+//
+//    
+//    int len = data-&gt;length();
+//    Vec score;
+//    Vec target;
+//    real weight;
+//    Vec bias_tempo;
+//    Vec visi_bias_tempo;
+//   
+//   
+//    
+//    previous_hidden_layer.resize(hidden_layer-&gt;size);
+//    connections_idem = connections;
+//
+//    for (int ith_sample = 0; ith_sample &lt; len ; ith_sample++ ){
+//        
+//        data-&gt;getExample(ith_sample, score, target, weight);
+//        //score &lt;&lt; data(ith_sample);
+//        input_prediction_list.resize(
+//            ith_sample+1,visible_layer-&gt;size);
+//        if(ith_sample &gt; 0)
+//        {
+//            
+//            //input_list(ith_sample_in_sequence) &lt;&lt; previous_input;
+//            //h*_{t-1}
+//            //////////////////////////////////
+//            dynamic_connections-&gt;fprop(previous_hidden_layer, cond_bias);
+//            hidden_layer-&gt;setAllBias(cond_bias); //**************************
+//            
+//            
+//            
+//            //up phase
+//            connections-&gt;setAsDownInput( input_prediction_list(ith_sample-1) );
+//            hidden_layer-&gt;getAllActivations( connections_idem );
+//            hidden_layer-&gt;computeExpectation();
+//            //////////////////////////////////
+//            
+//            //previous_hidden_layer &lt;&lt; hidden_layer-&gt;expectation;//h_{t-2} au prochain tour//******************************
+//            //previous_hidden_layer_act_no_bias &lt;&lt; hidden_layer-&gt;activation;
+//            
+//            
+//            //h*_{t}
+//            ////////////
+//            if(dynamic_connections_copy)
+//                dynamic_connections_copy-&gt;fprop( hidden_layer-&gt;expectation ,hidden_layer-&gt;activation);//conection entre h_{t-1} et h_{t}
+//            else
+//                dynamic_connections-&gt;fprop( hidden_layer-&gt;expectation ,hidden_layer-&gt;activation);//conection entre h_{t-1} et h_{t}
+//            //dynamic_connections_copy-&gt;fprop( hidden_layer-&gt;expectation ,hidden_layer-&gt;activation);//conection entre h_{t-1} et h_{t}
+//            hidden_layer-&gt;expectation_is_not_up_to_date();
+//            hidden_layer-&gt;computeExpectation();//h_{t}
+//            ///////////
+//            
+//            //previous_input &lt;&lt; visible_layer-&gt;expectation;//v_{t-1}
+//            
+//        }
+//        else
+//        {
+//            
+//            previous_hidden_layer.clear();//h_{t-1}
+//            if(dynamic_connections_copy)
+//                dynamic_connections_copy-&gt;fprop( previous_hidden_layer ,
+//                                                 hidden_layer-&gt;activation);//conection entre h_{t-1} et h_{t}
+//            else
+//                dynamic_connections-&gt;fprop(previous_hidden_layer,
+//                                           hidden_layer-&gt;activation);//conection entre h_{t-1} et h_{t}
+//            
+//            hidden_layer-&gt;expectation_is_not_up_to_date();
+//            hidden_layer-&gt;computeExpectation();//h_{t}
+//            //previous_input.resize(data-&gt;inputsize);
+//            //previous_input &lt;&lt; data(ith_sample);
+//            
+//        }
+//        
+//        //connections_transpose-&gt;setAsDownInput( hidden_layer-&gt;expectation );
+//        //visible_layer-&gt;getAllActivations( connections_idem_t );
+//        
+//        connections-&gt;setAsUpInput( hidden_layer-&gt;expectation );
+//        visible_layer-&gt;getAllActivations( connections_idem );
+//        
+//        visible_layer-&gt;computeExpectation();
+//        //visible_layer-&gt;generateSample();
+//        partition(score.subVec(14,taillePart), visible_layer-&gt;activation.subVec(14+taillePart,taillePart), visible_layer-&gt;activation.subVec(14+(taillePart*2),taillePart));
+//        partition(score.subVec(14,taillePart), visible_layer-&gt;expectation.subVec(14+taillePart,taillePart), visible_layer-&gt;expectation.subVec(14+(taillePart*2),taillePart));
+//
+//
+//        visible_layer-&gt;activation.subVec(0,14+taillePart) &lt;&lt; score;
+//        visible_layer-&gt;expectation.subVec(0,14+taillePart) &lt;&lt; score;
+//
+//        input_prediction_list(ith_sample) &lt;&lt; visible_layer-&gt;expectation;
+//        
+//    }
+//    
+//    //Vec tempo;
+//    TVec&lt;real&gt; tempo;
+//    tempo.resize(visible_layer-&gt;size);
+//    ofstream myfile;
+//    myfile.open (&quot;/home/stan/Documents/recherche_maitrise/DDBN_bosendorfer/data/generate/test.txt&quot;);
+//    
+//    for (int i = 0; i &lt; len ; i++ ){
+//        tempo &lt;&lt; input_prediction_list(i);
+//        
+//        //cout &lt;&lt; tempo[2] &lt;&lt; endl;
+//       
+//        for (int j = 0; j &lt; tempo.length() ; j++ ){
+//            
+//            
+//                
+//                
+//               myfile &lt;&lt; tempo[j] &lt;&lt; &quot; &quot;;
+//               
+//
+//               
+//           
+//        }
+//        myfile &lt;&lt; &quot;\n&quot;;
+//    }
+//     
+//
+//     myfile.close();
+//
+//}
+//void DynamicallyLinkedRBMsModel::generate(int nbNotes)
+//{
+//    
+//    previous_hidden_layer.resize(hidden_layer-&gt;size);
+//    connections_idem = connections;
+//
+//    for (int ith_sample = 0; ith_sample &lt; nbNotes ; ith_sample++ ){
+//        
+//        input_prediction_list.resize(
+//            ith_sample+1,visible_layer-&gt;size);
+//        if(ith_sample &gt; 0)
+//        {
+//            
+//            //input_list(ith_sample_in_sequence) &lt;&lt; previous_input;
+//            //h*_{t-1}
+//            //////////////////////////////////
+//            dynamic_connections-&gt;fprop(previous_hidden_layer, cond_bias);
+//            hidden_layer-&gt;setAllBias(cond_bias); //**************************
+//            
+//            
+//            
+//            //up phase
+//            connections-&gt;setAsDownInput( input_prediction_list(ith_sample-1) );
+//            hidden_layer-&gt;getAllActivations( connections_idem );
+//            hidden_layer-&gt;computeExpectation();
+//            //////////////////////////////////
+//            
+//            //previous_hidden_layer &lt;&lt; hidden_layer-&gt;expectation;//h_{t-2} au prochain tour//******************************
+//            //previous_hidden_layer_act_no_bias &lt;&lt; hidden_layer-&gt;activation;
+//            
+//            
+//            //h*_{t}
+//            ////////////
+//            if(dynamic_connections_copy)
+//                dynamic_connections_copy-&gt;fprop( hidden_layer-&gt;expectation ,hidden_layer-&gt;activation);//conection entre h_{t-1} et h_{t}
+//            else
+//                dynamic_connections-&gt;fprop( hidden_layer-&gt;expectation ,hidden_layer-&gt;activation);//conection entre h_{t-1} et h_{t}
+//            //dynamic_connections_copy-&gt;fprop( hidden_layer-&gt;expectation ,hidden_layer-&gt;activation);//conection entre h_{t-1} et h_{t}
+//            hidden_layer-&gt;expectation_is_not_up_to_date();
+//            hidden_layer-&gt;computeExpectation();//h_{t}
+//            ///////////
+//            
+//            //previous_input &lt;&lt; visible_layer-&gt;expectation;//v_{t-1}
+//            
+//        }
+//        else
+//        {
+//            
+//            previous_hidden_layer.clear();//h_{t-1}
+//            if(dynamic_connections_copy)
+//                dynamic_connections_copy-&gt;fprop( previous_hidden_layer ,
+//                                                 hidden_layer-&gt;activation);//conection entre h_{t-1} et h_{t}
+//            else
+//                dynamic_connections-&gt;fprop(previous_hidden_layer,
+//                                           hidden_layer-&gt;activation);//conection entre h_{t-1} et h_{t}
+//            
+//            hidden_layer-&gt;expectation_is_not_up_to_date();
+//            hidden_layer-&gt;computeExpectation();//h_{t}
+//            
+//            
+//        }
+//        
+//        //connections_transpose-&gt;setAsDownInput( hidden_layer-&gt;expectation );
+//        //visible_layer-&gt;getAllActivations( connections_idem_t );
+//        
+//        connections-&gt;setAsUpInput( hidden_layer-&gt;expectation );
+//        visible_layer-&gt;getAllActivations( connections_idem );
+//        
+//        visible_layer-&gt;computeExpectation();
+//        visible_layer-&gt;generateSample();
+//        
+//        input_prediction_list(ith_sample) &lt;&lt; visible_layer-&gt;sample;
+//        
+//    }
+//    
+//    //Vec tempo;
+//    TVec&lt;int&gt; tempo;
+//    tempo.resize(visible_layer-&gt;size);
+//    int theNote;
+//    //int nbNoteVisiLayer = input_prediction_list(1).length()/13;
+//    ofstream myfile;
+//    int theLayer;
+//    myfile.open (&quot;/home/stan/Documents/recherche_maitrise/DDBN_musicGeneration/data/generate/test.txt&quot;);
+//    
+//    for (int i = 0; i &lt; nbNotes ; i++ ){
+//        tempo &lt;&lt; input_prediction_list(i);
+//        
+//        //cout &lt;&lt; tempo[2] &lt;&lt; endl;
+//       
+//        for (int j = 0; j &lt; tempo.length() ; j++ ){
+//            
+//            if (tempo[j] == 1){
+//                theLayer = (j/13);
+//                
+//                theNote = j - (13*theLayer);
+//               
+//
+//                if (theNote&lt;=11){
+//                    //print theNote
+//                    //cout &lt;&lt; theNote+50 &lt;&lt; &quot; &quot;;
+//                    myfile &lt;&lt; theNote &lt;&lt; &quot; &quot;;
+//                }
+//                else{
+//                    //print #
+//                    //cout &lt;&lt; &quot;# &quot;;
+//                    myfile &lt;&lt; &quot;# &quot;;
+//                    
+//                }
+//     
+//            }
+//           
+//        }
+//        myfile &lt;&lt; &quot;\n&quot;;
+//    }
+//     myfile &lt;&lt; &quot;&lt;oov&gt; &lt;oov&gt; \n&quot;;
+//
+//     myfile.close();
+//
+//}
 
-    
-    int len = data-&gt;length();
-    Vec score;
-    Vec target;
-    real weight;
-    Vec bias_tempo;
-    Vec visi_bias_tempo;
-   
-   
-    
-    previous_hidden_layer.resize(hidden_layer-&gt;size);
-    connections_idem = connections;
-
-    for (int ith_sample = 0; ith_sample &lt; len ; ith_sample++ ){
-        
-        data-&gt;getExample(ith_sample, score, target, weight);
-        //score &lt;&lt; data(ith_sample);
-        input_prediction_list.resize(
-            ith_sample+1,visible_layer-&gt;size);
-        if(ith_sample &gt; 0)
-        {
-            
-            //input_list(ith_sample_in_sequence) &lt;&lt; previous_input;
-            //h*_{t-1}
-            //////////////////////////////////
-            dynamic_connections-&gt;fprop(previous_hidden_layer, cond_bias);
-            hidden_layer-&gt;setAllBias(cond_bias); //**************************
-            
-            
-            
-            //up phase
-            connections-&gt;setAsDownInput( input_prediction_list(ith_sample-1) );
-            hidden_layer-&gt;getAllActivations( connections_idem );
-            hidden_layer-&gt;computeExpectation();
-            //////////////////////////////////
-            
-            //previous_hidden_layer &lt;&lt; hidden_layer-&gt;expectation;//h_{t-2} au prochain tour//******************************
-            //previous_hidden_layer_activation &lt;&lt; hidden_layer-&gt;activation;
-            
-            
-            //h*_{t}
-            ////////////
-            if(dynamic_connections_copy)
-                dynamic_connections_copy-&gt;fprop( hidden_layer-&gt;expectation ,hidden_layer-&gt;activation);//conection entre h_{t-1} et h_{t}
-            else
-                dynamic_connections-&gt;fprop( hidden_layer-&gt;expectation ,hidden_layer-&gt;activation);//conection entre h_{t-1} et h_{t}
-            //dynamic_connections_copy-&gt;fprop( hidden_layer-&gt;expectation ,hidden_layer-&gt;activation);//conection entre h_{t-1} et h_{t}
-            hidden_layer-&gt;expectation_is_not_up_to_date();
-            hidden_layer-&gt;computeExpectation();//h_{t}
-            ///////////
-            
-            //previous_input &lt;&lt; visible_layer-&gt;expectation;//v_{t-1}
-            
-        }
-        else
-        {
-            
-            previous_hidden_layer.clear();//h_{t-1}
-            if(dynamic_connections_copy)
-                dynamic_connections_copy-&gt;fprop( previous_hidden_layer ,
-                                                 hidden_layer-&gt;activation);//conection entre h_{t-1} et h_{t}
-            else
-                dynamic_connections-&gt;fprop(previous_hidden_layer,
-                                           hidden_layer-&gt;activation);//conection entre h_{t-1} et h_{t}
-            
-            hidden_layer-&gt;expectation_is_not_up_to_date();
-            hidden_layer-&gt;computeExpectation();//h_{t}
-            //previous_input.resize(data-&gt;inputsize);
-            //previous_input &lt;&lt; data(ith_sample);
-            
-        }
-        
-        //connections_transpose-&gt;setAsDownInput( hidden_layer-&gt;expectation );
-        //visible_layer-&gt;getAllActivations( connections_idem_t );
-        
-        connections-&gt;setAsUpInput( hidden_layer-&gt;expectation );
-        visible_layer-&gt;getAllActivations( connections_idem );
-        
-        visible_layer-&gt;computeExpectation();
-        //visible_layer-&gt;generateSample();
-        partition(score.subVec(14,taillePart), visible_layer-&gt;activation.subVec(14+taillePart,taillePart), visible_layer-&gt;activation.subVec(14+(taillePart*2),taillePart));
-        partition(score.subVec(14,taillePart), visible_layer-&gt;expectation.subVec(14+taillePart,taillePart), visible_layer-&gt;expectation.subVec(14+(taillePart*2),taillePart));
-
-
-        visible_layer-&gt;activation.subVec(0,14+taillePart) &lt;&lt; score;
-        visible_layer-&gt;expectation.subVec(0,14+taillePart) &lt;&lt; score;
-
-        input_prediction_list(ith_sample) &lt;&lt; visible_layer-&gt;expectation;
-        
-    }
-    
-    //Vec tempo;
-    TVec&lt;real&gt; tempo;
-    tempo.resize(visible_layer-&gt;size);
-    ofstream myfile;
-    myfile.open (&quot;/home/stan/Documents/recherche_maitrise/DDBN_bosendorfer/data/generate/test.txt&quot;);
-    
-    for (int i = 0; i &lt; len ; i++ ){
-        tempo &lt;&lt; input_prediction_list(i);
-        
-        //cout &lt;&lt; tempo[2] &lt;&lt; endl;
-       
-        for (int j = 0; j &lt; tempo.length() ; j++ ){
-            
-            
-                
-                
-               myfile &lt;&lt; tempo[j] &lt;&lt; &quot; &quot;;
-               
-
-               
-           
-        }
-        myfile &lt;&lt; &quot;\n&quot;;
-    }
-     
-
-     myfile.close();
-
-}
-void DynamicallyLinkedRBMsModel::generate(int nbNotes)
-{
-    
-    previous_hidden_layer.resize(hidden_layer-&gt;size);
-    connections_idem = connections;
-
-    for (int ith_sample = 0; ith_sample &lt; nbNotes ; ith_sample++ ){
-        
-        input_prediction_list.resize(
-            ith_sample+1,visible_layer-&gt;size);
-        if(ith_sample &gt; 0)
-        {
-            
-            //input_list(ith_sample_in_sequence) &lt;&lt; previous_input;
-            //h*_{t-1}
-            //////////////////////////////////
-            dynamic_connections-&gt;fprop(previous_hidden_layer, cond_bias);
-            hidden_layer-&gt;setAllBias(cond_bias); //**************************
-            
-            
-            
-            //up phase
-            connections-&gt;setAsDownInput( input_prediction_list(ith_sample-1) );
-            hidden_layer-&gt;getAllActivations( connections_idem );
-            hidden_layer-&gt;computeExpectation();
-            //////////////////////////////////
-            
-            //previous_hidden_layer &lt;&lt; hidden_layer-&gt;expectation;//h_{t-2} au prochain tour//******************************
-            //previous_hidden_layer_activation &lt;&lt; hidden_layer-&gt;activation;
-            
-            
-            //h*_{t}
-            ////////////
-            if(dynamic_connections_copy)
-                dynamic_connections_copy-&gt;fprop( hidden_layer-&gt;expectation ,hidden_layer-&gt;activation);//conection entre h_{t-1} et h_{t}
-            else
-                dynamic_connections-&gt;fprop( hidden_layer-&gt;expectation ,hidden_layer-&gt;activation);//conection entre h_{t-1} et h_{t}
-            //dynamic_connections_copy-&gt;fprop( hidden_layer-&gt;expectation ,hidden_layer-&gt;activation);//conection entre h_{t-1} et h_{t}
-            hidden_layer-&gt;expectation_is_not_up_to_date();
-            hidden_layer-&gt;computeExpectation();//h_{t}
-            ///////////
-            
-            //previous_input &lt;&lt; visible_layer-&gt;expectation;//v_{t-1}
-            
-        }
-        else
-        {
-            
-            previous_hidden_layer.clear();//h_{t-1}
-            if(dynamic_connections_copy)
-                dynamic_connections_copy-&gt;fprop( previous_hidden_layer ,
-                                                 hidden_layer-&gt;activation);//conection entre h_{t-1} et h_{t}
-            else
-                dynamic_connections-&gt;fprop(previous_hidden_layer,
-                                           hidden_layer-&gt;activation);//conection entre h_{t-1} et h_{t}
-            
-            hidden_layer-&gt;expectation_is_not_up_to_date();
-            hidden_layer-&gt;computeExpectation();//h_{t}
-            
-            
-        }
-        
-        //connections_transpose-&gt;setAsDownInput( hidden_layer-&gt;expectation );
-        //visible_layer-&gt;getAllActivations( connections_idem_t );
-        
-        connections-&gt;setAsUpInput( hidden_layer-&gt;expectation );
-        visible_layer-&gt;getAllActivations( connections_idem );
-        
-        visible_layer-&gt;computeExpectation();
-        visible_layer-&gt;generateSample();
-        
-        input_prediction_list(ith_sample) &lt;&lt; visible_layer-&gt;sample;
-        
-    }
-    
-    //Vec tempo;
-    TVec&lt;int&gt; tempo;
-    tempo.resize(visible_layer-&gt;size);
-    int theNote;
-    //int nbNoteVisiLayer = input_prediction_list(1).length()/13;
-    ofstream myfile;
-    int theLayer;
-    myfile.open (&quot;/home/stan/Documents/recherche_maitrise/DDBN_musicGeneration/data/generate/test.txt&quot;);
-    
-    for (int i = 0; i &lt; nbNotes ; i++ ){
-        tempo &lt;&lt; input_prediction_list(i);
-        
-        //cout &lt;&lt; tempo[2] &lt;&lt; endl;
-       
-        for (int j = 0; j &lt; tempo.length() ; j++ ){
-            
-            if (tempo[j] == 1){
-                theLayer = (j/13);
-                
-                theNote = j - (13*theLayer);
-               
-
-                if (theNote&lt;=11){
-                    //print theNote
-                    //cout &lt;&lt; theNote+50 &lt;&lt; &quot; &quot;;
-                    myfile &lt;&lt; theNote &lt;&lt; &quot; &quot;;
-                }
-                else{
-                    //print #
-                    //cout &lt;&lt; &quot;# &quot;;
-                    myfile &lt;&lt; &quot;# &quot;;
-                    
-                }
-     
-            }
-           
-        }
-        myfile &lt;&lt; &quot;\n&quot;;
-    }
-     myfile &lt;&lt; &quot;&lt;oov&gt; &lt;oov&gt; \n&quot;;
-
-     myfile.close();
-
-}
-
 } // end of namespace PLearn
 
 

Modified: trunk/plearn_learners_experimental/DynamicallyLinkedRBMsModel.h
===================================================================
--- trunk/plearn_learners_experimental/DynamicallyLinkedRBMsModel.h	2008-05-15 00:51:25 UTC (rev 9006)
+++ trunk/plearn_learners_experimental/DynamicallyLinkedRBMsModel.h	2008-05-15 01:30:22 UTC (rev 9007)
@@ -164,12 +164,12 @@
     virtual TVec&lt;std::string&gt; getTestCostNames() const;
 
 
-    //! Generate music in a folder
-    void generate(int nbNotes);
+//    //! Generate music in a folder
+//    void generate(int nbNotes);
+//
+//    //! Generate a part of the data in a folder
+//    void gen();
 
-    //! Generate a part of the data in a folder
-    void gen();
-
     //! Returns the names of the objective costs that the train method computes
     //! and  for which it updates the VecStatsCollector train_stats.
     virtual TVec&lt;std::string&gt; getTrainCostNames() const;
@@ -232,69 +232,27 @@
    
     //! Stores bias gradient
     mutable Vec bias_gradient;
-
+    
      //! Stores bias gradient
     mutable Vec visi_bias_gradient;
 
-    //! Stores hidden layer target in dynamic learning phase
-    mutable Vec hidden_layer_target;
-
-    //! Stores input gradient of dynamic connections
-    mutable Vec input_gradient;
-    
     //! Stores hidden gradient of dynamic connections
     mutable Vec hidden_gradient;
     
-    //! Stores hidden gradient of dynamic connections
-    mutable Vec hidden_gradient2;
-
-    
     //! Stores hidden gradient of dynamic connections coming from time t+1
     mutable Vec hidden_temporal_gradient;
-    
-    //! Stores previous input layer value
-    mutable Vec previous_input;
-
-    //! Stores previous target layer value
-    mutable TVec&lt; Vec &gt; previous_targets;
-    
-    //! Stores previous hidden layer value
-    mutable Vec previous_hidden_layer;
-    mutable Vec previous_hidden_layer_activation;
-
-    //! Stores previous visible layer value
-    mutable Vec previous_visible_layer;
-
-    //! Stores a sample from the hidden layer
-    mutable Vec hidden_layer_sample;
-
-     //! Stores a expectation from the hidden layer
-    mutable Vec hidden_layer_expectation;
-
-    //! Stores a sample from the visible layer
-    mutable Vec visible_layer_sample;
-
-    //! Stores a input from the visible layer
-    mutable Vec visible_layer_input;
-
-    //! Store a copy of the positive phase values
-    mutable Vec pos_down_values;
-    mutable Vec pos_up_values;
-
-    //! Parameter of the dynamic connection
-    mutable Vec alpha;
-
+        
     //! List of hidden layers values
     mutable Mat hidden_list;
-    mutable Mat hidden_activations_list;
+    mutable Mat hidden_act_no_bias_list;
 
     //! List of second hidden layers values
     mutable Mat hidden2_list;
-    mutable Mat hidden2_activations_list;
+    mutable Mat hidden2_act_no_bias_list;
 
     //! List of target prediction values
     mutable TVec&lt; Mat &gt; target_prediction_list;
-    mutable TVec&lt; Mat &gt; target_prediction_activations_list;
+    mutable TVec&lt; Mat &gt; target_prediction_act_no_bias_list;
 
     //! List of inputs values
     mutable Mat input_list;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002454.html">[Plearn-commits] r9006 - trunk/plearn_learners_experimental
</A></li>
	<LI>Next message: <A HREF="002456.html">[Plearn-commits] r9008 - trunk/plearn/vmat
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2455">[ date ]</a>
              <a href="thread.html#2455">[ thread ]</a>
              <a href="subject.html#2455">[ subject ]</a>
              <a href="author.html#2455">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/plearn-commits">More information about the Plearn-commits
mailing list</a><br>
</body></html>
