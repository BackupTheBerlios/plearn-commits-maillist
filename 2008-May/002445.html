<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Plearn-commits] r8997 - trunk/plearn_learners_experimental
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/plearn-commits/2008-May/index.html" >
   <LINK REL="made" HREF="mailto:plearn-commits%40lists.berlios.de?Subject=Re%3A%20%5BPlearn-commits%5D%20r8997%20-%20trunk/plearn_learners_experimental&In-Reply-To=%3C200805141818.m4EIIMYX011221%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002444.html">
   <LINK REL="Next"  HREF="002446.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Plearn-commits] r8997 - trunk/plearn_learners_experimental</H1>
    <B>laulysta at BerliOS</B> 
    <A HREF="mailto:plearn-commits%40lists.berlios.de?Subject=Re%3A%20%5BPlearn-commits%5D%20r8997%20-%20trunk/plearn_learners_experimental&In-Reply-To=%3C200805141818.m4EIIMYX011221%40sheep.berlios.de%3E"
       TITLE="[Plearn-commits] r8997 - trunk/plearn_learners_experimental">laulysta at mail.berlios.de
       </A><BR>
    <I>Wed May 14 20:18:22 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="002444.html">[Plearn-commits] r8996 - trunk/plearn_learners_experimental
</A></li>
        <LI>Next message: <A HREF="002446.html">[Plearn-commits] r8998 - trunk/plearn/vmat
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2445">[ date ]</a>
              <a href="thread.html#2445">[ thread ]</a>
              <a href="subject.html#2445">[ subject ]</a>
              <a href="author.html#2445">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: laulysta
Date: 2008-05-14 20:18:21 +0200 (Wed, 14 May 2008)
New Revision: 8997

Modified:
   trunk/plearn_learners_experimental/DynamicallyLinkedRBMsModel.cc
   trunk/plearn_learners_experimental/DynamicallyLinkedRBMsModel.h
Log:
pour HUGO


Modified: trunk/plearn_learners_experimental/DynamicallyLinkedRBMsModel.cc
===================================================================
--- trunk/plearn_learners_experimental/DynamicallyLinkedRBMsModel.cc	2008-05-14 13:12:51 UTC (rev 8996)
+++ trunk/plearn_learners_experimental/DynamicallyLinkedRBMsModel.cc	2008-05-14 18:18:21 UTC (rev 8997)
@@ -43,6 +43,23 @@
 #include &quot;DynamicallyLinkedRBMsModel.h&quot;
 #include &quot;plearn/math/plapack.h&quot;
 
+// Options to have:
+//
+// - input_layer
+// - input_connection
+// - target_layers
+// - target_connections
+// - target_layers_weights
+// - mask_size
+// - end_of_sequence_symbol
+// - input reconstruction weight
+//
+// Problems to have in mind:
+// 
+// - have a proper normalization of costs
+// - output one cost per target + weighted sum of all costs
+// - make sure gradient descent is proper (change some vectors into matrices, etc.)
+
 namespace PLearn {
 using namespace std;
 
@@ -59,6 +76,8 @@
     fine_tuning_learning_rate( 0.01 ),
     recurrent_net_learning_rate( 0.01),
     untie_weights( false ),
+    taillePart( 0 ),
+    isRegression( 0 ),
     rbm_nstages( 0 ),
     dynamic_nstages( 0 ),
     fine_tuning_nstages( 0 ),
@@ -99,6 +118,14 @@
                   OptionBase::buildoption,
                   &quot;Indication to untie weights in recurrent net&quot;);
 
+    declareOption(ol, &quot;taillePart&quot;, &amp;DynamicallyLinkedRBMsModel::taillePart,
+                  OptionBase::buildoption,
+                  &quot;Indication the size of the partition&quot;);
+
+    declareOption(ol, &quot;isRegression&quot;, &amp;DynamicallyLinkedRBMsModel::isRegression,
+                  OptionBase::buildoption,
+                  &quot;Indication if the model is used for regression&quot;);
+
     declareOption(ol, &quot;rbm_nstages&quot;, &amp;DynamicallyLinkedRBMsModel::rbm_nstages,
                   OptionBase::buildoption,
                   &quot;Number of epochs for rbm phase&quot;);
@@ -115,10 +142,14 @@
                   OptionBase::buildoption,
                   &quot;Number of epochs for the recurrent phase&quot;);
 
-    declareOption(ol, &quot;visible_layer&quot;, &amp;DynamicallyLinkedRBMsModel::visible_layer,
+    declareOption(ol, &quot;input_layer&quot;, &amp;DynamicallyLinkedRBMsModel::input_layer,
                   OptionBase::buildoption,
-                  &quot;The visible layer of the RBMs&quot;);
+                  &quot;The input layer of the model&quot;);
 
+    declareOption(ol, &quot;target_layer&quot;, &amp;DynamicallyLinkedRBMsModel::target_layer,
+                  OptionBase::buildoption,
+                  &quot;The target layer of the model&quot;);
+
     declareOption(ol, &quot;hidden_layer&quot;, &amp;DynamicallyLinkedRBMsModel::hidden_layer,
                   OptionBase::buildoption,
                   &quot;The hidden layer of the RBMs. Its size must be set, and will\n&quot;
@@ -175,10 +206,10 @@
 
     if(train_set)
     {
-        visible_size = 0;
-        symbol_sizes.resize(0);
+        input_size = 0;
+        input_symbol_sizes.resize(0);
         PP&lt;Dictionary&gt; dict;        
-        for(int i=0; i&lt;train_set-&gt;inputsize(); i++)
+        for(int i=0; i&lt;input_layer-&gt;size; i++)
         {
             dict = train_set-&gt;getDictionary(i);
             if(dict)
@@ -186,41 +217,61 @@
                 if( dict-&gt;size() == 0 )
                     PLERROR(&quot;DynamicallyLinkedRBMsModel::build_(): dictionary &quot;
                         &quot;of field %d is empty&quot;, i);
-                symbol_sizes.push_back(dict-&gt;size());
+                input_symbol_sizes.push_back(dict-&gt;size());
                 // Adjust size to include one-hot vector
-                visible_size += dict-&gt;size();
+                input_size += dict-&gt;size();
             }
             else
             {
-                symbol_sizes.push_back(-1);
-                visible_size++;
+                input_symbol_sizes.push_back(-1);
+                input_size++;
             }
         }
 
+        //target_size.fill(-1);
+        //target_symbol_sizes.resize(0);
+        target_size = 0;
+        for( int tar=0; tar&lt;target_layers.length(); tar++){
+            target_layers_size[tar] = 0;
+            target_symbol_sizes.resize(0,0);
+            for(int i=0; i&lt;target_layer[tar]-&gt;size; i++)
+            {
+                dict = train_set-&gt;getDictionary(i);
+                if(dict)
+                {
+                    if( dict-&gt;size() == 0 )
+                        PLERROR(&quot;DynamicallyLinkedRBMsModel::build_(): dictionary &quot;
+                                &quot;of field %d is empty&quot;, i);
+                    target_symbol_sizes.resize(tar+1,i+1);
+                    target_symbol_sizes(tar,i) = dict-&gt;size();
+                    // Adjust size to include one-hot vector
+                    target_layers_size[tar] += dict-&gt;size();
+                    target_size += dict-&gt;size();
+                }
+                else
+                {
+
+                    target_symbol_sizes.resize(tar+1,i+1);
+                    target_symbol_sizes(tar,i) = -1;
+                    target_layers_size[tar]++;
+                    target_size++;
+                }
+            }
+        }
         // Set and verify sizes
         if(hidden_layer-&gt;size &lt;= 0)
             PLERROR(&quot;DynamicallyLinkedRBMsModel::build_(): hidden_layer-&gt;size &quot;
                 &quot;must be &gt; 0&quot;);
 
-        //cond_bias.resize(hidden_layer-&gt;size);
-
-        pos_down_values.resize(visible_size);
-        pos_up_values.resize(hidden_layer-&gt;size);
-        hidden_layer_target.resize(hidden_layer-&gt;size);
-        hidden_layer_sample.resize(hidden_layer-&gt;size);
-        visible_layer_sample.resize(visible_size);
-        previous_hidden_layer.resize(hidden_layer-&gt;size);
-        previous_hidden_layer_activation.resize(hidden_layer-&gt;size);
+        
         previous_visible_layer.resize(visible_size);
 
         visi_bias_gradient.resize(visible_size);
-        hidden_temporal_gradient.resize(hidden_layer-&gt;size);
 
         visible_layer-&gt;size = visible_size;
 
         connections-&gt;down_size = visible_size;
         connections-&gt;up_size = hidden_layer-&gt;size;
-        connections_idem = connections;
 
         dynamic_connections-&gt;input_size = hidden_layer-&gt;size;
         dynamic_connections-&gt;output_size = hidden_layer-&gt;size;
@@ -244,7 +295,19 @@
         connections_transpose = new RBMMatrixTransposeConnection(connections);
         connections_idem_t = connections_transpose;
     }
+    if(hidden_layer-&gt;size&gt;0){
+        previous_hidden_layer.resize(hidden_layer-&gt;size);
 
+        pos_up_values.resize(hidden_layer-&gt;size);
+        hidden_layer_target.resize(hidden_layer-&gt;size);
+        hidden_layer_sample.resize(hidden_layer-&gt;size);
+        previous_hidden_layer.resize(hidden_layer-&gt;size);
+        previous_hidden_layer_activation.resize(hidden_layer-&gt;size);
+        hidden_temporal_gradient.resize(hidden_layer-&gt;size);
+    }
+    if(connections)
+        connections_idem = connections;
+
 }
 
 // ### Nothing to add here, simply calls build_
@@ -280,6 +343,7 @@
     deepCopyField( hidden_gradient2 , copies);
     deepCopyField( hidden_temporal_gradient , copies);
     deepCopyField( previous_input , copies);
+    deepCopyField( previous_target , copies);
     deepCopyField( previous_hidden_layer , copies);
     deepCopyField( previous_hidden_layer_activation , copies);
     deepCopyField( previous_visible_layer , copies);
@@ -297,6 +361,7 @@
     deepCopyField( input_prediction_list , copies);
     deepCopyField( input_prediction_activations_list , copies);
     deepCopyField( input_list , copies);
+    deepCopyField( target_list , copies);
     deepCopyField( nll_list , copies);
     deepCopyField( input_expectation , copies);
 
@@ -403,230 +468,26 @@
     /***** RBM training phase *****/
     if(stage &lt; rbm_nstages)
     {
-        MODULE_LOG &lt;&lt; &quot;Training connection weights between RBMs&quot; &lt;&lt; endl;
-
-        int init_stage = stage;
-        int end_stage = min( rbm_nstages, nstages );
-
-        MODULE_LOG &lt;&lt; &quot;  stage = &quot; &lt;&lt; stage &lt;&lt; endl;
-        MODULE_LOG &lt;&lt; &quot;  end_stage = &quot; &lt;&lt; end_stage &lt;&lt; endl;
-        MODULE_LOG &lt;&lt; &quot;  rbm_learning_rate = &quot; &lt;&lt; rbm_learning_rate &lt;&lt; endl;
-
-        if( report_progress &amp;&amp; stage &lt; end_stage )
-            pb = new ProgressBar( &quot;RBM training phase of &quot;+classname(),
-                                  end_stage - init_stage );
-
-        visible_layer-&gt;setLearningRate( rbm_learning_rate );
-        connections-&gt;setLearningRate( rbm_learning_rate );
-        hidden_layer-&gt;setLearningRate( rbm_learning_rate );
-        real mean_cost = 0;
-        while(stage &lt; end_stage)
-        {
-            for(int sample=0 ; sample&lt;train_set-&gt;length() ; sample++ )
-            {
-                train_set-&gt;getExample(sample, input, target, weight);
-
-               
-                if(train_set-&gt;getString(sample,0) == &quot;&lt;oov&gt;&quot;)
-                    continue;
-
-                clamp_visible_units(input);
-
-                mean_cost += rbm_update();
-
-            }
-
-            if( pb )
-                pb-&gt;update( stage + 1 - init_stage);
-            if(verbosity&gt;0)
-                cout &lt;&lt; &quot;mean cost at stage &quot; &lt;&lt; stage &lt;&lt; 
-                    &quot; = &quot; &lt;&lt; mean_cost/train_set-&gt;length() &lt;&lt; endl;
-            mean_cost = 0;
-            stage++;
-        }    
-        if( pb )
-        {
-            delete pb;
-            pb = 0;
-        }
-
-        //cout &lt;&lt; &quot;RBM training phase&quot; &lt;&lt; endl;
     }
 
 
-
-
     /***** dynamic phase training  *****/
 
     if(stage &lt; rbm_nstages +  dynamic_nstages)
     {
-        MODULE_LOG &lt;&lt; &quot;Training dynamic connections between RBMs' hidden layers&quot; &lt;&lt; endl;
+    }  
 
-        int init_stage = stage;
-        int end_stage = min( rbm_nstages + dynamic_nstages, nstages );
 
-        MODULE_LOG &lt;&lt; &quot;  stage = &quot; &lt;&lt; stage &lt;&lt; endl;
-        MODULE_LOG &lt;&lt; &quot;  end_stage = &quot; &lt;&lt; end_stage &lt;&lt; endl;
-        MODULE_LOG &lt;&lt; &quot;  dynamic_learning_rate = &quot; &lt;&lt; dynamic_learning_rate &lt;&lt; endl;
-        MODULE_LOG &lt;&lt; &quot;  visible_dynamic_learning_rate = &quot; &lt;&lt; visible_dynamic_learning_rate &lt;&lt; endl;
-
-
-        if( report_progress &amp;&amp; stage &lt; end_stage )
-            pb = new ProgressBar( &quot;Dynamic training phase of &quot;+classname(),
-                                  end_stage - init_stage );
-
-        previous_hidden_layer.resize(hidden_layer-&gt;size);
-        previous_visible_layer.resize(visible_layer-&gt;size);
-        dynamic_connections-&gt;setLearningRate( dynamic_learning_rate );
-        visible_connections-&gt;setLearningRate( visible_dynamic_learning_rate );
-        real mean_cost = 0;
-        while(stage &lt; end_stage)
-        {
-            for(int sample=0 ; sample&lt;train_set-&gt;length() ; sample++ )
-            {
-                if(sample &gt; 0)
-                {
-                    previous_hidden_layer &lt;&lt; hidden_layer_sample;
-                    previous_visible_layer &lt;&lt; visible_layer_sample;
-                    // ** or **
-                    // hidden_layer-&gt;generateSample();
-                    // previous_hidden_layer &lt;&lt; hidden_layer-&gt;sample;
-                }
-                else
-                {
-                    previous_hidden_layer.clear();
-                    previous_visible_layer.clear();
-                }
-
-                train_set-&gt;getExample(sample, input, target, weight);
-
-                if(train_set-&gt;getString(sample,0) == &quot;&lt;oov&gt;&quot;)
-                {
-                    hidden_layer_sample.clear();
-                    visible_layer_sample.clear();
-                    continue;
-                }
-            
-                clamp_visible_units(input);
-                
-                mean_cost += dynamic_connections_update();
-                                
-            }
-            if( pb )
-                pb-&gt;update( stage + 1 - init_stage);
-
-            if(verbosity&gt;0)
-                cout &lt;&lt; &quot;mean cost at stage &quot; &lt;&lt; stage &lt;&lt; 
-                    &quot; = &quot; &lt;&lt; mean_cost/train_set-&gt;length() &lt;&lt; endl;
-            mean_cost = 0;
-            stage++;
-        }    
-        if( pb )
-        {
-            delete pb;
-            pb = 0;
-        }
-
-        //Make a copy of the dynamique phase
-        //CopiesMap map;
-        //dynamic_connections_copy = dynamic_connections-&gt;deepCopy(map);
-
-        //cout &lt;&lt; &quot;dynamic phase training&quot; &lt;&lt; endl;
-    }
-
-
-    //cout &lt;&lt; dynamic_connections_copy-&gt;weights &lt;&lt; endl;
-
-
-    //alpha = Vec(hidden_layer-&gt;size,1);
-
-
-
     /***** fine-tuning *****/
     if( stage &gt;= nstages )
         return;
 
     if(stage &lt; rbm_nstages +  dynamic_nstages + fine_tuning_nstages )
     {
-        MODULE_LOG &lt;&lt; &quot;Training the whole model&quot; &lt;&lt; endl;
-
-        int init_stage = stage;
-        //int end_stage = max(0,nstages-(rbm_nstages + dynamic_nstages));
-        //int end_stage = nstages;
-        int end_stage = min( rbm_nstages + dynamic_nstages + fine_tuning_nstages, nstages );
-
-        MODULE_LOG &lt;&lt; &quot;  stage = &quot; &lt;&lt; stage &lt;&lt; endl;
-        MODULE_LOG &lt;&lt; &quot;  end_stage = &quot; &lt;&lt; end_stage &lt;&lt; endl;
-        MODULE_LOG &lt;&lt; &quot;  fine_tuning_learning_rate = &quot; &lt;&lt; fine_tuning_learning_rate &lt;&lt; endl;
-
-        if( report_progress &amp;&amp; stage &lt; end_stage )
-            pb = new ProgressBar( &quot;Fine-tuning training phase of &quot;+classname(),
-                                  end_stage - init_stage );
-
-        previous_hidden_layer.resize(hidden_layer-&gt;size);
-        dynamic_connections-&gt;setLearningRate( fine_tuning_learning_rate );
-        visible_layer-&gt;setLearningRate( fine_tuning_learning_rate );
-        connections-&gt;setLearningRate( fine_tuning_learning_rate );
-
-        real mean_cost = 0;
-
-
-        while(stage &lt; end_stage)
-        {
-            for(int sample=0 ; sample&lt;train_set-&gt;length() ; sample++ )
-            {
-                if(sample &gt; 0)
-                {
-                    previous_hidden_layer &lt;&lt; hidden_layer_sample;
-
-                    // ** or **
-                    // hidden_layer-&gt;generateSample();
-                    // previous_hidden_layer &lt;&lt; hidden_layer-&gt;sample;
-                }
-                else
-                    previous_hidden_layer.clear();
-
-
-                train_set-&gt;getExample(sample, input, target, weight);
-
-                
-
-                if(train_set-&gt;getString(sample,0) == &quot;&lt;oov&gt;&quot;)
-                {
-                    hidden_layer_sample.clear();
-                    continue;
-                }
-
-                
-
-                clamp_visible_units(input);
-                
-                mean_cost += fine_tuning_update();     
-                //cout &lt;&lt; &quot;lalalalalalallalalalalalalala4&quot; &lt;&lt; endl;
-            }
-
-            if( pb )
-                pb-&gt;update( stage + 1 - init_stage);
-
-            if(verbosity&gt;0)
-                cout &lt;&lt; &quot;mean cost at stage &quot; &lt;&lt; stage &lt;&lt; 
-                    &quot; = &quot; &lt;&lt; mean_cost/train_set-&gt;length() &lt;&lt; endl;
-            mean_cost = 0;
-            stage++;
-        }    
-        if( pb )
-        {
-            delete pb;
-            pb = 0;
-        }
-
     }
 
-    //cout &lt;&lt; dynamic_connections-&gt;weights - dynamic_connections_copy-&gt;weights&lt;&lt; endl;    
-    
 
-
- /***** Recurrent phase *****/
+    /***** Recurrent phase *****/
     if( stage &gt;= nstages )
         return;
 
@@ -660,21 +521,25 @@
         real mean_cost = 0;
         int ith_sample_in_sequence = 0;
         int nb_oov = 0;
-
+        
+        RBMMixedLayer* p_visible_layer = dynamic_cast&lt;RBMMixedLayer*&gt;((RBMLayer*)visible_layer);
+        target_layer = p_visible_layer-&gt;sub_layers[3];
+        //target_layer = (PLearn::PP&lt;PLearn::RBMMixedLayer&gt;)visible_layer;
+        //test_layer = target_layer.sub_layers(1);
         while(stage &lt; end_stage)
         {
             if(untie_weights &amp;&amp; 
                stage == rbm_nstages + dynamic_nstages + fine_tuning_nstages)
             {
                 
-                //CopiesMap map;
-                //dynamic_connections_copy = dynamic_connections-&gt;deepCopy(map);
+                CopiesMap map;
+                dynamic_connections_copy = dynamic_connections-&gt;deepCopy(map);
 
                 //CopiesMap map2;
                 //connections_transpose_copy = connections_transpose-&gt;deepCopy(map2);
                 //connections_transpose = connections_transpose_copy;  
 /*
-                TMat&lt;real&gt; U,V;//////////*********************crap James
+                TMat&lt;real&gt; U,V;//////////crap James
                 TVec&lt;real&gt; S;
                 U.resize(hidden_layer-&gt;size,hidden_layer-&gt;size);
                 V.resize(hidden_layer-&gt;size,hidden_layer-&gt;size);
@@ -702,32 +567,17 @@
                 input_prediction_activations_list.resize(
                     ith_sample_in_sequence+1,visible_layer-&gt;size);
                 input_list.resize(ith_sample_in_sequence+1,visible_layer-&gt;size);
+                target_list.resize(ith_sample_in_sequence+1,target_layer-&gt;size);
                 nll_list.resize(ith_sample_in_sequence+1);
+                
+               
 
+                //if(train_set-&gt;getString(sample,0) == &quot;&lt;oov&gt;&quot;)
+                if(train_set-&gt;get(sample,0) == 8)
+                {
 
-                if(train_set-&gt;getString(sample,0) == &quot;&lt;oov&gt;&quot;)
-                {/*
-                    nb_oov++;
-                    hidden_list.resize(ith_sample_in_sequence,hidden_layer-&gt;size);
-                    hidden_activations_list.resize(ith_sample_in_sequence,hidden_layer-&gt;size);
-                    hidden2_list.resize(ith_sample_in_sequence,hidden_layer-&gt;size);
-                    hidden2_activations_list.resize(ith_sample_in_sequence,hidden_layer-&gt;size);
-                    input_prediction_list.resize(
-                        ith_sample_in_sequence,visible_layer-&gt;size);
-                    input_prediction_activations_list.resize(
-                        ith_sample_in_sequence,visible_layer-&gt;size);
-                    input_list.resize(ith_sample_in_sequence,visible_layer-&gt;size);
-                    nll_list.resize(ith_sample_in_sequence);
-                    recurrent_update();
-                    ith_sample_in_sequence = 0;
-                    hidden_list.clear();
-                    hidden2_list.clear();
-                    input_prediction_list.clear();
-                    input_list.clear();
-                    nll_list.clear();
-                    continue;
-                 */
                     input_list(ith_sample_in_sequence) &lt;&lt; previous_input;
+                    target_list(ith_sample_in_sequence) &lt;&lt; previous_target;
                     connections-&gt;setAsDownInput( previous_input );
                     hidden_layer-&gt;getAllActivations( connections_idem );
                     hidden_layer-&gt;computeExpectation();
@@ -753,39 +603,30 @@
                     hidden2_list.clear();
                     input_prediction_list.clear();
                     input_list.clear();
+                    target_list.clear();
                     nll_list.clear();
                     continue;
                 }
-/*
-                hidden_list.resize(ith_sample_in_sequence+1,hidden_layer-&gt;size);
-                hidden_activations_list.resize(ith_sample_in_sequence+1,hidden_layer-&gt;size);
-                hidden2_list.resize(ith_sample_in_sequence+1,hidden_layer-&gt;size);
-                hidden2_activations_list.resize(ith_sample_in_sequence+1,hidden_layer-&gt;size);
-                input_prediction_list.resize(
-                    ith_sample_in_sequence+1,visible_layer-&gt;size);
-                input_prediction_activations_list.resize(
-                    ith_sample_in_sequence+1,visible_layer-&gt;size);
-                input_list.resize(ith_sample_in_sequence+1,visible_layer-&gt;size);
-                nll_list.resize(ith_sample_in_sequence+1);
-*/
+
          
-                clamp_visible_units(input);
 
+
+                if(isRegression)
+                    visible_layer-&gt;setExpectation(input);
+                else
+                    clamp_visible_units(input);
+                
+
                 if(ith_sample_in_sequence &gt; 0)
                 {
                    
                     input_list(ith_sample_in_sequence) &lt;&lt; previous_input;
+                    target_list(ith_sample_in_sequence) &lt;&lt; previous_target;
                     //h*_{t-1}
                     //////////////////////////////////
                     dynamic_connections-&gt;fprop(previous_hidden_layer, cond_bias);
                     hidden_layer-&gt;setAllBias(cond_bias); //**************************
 
-//                    if (visible_connections_option){
-//                        //v*_{t-1} VISIBLE DYNAMIC CONNECTION
-//                        //////////////////////////////////
-//                        visible_connections-&gt;fprop(previous_input, visi_cond_bias);
-//                        visible_layer-&gt;getAllBias(visi_cond_bias); //**************************
-//                    }
 
                     //up phase
                     connections-&gt;setAsDownInput( previous_input );
@@ -803,18 +644,19 @@
                         dynamic_connections_copy-&gt;fprop( hidden_layer-&gt;expectation ,hidden_layer-&gt;activation);//conection entre h_{t-1} et h_{t}
                     else
                         dynamic_connections-&gt;fprop( hidden_layer-&gt;expectation ,hidden_layer-&gt;activation);//conection entre h_{t-1} et h_{t}
-                    //dynamic_connections_copy-&gt;fprop( hidden_layer-&gt;expectation ,hidden_layer-&gt;activation);//conection entre h_{t-1} et h_{t}
+                    
                     hidden_layer-&gt;expectation_is_not_up_to_date();
                     hidden_layer-&gt;computeExpectation();//h_{t}
-                    ///////////
+                    
 
-                    previous_input &lt;&lt; visible_layer-&gt;expectation;//v_{t-1}
+                    
              
                 }
                 else
                 {
                     
                     input_list(ith_sample_in_sequence).fill(-1);
+                    target_list(ith_sample_in_sequence).fill(-1);
  
                     previous_hidden_layer.clear();//h_{t-1}
                     //previous_hidden_layer.fill(0.5);//**************************crap James
@@ -827,39 +669,35 @@
                         dynamic_connections-&gt;fprop(
                             previous_hidden_layer,hidden_layer-&gt;activation);//conection entre h_{t-1} et h_{t}
 
-                    //dynamic_connections_copy-&gt;fprop(previous_hidden_layer,hidden_layer-&gt;activation);//conection entre h_{t-1} et h_{t}
+                    
                     hidden_layer-&gt;expectation_is_not_up_to_date();
                     hidden_layer-&gt;computeExpectation();//h_{t}
 
                     previous_input.resize(visible_layer-&gt;size);
-                    previous_input &lt;&lt; visible_layer-&gt;expectation;
+                    previous_target.resize(target_layer-&gt;size);
  
 
-//                    if (visible_connections_option){
-//
-//                        /////////VISIBLE DYNAMIC CONNECTION
-//                        previous_visible_layer.clear();//v_{t-1}
-//                        visible_connections-&gt;fprop(previous_visible_layer,visible_layer-&gt;activation);//conection entre v_{t-1} et v_{t}
-//                
-//                        visible_layer-&gt;expectation_is_not_up_to_date();
-//                        visible_layer-&gt;computeExpectation();//v_{t}
-//                
-//                        visi_bias_tempo.resize(visible_layer-&gt;bias.length());
-//                        visi_bias_tempo &lt;&lt; visible_layer-&gt;bias;
-//                    }
             
                 }
 
-                // cout &lt;&lt; &quot;trililililililili&quot; &lt;&lt; endl;
+               
+                previous_input &lt;&lt; visible_layer-&gt;expectation;//v_{t-1}
+                previous_target &lt;&lt; target_layer-&gt;expectation;
+                
+               
 
-                connections_transpose-&gt;setAsDownInput( hidden_layer-&gt;expectation );
-                visible_layer-&gt;getAllActivations( connections_idem_t );
+                //connections_transpose-&gt;setAsDownInput( hidden_layer-&gt;expectation );
+                //visible_layer-&gt;getAllActivations( connections_idem_t );
 
-                //connections-&gt;setAsUpInput( hidden_layer-&gt;expectation );
-                //visible_layer-&gt;getAllActivations( connections_idem );
-
+                connections-&gt;setAsUpInput( hidden_layer-&gt;expectation );
+                visible_layer-&gt;getAllActivations( connections_idem );
                 visible_layer-&gt;computeExpectation();
- 
+
+                if(isRegression){
+                    partition(previous_input.subVec(14,taillePart), visible_layer-&gt;activation.subVec(14+taillePart,taillePart), visible_layer-&gt;activation.subVec(14+(taillePart*2),taillePart));
+                    partition(previous_input.subVec(14,taillePart), visible_layer-&gt;expectation.subVec(14+taillePart,taillePart), visible_layer-&gt;expectation.subVec(14+(taillePart*2),taillePart));
+                }
+
                 // Copies for backprop
                 hidden_list(ith_sample_in_sequence) &lt;&lt; previous_hidden_layer;
                 hidden_activations_list(ith_sample_in_sequence) 
@@ -872,17 +710,17 @@
                 input_prediction_activations_list(ith_sample_in_sequence) &lt;&lt; 
                     visible_layer-&gt;activation;
 
+                
  
-                nll_list[ith_sample_in_sequence] = 
-                    visible_layer-&gt;fpropNLL(previous_input) / inputsize() ;
+                //nll_list[ith_sample_in_sequence] = visible_layer-&gt;fpropNLL(previous_input); // / inputsize() ;
+                // real sum_mask = sums(mask);
+                nll_list[ith_sample_in_sequence] = target_layer-&gt;fpropNLL(previous_target); // / sum_mask;
+                
+
                 mean_cost += nll_list[ith_sample_in_sequence];
                 ith_sample_in_sequence++;
-                /////////VISIBLE DYNAMIC CONNECTION
-//                if (visible_connections_option){
-//                    visible_layer-&gt;getAllBias(visi_bias_tempo); 
-//                }
-
                
+               
             }
             if( pb )
                 pb-&gt;update( stage + 1 - init_stage);
@@ -905,7 +743,18 @@
     train_stats-&gt;finalize();
 }
 
+void DynamicallyLinkedRBMsModel::partition(TVec&lt;double&gt; part, TVec&lt;double&gt; periode, TVec&lt;double&gt; vel ) const
+{
+    for(int i = 0; i&lt;part-&gt;size();i++){
+        periode[i] = part[i]*periode[i];
+        vel[i] = part[i]*vel[i];
 
+    }
+
+
+
+}
+
 void DynamicallyLinkedRBMsModel::clamp_visible_units(const Vec&amp; input) const
 {
     int it = 0;
@@ -917,7 +766,6 @@
         // If input is a real ...
         if(ss &lt; 0) 
         {
-            //cout &lt;&lt; &quot;yoyoyoyoyo&quot; &lt;&lt; endl;
             input_expectation[it++] = input[i];
         }
         else // ... or a symbol
@@ -931,320 +779,46 @@
     visible_layer-&gt;setExpectation(input_expectation);
 }
 
-real DynamicallyLinkedRBMsModel::rbm_update()
-{
 
-    //###### Positive phase #####################
 
-    //up phase
-    connections-&gt;setAsDownInput( visible_layer-&gt;expectation );
-    
-    hidden_layer-&gt;getAllActivations( connections_idem );
-
-    hidden_layer-&gt;computeExpectation();
-
-
-    //save the stats for the positive phase
-    pos_down_values &lt;&lt; visible_layer-&gt;expectation;
-    pos_up_values &lt;&lt; hidden_layer-&gt;expectation;
-
-
-
-    //down phase
-    hidden_layer-&gt;generateSample();
-    
-    connections-&gt;setAsUpInput( hidden_layer-&gt;sample );
-
-    visible_layer-&gt;getAllActivations( connections_idem );
-
-    visible_layer-&gt;computeExpectation();
-    
-    visible_layer-&gt;generateSample();
-
-
-
-
-    //############ Negative phase  ##################
-
-    connections-&gt;setAsDownInput( visible_layer-&gt;sample );
-    
-    hidden_layer-&gt;getAllActivations( connections_idem );
-
-    hidden_layer-&gt;computeExpectation();
-
-    hidden_layer-&gt;generateSample();
-
-    //############ CD update #########################
-
-    visible_layer-&gt;update( 
-        pos_down_values, visible_layer-&gt;sample ); // ... of visible_layer bias ...
-
-    hidden_layer-&gt;update( 
-        pos_up_values, hidden_layer-&gt;expectation );// ... of hidden_layer bias ...
-    
-    connections-&gt;update( 
-        pos_down_values, pos_up_values, visible_layer-&gt;sample
-        , hidden_layer-&gt;expectation  ); // ... of connections between layers.
-    
-    // Compute reconstruction error
-    
-    connections-&gt;setAsUpInput( pos_up_values );
-
-    visible_layer-&gt;getAllActivations( connections_idem );
-
-    
-    visible_layer-&gt;computeExpectation();
-    
-    
-    return visible_layer-&gt;fpropNLL(pos_down_values);
-   
-}
-
-real DynamicallyLinkedRBMsModel::dynamic_connections_update()
-{
-    
-
-    // Obtain target hidden_layer h_t
-    connections-&gt;setAsDownInput(visible_layer-&gt;expectation);
-    hidden_layer-&gt;getAllActivations(connections_idem);
-    hidden_layer-&gt;computeExpectation();
-    hidden_layer_target &lt;&lt; hidden_layer-&gt;expectation;
-    hidden_layer-&gt;generateSample();
-    hidden_layer_sample &lt;&lt; hidden_layer-&gt;sample;
-    
-    // Use &quot;previous_hidden_layer&quot; field and &quot;dynamic_connections&quot; module 
-    // to set bias of &quot;hidden_layer&quot;
-    dynamic_connections-&gt;fprop(previous_hidden_layer,hidden_layer-&gt;activation);
-    hidden_layer-&gt;expectation_is_not_up_to_date();
-    hidden_layer-&gt;computeExpectation();
-    
-    
-    
-    // Ask &quot;hidden_layer&quot; for maximum likelyhood gradient on bias
-    real nll = hidden_layer-&gt;fpropNLL(hidden_layer_target);
-    hidden_layer-&gt;bpropNLL(hidden_layer_target, nll, bias_gradient);
-    
-    
-    dynamic_connections-&gt;bpropUpdate(previous_hidden_layer,
-                                     hidden_layer-&gt;activation,
-                                     input_gradient, bias_gradient);
-    
-    
-    
-    
-    
-    
-    
-    
-    //////////////////// VISIBLE DYNAMIC CONNECTION
-    /*  if (visible_connections_option){
-        visible_layer_sample &lt;&lt; visible_layer-&gt;expectation;
-        
-        // Use &quot;previous_visible_layer&quot; field and &quot;visible_connections&quot; module 
-        // to set bias of &quot;visible_layer&quot;
-        
-        visible_connections-&gt;fprop(previous_visible_layer,visible_layer-&gt;activation);
-        visible_layer-&gt;expectation_is_not_up_to_date();
-        visible_layer-&gt;computeExpectation();
-        
-        
-        
-        // Ask &quot;visible_layer&quot; for maximum likelyhood gradient on bias
-        real nll_visi = visible_layer-&gt;fpropNLL(visible_layer_sample);
-        visible_layer-&gt;bpropNLL(visible_layer_sample, nll_visi, visi_bias_gradient);
-        
-        
-        visible_connections-&gt;bpropUpdate(previous_visible_layer,
-                                         visible_layer-&gt;activation,
-                                         input_gradient, visi_bias_gradient);
-                                         }*/
-
-    return nll;
-}
-
-real DynamicallyLinkedRBMsModel::fine_tuning_update()
-{
-
- 
-
-     
-
-
-
-    cond_bias.resize(hidden_layer-&gt;size);
-   
-    dynamic_connections-&gt;fprop(previous_hidden_layer, cond_bias);
-
-
-  
-
-    hidden_layer-&gt;setAllBias(cond_bias);
-    
-
-
-
- //###### Positive phase #####################
-
-    //up phase
-    connections-&gt;setAsDownInput( visible_layer-&gt;expectation );
-    hidden_layer-&gt;getAllActivations( connections_idem );
-    hidden_layer-&gt;computeExpectation();
-
-
-    //save the stats for the positive phase
-    pos_down_values &lt;&lt; visible_layer-&gt;expectation;
-    pos_up_values &lt;&lt; hidden_layer-&gt;expectation;
-
-
-
-    //down phase
-    hidden_layer-&gt;generateSample();
-    hidden_layer_sample &lt;&lt; hidden_layer-&gt;sample;
-    connections-&gt;setAsUpInput( hidden_layer-&gt;sample );
-
-    visible_layer-&gt;getAllActivations( connections_idem );
-
-    visible_layer-&gt;computeExpectation();
-    
-    visible_layer-&gt;generateSample();
-
-
-
-
-    //############ Negative phase  ##################
-
-    connections-&gt;setAsDownInput( visible_layer-&gt;sample );
-    
-    hidden_layer-&gt;getAllActivations( connections_idem );
-
-    hidden_layer-&gt;computeExpectation();
-
-    hidden_layer-&gt;generateSample();
-
-    
-
-
-    //cout &lt;&lt;  hidden_layer-&gt;bias &lt;&lt; endl;
-     //############ CD update #########################
-
-    visible_layer-&gt;update( 
-        pos_down_values, visible_layer-&gt;sample ); // ... of visible_layer bias ...
-
-    
-
-
-// cout &lt;&lt; pos_up_values &lt;&lt; endl;
-// cout &lt;&lt; &quot;blabla&quot; &lt;&lt; endl;
-// cout &lt;&lt; hidden_layer-&gt;sample &lt;&lt; endl;
-    bias_gradient.resize( hidden_layer-&gt; size );
-
-
-
-
-
-
-    hidden_layer-&gt;bpropCD(pos_up_values, hidden_layer-&gt;expectation, bias_gradient);
-
-
-
-    dynamic_connections-&gt;bpropUpdate(previous_hidden_layer,
-                                     cond_bias,
-                                     input_gradient, bias_gradient);
-
-
-    // hidden_layer-&gt;update( 
-    //    pos_up_values, hidden_layer-&gt;sample );// ... of hidden_layer bias ...
-    
-    connections-&gt;update( 
-        pos_down_values, pos_up_values, visible_layer-&gt;sample
-        , hidden_layer-&gt;expectation ); // ... of connections between layers.
-
-    //cout &lt;&lt; ((PLearn::PP&lt;PLearn::GradNNetLayerModule&gt;)dynamic_connections)-&gt;weights &lt;&lt; endl;
-
-
-
-
-
-
-
-
-    // Use &quot;previous_hidden_layer&quot; field and &quot;dynamic_connections&quot; module 
-    // to set bias of &quot;hidden_layer&quot;
-
-    // Positive phase
-
-    // Negative phase
-
-    // CD update ...
-
-    // .. ask &quot;hidden_layer&quot; for CD gradient on bias and ...
-
-    // ... bpropUpdate through dynamic_connections 
-    // to update conditional bias (*)
-    
-    // ... of visible_layer bias ...
-
-    // ... of connections between layers.
-
-    // NB.: it is important not to update the hidden_layer's bias
-    //      using usual CD update. Conditional bias was updated
-    //      before at (*)
-
-
-
-
-
-    // Compute reconstruction error
-
-    //cond_bias.clear();
-    //dynamic_connections-&gt;fprop(previous_hidden_layer, cond_bias);
-    //hidden_layer-&gt;getAllBias(cond_bias);
-
-    
-
-
-
-    connections-&gt;setAsUpInput( pos_up_values );
-
-    visible_layer-&gt;getAllActivations( connections_idem );
-
-    visible_layer-&gt;computeExpectation();
-    
-    return visible_layer-&gt;fpropNLL(pos_down_values);
-
-    
-
-
-}
-
-
 void DynamicallyLinkedRBMsModel::recurrent_update()
 {
     // Notes: 
     //    - not all lists are useful (some *_activations_* are not)
-    int segment = hidden_list.length()/2;
-    int seg =0;
-    for(int k=hidden_list.length()-3; k&gt;=-segment; k-=segment){ 
-        seg = k;
-        if(seg &lt; 0)
-            seg = 0;
+    //int segment = hidden_list.length()/2;
+    //int seg =0;
+    //for(int k=hidden_list.length()-3; k&gt;=-segment; k-=segment){ 
+    //  seg = k;
+    //  if(seg &lt; 0)
+    //      seg = 0;
         //cout &lt;&lt; &quot;segment: &quot; &lt;&lt; seg &lt;&lt; endl;
         hidden_temporal_gradient.clear();
-        //for(int i=hidden_list.length()-2; i&gt;=0; i--){  
-        for(int i=hidden_list.length()-2; i&gt;=seg; i--){     
+        for(int i=hidden_list.length()-2; i&gt;=0; i--){  
+        // for(int i=hidden_list.length()-2; i&gt;=seg; i--){     
             
             //visible_layer-&gt;expectation &lt;&lt; input_prediction_list(i);
             //visible_layer-&gt;activation &lt;&lt; ?????;
             visible_layer-&gt;setExpectation(input_prediction_list(i));
             
+            //visible_layer-&gt;bpropNLL(input_list(i+1),nll_list[i],visi_bias_gradient, (taillePart*3)+14);
+
+            //      hidden_gradient.clear();
+            //HUGO: for( int tar=0; tar&lt;target_layers.length(); tar++)
+            //      {
+            //           target_layers[tar]-&gt;bpropNLL(targets_list[tar](i+1),nll_list(i,tar),target_bias_gradient[tar]);
+            //           target_bias_gradient[tar] *= target_layers_weights[tar];
+            //           target_layers[tar]-&gt;update(target_bias_gradient[tar]);
+            //           target_connections[tar]-&gt;bpropUpdate(hidden2_list(i),target_prediction_activations_list[tar](i),
+            //                                                hidden_gradient, target_bias_gradient[tar],true);
+            //      }
+
             visible_layer-&gt;bpropNLL(input_list(i+1),nll_list[i],visi_bias_gradient);
             
             visible_layer-&gt;update(visi_bias_gradient);
             
+            //visible_layer-&gt;bpropNLL(input_list(i+1),nll_list[i],visi_bias_gradient, (taillePart*3)+14);
             
-            connections_transpose-&gt;bpropUpdate(
-                hidden2_list(i),input_prediction_activations_list(i),
-                hidden_gradient, visi_bias_gradient);
+            connections_transpose-&gt;bpropUpdate(hidden2_list(i),input_prediction_activations_list(i),hidden_gradient, visi_bias_gradient);
             
             
             //hidden_layer-&gt;setExpectation(hidden_list(i+1));//////////////////////////////
@@ -1301,7 +875,7 @@
                 // Could learn initial value for h_{-1}
             }
         }
-    }
+    
 }
 
 
@@ -1358,7 +932,8 @@
        
 
 
-        if(testset-&gt;getString(i,0) == &quot;&lt;oov&gt;&quot;)
+        //if(testset-&gt;getString(i,0) == &quot;&lt;oov&gt;&quot;)
+        if(testset-&gt;get(i,0) == 8)
         {
             begin = 0;
             nb_oov++;
@@ -1369,11 +944,11 @@
 
 
 
-        clamp_visible_units(input);
+        //clamp_visible_units(input);
+        visible_layer-&gt;setExpectation(input);
 
 
 
-
         if(begin &gt; 0)
         {
 
@@ -1386,7 +961,7 @@
                 //v*_{t-1} VISIBLE DYNAMIC CONNECTION
                 //////////////////////////////////
                 visible_connections-&gt;fprop(previous_input, visi_cond_bias);
-                visible_layer-&gt;setAllBias(visi_cond_bias); //**************************
+                visible_layer-&gt;setAllBias(visi_cond_bias); 
                 }*/
 
             //up phase
@@ -1458,20 +1033,20 @@
 
 
      
-        connections_transpose-&gt;setAsDownInput( hidden_layer-&gt;expectation );
-        visible_layer-&gt;getAllActivations( connections_idem_t );
+        //connections_transpose-&gt;setAsDownInput( hidden_layer-&gt;expectation );
+        //visible_layer-&gt;getAllActivations( connections_idem_t );
 
-        //connections-&gt;setAsUpInput( hidden_layer-&gt;expectation );
-        //visible_layer-&gt;getAllActivations( connections_idem );
-
-
-       
+        connections-&gt;setAsUpInput( hidden_layer-&gt;expectation );
+        visible_layer-&gt;getAllActivations( connections_idem );
         visible_layer-&gt;computeExpectation();
 
-       
 
-        costs[0] = visible_layer-&gt;fpropNLL(previous_input) / inputsize() ;
+        partition(previous_input.subVec(14,taillePart), visible_layer-&gt;activation.subVec(14+taillePart,taillePart), visible_layer-&gt;activation.subVec(14+(taillePart*2),taillePart));
+        partition(previous_input.subVec(14,taillePart), visible_layer-&gt;expectation.subVec(14+taillePart,taillePart), visible_layer-&gt;expectation.subVec(14+(taillePart*2),taillePart));
 
+
+        //costs[0] = visible_layer-&gt;fpropNLL(previous_input,(taillePart*3)+14) ;
+        costs[0] = visible_layer-&gt;fpropNLL(previous_input) ;
        
         hidden_layer-&gt;setAllBias(bias_tempo); 
 
@@ -1514,6 +1089,137 @@
     return getTestCostNames();
 }
 
+void DynamicallyLinkedRBMsModel::gen()
+{
+    //PPath* the_filename = &quot;/home/stan/Documents/recherche_maitrise/DDBN_bosendorfer/data/generate/scoreGen.amat&quot;;
+    data = new AutoVMatrix();
+    data-&gt;filename = &quot;/home/stan/Documents/recherche_maitrise/DDBN_bosendorfer/data/generate/scoreGen.amat&quot;;
+    data-&gt;defineSizes(21,0,0);
+    //data-&gt;inputsize = 21;
+    //data-&gt;targetsize = 0;
+    //data-&gt;weightsize = 0;
+    data-&gt;build();
+
+    
+    int len = data-&gt;length();
+    Vec score;
+    Vec target;
+    real weight;
+    Vec bias_tempo;
+    Vec visi_bias_tempo;
+   
+   
+    
+    previous_hidden_layer.resize(hidden_layer-&gt;size);
+    connections_idem = connections;
+
+    for (int ith_sample = 0; ith_sample &lt; len ; ith_sample++ ){
+        
+        data-&gt;getExample(ith_sample, score, target, weight);
+        //score &lt;&lt; data(ith_sample);
+        input_prediction_list.resize(
+            ith_sample+1,visible_layer-&gt;size);
+        if(ith_sample &gt; 0)
+        {
+            
+            //input_list(ith_sample_in_sequence) &lt;&lt; previous_input;
+            //h*_{t-1}
+            //////////////////////////////////
+            dynamic_connections-&gt;fprop(previous_hidden_layer, cond_bias);
+            hidden_layer-&gt;setAllBias(cond_bias); //**************************
+            
+            
+            
+            //up phase
+            connections-&gt;setAsDownInput( input_prediction_list(ith_sample-1) );
+            hidden_layer-&gt;getAllActivations( connections_idem );
+            hidden_layer-&gt;computeExpectation();
+            //////////////////////////////////
+            
+            //previous_hidden_layer &lt;&lt; hidden_layer-&gt;expectation;//h_{t-2} au prochain tour//******************************
+            //previous_hidden_layer_activation &lt;&lt; hidden_layer-&gt;activation;
+            
+            
+            //h*_{t}
+            ////////////
+            if(dynamic_connections_copy)
+                dynamic_connections_copy-&gt;fprop( hidden_layer-&gt;expectation ,hidden_layer-&gt;activation);//conection entre h_{t-1} et h_{t}
+            else
+                dynamic_connections-&gt;fprop( hidden_layer-&gt;expectation ,hidden_layer-&gt;activation);//conection entre h_{t-1} et h_{t}
+            //dynamic_connections_copy-&gt;fprop( hidden_layer-&gt;expectation ,hidden_layer-&gt;activation);//conection entre h_{t-1} et h_{t}
+            hidden_layer-&gt;expectation_is_not_up_to_date();
+            hidden_layer-&gt;computeExpectation();//h_{t}
+            ///////////
+            
+            //previous_input &lt;&lt; visible_layer-&gt;expectation;//v_{t-1}
+            
+        }
+        else
+        {
+            
+            previous_hidden_layer.clear();//h_{t-1}
+            if(dynamic_connections_copy)
+                dynamic_connections_copy-&gt;fprop( previous_hidden_layer ,
+                                                 hidden_layer-&gt;activation);//conection entre h_{t-1} et h_{t}
+            else
+                dynamic_connections-&gt;fprop(previous_hidden_layer,
+                                           hidden_layer-&gt;activation);//conection entre h_{t-1} et h_{t}
+            
+            hidden_layer-&gt;expectation_is_not_up_to_date();
+            hidden_layer-&gt;computeExpectation();//h_{t}
+            //previous_input.resize(data-&gt;inputsize);
+            //previous_input &lt;&lt; data(ith_sample);
+            
+        }
+        
+        //connections_transpose-&gt;setAsDownInput( hidden_layer-&gt;expectation );
+        //visible_layer-&gt;getAllActivations( connections_idem_t );
+        
+        connections-&gt;setAsUpInput( hidden_layer-&gt;expectation );
+        visible_layer-&gt;getAllActivations( connections_idem );
+        
+        visible_layer-&gt;computeExpectation();
+        //visible_layer-&gt;generateSample();
+        partition(score.subVec(14,taillePart), visible_layer-&gt;activation.subVec(14+taillePart,taillePart), visible_layer-&gt;activation.subVec(14+(taillePart*2),taillePart));
+        partition(score.subVec(14,taillePart), visible_layer-&gt;expectation.subVec(14+taillePart,taillePart), visible_layer-&gt;expectation.subVec(14+(taillePart*2),taillePart));
+
+
+        visible_layer-&gt;activation.subVec(0,14+taillePart) &lt;&lt; score;
+        visible_layer-&gt;expectation.subVec(0,14+taillePart) &lt;&lt; score;
+
+        input_prediction_list(ith_sample) &lt;&lt; visible_layer-&gt;expectation;
+        
+    }
+    
+    //Vec tempo;
+    TVec&lt;real&gt; tempo;
+    tempo.resize(visible_layer-&gt;size);
+    ofstream myfile;
+    myfile.open (&quot;/home/stan/Documents/recherche_maitrise/DDBN_bosendorfer/data/generate/test.txt&quot;);
+    
+    for (int i = 0; i &lt; len ; i++ ){
+        tempo &lt;&lt; input_prediction_list(i);
+        
+        //cout &lt;&lt; tempo[2] &lt;&lt; endl;
+       
+        for (int j = 0; j &lt; tempo.length() ; j++ ){
+            
+            
+                
+                
+               myfile &lt;&lt; tempo[j] &lt;&lt; &quot; &quot;;
+               
+
+               
+           
+        }
+        myfile &lt;&lt; &quot;\n&quot;;
+    }
+     
+
+     myfile.close();
+
+}
 void DynamicallyLinkedRBMsModel::generate(int nbNotes)
 {
     
@@ -1593,10 +1299,10 @@
     TVec&lt;int&gt; tempo;
     tempo.resize(visible_layer-&gt;size);
     int theNote;
-    int nbNoteVisiLayer = input_prediction_list(1).length()/13;
+    //int nbNoteVisiLayer = input_prediction_list(1).length()/13;
     ofstream myfile;
     int theLayer;
-    myfile.open (&quot;/u/laulysta/recherche_maitrise/projet_GenerationDeMusique/data/generate/test.txt&quot;);
+    myfile.open (&quot;/home/stan/Documents/recherche_maitrise/DDBN_musicGeneration/data/generate/test.txt&quot;);
     
     for (int i = 0; i &lt; nbNotes ; i++ ){
         tempo &lt;&lt; input_prediction_list(i);

Modified: trunk/plearn_learners_experimental/DynamicallyLinkedRBMsModel.h
===================================================================
--- trunk/plearn_learners_experimental/DynamicallyLinkedRBMsModel.h	2008-05-14 13:12:51 UTC (rev 8996)
+++ trunk/plearn_learners_experimental/DynamicallyLinkedRBMsModel.h	2008-05-14 18:18:21 UTC (rev 8997)
@@ -46,8 +46,10 @@
 #include &lt;plearn_learners/online/OnlineLearningModule.h&gt;
 #include &lt;plearn_learners/online/RBMClassificationModule.h&gt;
 #include &lt;plearn_learners/online/RBMLayer.h&gt;
+#include &lt;plearn_learners/online/RBMMixedLayer.h&gt;
 #include &lt;plearn_learners/online/RBMConnection.h&gt;
 #include &lt;plearn_learners/online/RBMMatrixConnection.h&gt;
+#include &lt;plearn/vmat/AutoVMatrix.h&gt;
 #include &lt;plearn_learners/online/RBMMatrixTransposeConnection.h&gt;
 
 #include &lt;plearn_learners/online/GradNNetLayerModule.h&gt;
@@ -81,7 +83,13 @@
 
     //! Indication to untie weights in recurrent net
     bool untie_weights;
+    
+    //! Indicate the size of the partition
+    int taillePart;
 
+    //! Indicate if the model is used for regression
+    int isRegression;
+
     // TODO The weight decay used during the gradient descent 
     //real grad_weight_decay;
 
@@ -100,9 +108,15 @@
     //! Option for the visible dynamic connection 
     int visible_connections_option;
 
+    //! The target layer of the RBMs
+    PP&lt;RBMLayer&gt; target_layer;
+
     //! The visible layer of the RBMs
-    PP&lt;RBMLayer&gt; visible_layer;
+    TVec&lt;RBMLayer&gt; input_layer;
 
+     //! The visible layer of the RBMs
+    PP&lt;RBMLayer&gt; test_layer;
+
     //! The hidden layer of the RBMs
     PP&lt;RBMLayer&gt; hidden_layer;
 
@@ -130,12 +144,21 @@
 
     //#####  Public Learnt Options  ###########################################
 
-    //! Size of the visible layer
-    int visible_size;
+    //! Size of the input layer
+    int input_size;
 
+    //! Size of the target layer
+    int target_size;
+
+    //! Size of each target layers
+    TVec&lt;int&gt; target_layers_size;
+
     //! Number of symbols for each symbolic field of train_set
-    TVec&lt;int&gt; symbol_sizes;
-
+    TVec&lt;int&gt; input_symbol_sizes;
+    
+    //! Number of symbols for each symbolic field of train_set
+    Mat target_symbol_sizes;
+    
     //#####  Not Options  #####################################################
 
 
@@ -177,10 +200,16 @@
     //! Generate music in a folder
     void generate(int nbNotes);
 
+    //! Generate a part of the data in a folder
+    void gen();
+
     //! Returns the names of the objective costs that the train method computes
     //! and  for which it updates the VecStatsCollector train_stats.
     virtual TVec&lt;std::string&gt; getTrainCostNames() const;
 
+    //! Use the partition
+    void partition(TVec&lt;double&gt; part, TVec&lt;double&gt; periode, TVec&lt;double&gt; vel ) const;
+    
     //! Clamps the visible units based on an input vector
     void clamp_visible_units(const Vec&amp; input) const;
 
@@ -243,6 +272,10 @@
 protected:
     //#####  Not Options  #####################################################
 
+
+    //! Store external data;
+    AutoVMatrix*  data;
+   
     //! Stores conditional bias
     mutable Vec cond_bias;
 
@@ -271,8 +304,11 @@
     //! Stores hidden gradient of dynamic connections coming from time t+1
     mutable Vec hidden_temporal_gradient;
     
-    //! Stores previous hidden layer value
+    //! Stores previous input layer value
     mutable Vec previous_input;
+
+    //! Stores previous target layer value
+    mutable Vec previous_target;
     
     //! Stores previous hidden layer value
     mutable Vec previous_hidden_layer;
@@ -315,6 +351,9 @@
     //! List of inputs values
     Mat input_list;
 
+    //! List of inputs values
+    Mat target_list;
+
     //! List of the nll of the input samples in a sequence
     Vec nll_list;
 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002444.html">[Plearn-commits] r8996 - trunk/plearn_learners_experimental
</A></li>
	<LI>Next message: <A HREF="002446.html">[Plearn-commits] r8998 - trunk/plearn/vmat
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2445">[ date ]</a>
              <a href="thread.html#2445">[ thread ]</a>
              <a href="subject.html#2445">[ subject ]</a>
              <a href="author.html#2445">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/plearn-commits">More information about the Plearn-commits
mailing list</a><br>
</body></html>
