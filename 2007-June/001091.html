<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Plearn-commits] r7643 - in branches/cgi-desjardin: commands	plearn_learners/second_iteration
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/plearn-commits/2007-June/index.html" >
   <LINK REL="made" HREF="mailto:plearn-commits%40lists.berlios.de?Subject=Re%3A%20%5BPlearn-commits%5D%20r7643%20-%20in%20branches/cgi-desjardin%3A%20commands%0A%09plearn_learners/second_iteration&In-Reply-To=%3C200706261651.l5QGpE6s023337%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001090.html">
   <LINK REL="Next"  HREF="001092.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Plearn-commits] r7643 - in branches/cgi-desjardin: commands	plearn_learners/second_iteration</H1>
    <B>nouiz at BerliOS</B> 
    <A HREF="mailto:plearn-commits%40lists.berlios.de?Subject=Re%3A%20%5BPlearn-commits%5D%20r7643%20-%20in%20branches/cgi-desjardin%3A%20commands%0A%09plearn_learners/second_iteration&In-Reply-To=%3C200706261651.l5QGpE6s023337%40sheep.berlios.de%3E"
       TITLE="[Plearn-commits] r7643 - in branches/cgi-desjardin: commands	plearn_learners/second_iteration">nouiz at mail.berlios.de
       </A><BR>
    <I>Tue Jun 26 18:51:14 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="001090.html">[Plearn-commits] r7642 -	branches/cgi-desjardin/plearn_learners/second_iteration
</A></li>
        <LI>Next message: <A HREF="001092.html">[Plearn-commits] r7644 -	branches/cgi-desjardin/plearn_learners/second_iteration
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1091">[ date ]</a>
              <a href="thread.html#1091">[ thread ]</a>
              <a href="subject.html#1091">[ subject ]</a>
              <a href="author.html#1091">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: nouiz
Date: 2007-06-26 18:51:13 +0200 (Tue, 26 Jun 2007)
New Revision: 7643

Removed:
   branches/cgi-desjardin/plearn_learners/second_iteration/BallTreeNearestNeighbors.cc
   branches/cgi-desjardin/plearn_learners/second_iteration/BallTreeNearestNeighbors.h
   branches/cgi-desjardin/plearn_learners/second_iteration/BinaryBallTree.cc
   branches/cgi-desjardin/plearn_learners/second_iteration/BinaryBallTree.h
Modified:
   branches/cgi-desjardin/commands/plearn_gg_inc.h
   branches/cgi-desjardin/commands/plearn_inc_gg.h
Log:
Removec file that are already in PLearn


Modified: branches/cgi-desjardin/commands/plearn_gg_inc.h
===================================================================
--- branches/cgi-desjardin/commands/plearn_gg_inc.h	2007-06-26 16:48:51 UTC (rev 7642)
+++ branches/cgi-desjardin/commands/plearn_gg_inc.h	2007-06-26 16:51:13 UTC (rev 7643)
@@ -66,7 +66,7 @@
 #include &lt;plearn_learners/second_iteration/ConditionalMeanImputationVMatrix.h&gt;
 #include &lt;plearn_learners/second_iteration/CovariancePreservationImputationVMatrix.h&gt;
 #include &lt;plearn_learners/second_iteration/NeighborhoodImputationVMatrix.h&gt;
-#include &lt;plearn_learners/second_iteration/BallTreeNearestNeighbors.h&gt;
+//#include &lt;plearn_learners/second_iteration/BallTreeNearestNeighbors.h&gt;
 #include &lt;plearn_learners/second_iteration/WeightedDistance.h&gt;
 #include &lt;plearn_learners/regressors/RegressionTree.h&gt;
 #include &lt;plearn/vmat/VariableDeletionVMatrix.h&gt;

Modified: branches/cgi-desjardin/commands/plearn_inc_gg.h
===================================================================
--- branches/cgi-desjardin/commands/plearn_inc_gg.h	2007-06-26 16:48:51 UTC (rev 7642)
+++ branches/cgi-desjardin/commands/plearn_inc_gg.h	2007-06-26 16:51:13 UTC (rev 7643)
@@ -185,7 +185,7 @@
 #include &lt;plearn_learners/distributions/UniformDistribution.h&gt;
 
 // Nearest-Neighbors
-//gg#include &lt;plearn_learners/nearest_neighbors/BallTreeNearestNeighbors.h&gt;
+#include &lt;plearn_learners/nearest_neighbors/BallTreeNearestNeighbors.h&gt;
 //gg#include &lt;plearn_learners/nearest_neighbors/ExhaustiveNearestNeighbors.h&gt;
 //gg#include &lt;plearn_learners/nearest_neighbors/GenericNearestNeighbors.h&gt;
 

Deleted: branches/cgi-desjardin/plearn_learners/second_iteration/BallTreeNearestNeighbors.cc
===================================================================
--- branches/cgi-desjardin/plearn_learners/second_iteration/BallTreeNearestNeighbors.cc	2007-06-26 16:48:51 UTC (rev 7642)
+++ branches/cgi-desjardin/plearn_learners/second_iteration/BallTreeNearestNeighbors.cc	2007-06-26 16:51:13 UTC (rev 7643)
@@ -1,797 +0,0 @@
-// -*- C++ -*-
-
-// BallTreeNearestNeighbors.cc
-//
-// Copyright (C) 2004 Pascal Lamblin &amp; Marius Muja
-// 
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are met:
-// 
-//  1. Redistributions of source code must retain the above copyright
-//     notice, this list of conditions and the following disclaimer.
-// 
-//  2. Redistributions in binary form must reproduce the above copyright
-//     notice, this list of conditions and the following disclaimer in the
-//     documentation and/or other materials provided with the distribution.
-// 
-//  3. The name of the authors may not be used to endorse or promote
-//     products derived from this software without specific prior written
-//     permission.
-// 
-// THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
-// NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-// 
-// This file is part of the PLearn library. For more information on the PLearn
-// library, go to the PLearn Web site at www.plearn.org
-
-/* *******************************************************      
- * $Id: BallTreeNearestNeighbors.cc 4911 2006-02-09 22:02:57Z lamblin $ 
- ******************************************************* */
-
-// Authors: Pascal Lamblin &amp; Marius Muja
-
-/*! \file BallTreeNearestNeighbors.cc */
-
-#include &quot;BallTreeNearestNeighbors.h&quot;
-#include &lt;plearn/base/lexical_cast.h&gt;
-
-namespace PLearn {
-using namespace std;
-
-BallTreeNearestNeighbors::BallTreeNearestNeighbors() 
-    : rmin( 1 ),
-      train_method( &quot;anchor&quot; )
-{
-    num_neighbors = 1;
-    expdir = &quot;&quot;;
-    stage = 0;
-    nstages = -1;
-    report_progress = 0;
-}
-
-BallTreeNearestNeighbors::BallTreeNearestNeighbors( const VMat&amp; tr_set, const BinBallTree&amp; b_tree )
-    : rmin( 1 ),
-      train_method( &quot;anchor&quot; )
-{
-    num_neighbors = 1;
-    expdir = &quot;&quot;;
-    stage = 1;
-    nstages = 1;
-    report_progress = 0;
-
-    setTrainingSet( tr_set );
-    ball_tree = b_tree;
-}
-
-PLEARN_IMPLEMENT_OBJECT( BallTreeNearestNeighbors, 
-                         &quot;Organizes hierarchically a set of points to perform efficient  KNN search&quot;, 
-                         &quot;This learner builds a Ball Tree, a hierarchized structure\n&quot;
-                         &quot;allowing to perform efficient KNN search.\n&quot;
-                         &quot;Output is formatted as in GenericNearestNeighbors.\n&quot;
-                         &quot;The square distance to this point can be computed as the error.\n&quot; );
-
-void BallTreeNearestNeighbors::declareOptions( OptionList&amp; ol )
-{
-    // build options
-    declareOption( ol, &quot;point_indices&quot;, &amp;BallTreeNearestNeighbors::point_indices, 
-                   OptionBase::buildoption,
-                   &quot;Indices of the points we will consider&quot; );
-
-    declareOption( ol, &quot;rmin&quot;, &amp;BallTreeNearestNeighbors::rmin, OptionBase::buildoption,
-                   &quot;Max number of points in a leaf node of the tree&quot; );
-
-    declareOption( ol, &quot;train_method&quot;, &amp;BallTreeNearestNeighbors::train_method, 
-                   OptionBase::buildoption,
-                   &quot;Method used to build the tree. Just one is supported:\n&quot;
-                   &quot;  \&quot;anchor\&quot; (middle-out building based on Anchor\'s hierarchy\n&quot;
-        );
-
-    declareOption( ol, &quot;anchor_set&quot;, &amp;BallTreeNearestNeighbors::anchor_set, 
-                   OptionBase::learntoption, 
-                   &quot;Set of anchors, hierarchizing the set of points&quot; );
-
-    declareOption( ol, &quot;pivot_indices&quot;, &amp;BallTreeNearestNeighbors::pivot_indices, 
-                   OptionBase::learntoption, &quot;Indices of the anchors' centers&quot; );
-
-    // saved options
-    declareOption( ol, &quot;train_set&quot;, &amp;BallTreeNearestNeighbors::train_set, 
-                   OptionBase::buildoption,
-                   &quot;Indexed set of points we will be working with&quot; );
-
-    declareOption( ol, &quot;nb_train_points&quot;, &amp;BallTreeNearestNeighbors::nb_train_points, 
-                   OptionBase::learntoption, &quot;Number of points in train_set&quot; );
-
-    declareOption( ol, &quot;nb_points&quot;, &amp;BallTreeNearestNeighbors::nb_points, 
-                   OptionBase::learntoption, &quot;Number of points in point_indices&quot; );
-
-    declareOption( ol, &quot;ball_tree&quot;, &amp;BallTreeNearestNeighbors::ball_tree, 
-                   OptionBase::learntoption, &quot;Built ball-tree&quot; );
-
-
-    // Now call the parent class' declareOptions
-    inherited::declareOptions( ol );
-}
-
-void BallTreeNearestNeighbors::build_()
-{
-    if (train_set) {
-        // initialize nb_train_points
-        nb_train_points = train_set.length();
-        
-        // if point_indices isn't specified, we take all the points in train_set
-        if( !point_indices )
-            point_indices = TVec&lt;int&gt;( 0, nb_train_points-1, 1 );
-
-        // initialize nb_points
-        nb_points = point_indices.size();
-    }
-}
-
-
-void BallTreeNearestNeighbors::build()
-{
-    inherited::build();
-    build_();
-}
-
-
-void BallTreeNearestNeighbors::makeDeepCopyFromShallowCopy(map&lt;const void*, void*&gt;&amp; copies)
-{
-    inherited::makeDeepCopyFromShallowCopy(copies);
-
-    deepCopyField( ball_tree, copies );
-    deepCopyField( point_indices, copies );
-    deepCopyField( anchor_set, copies );
-    deepCopyField( pivot_indices, copies );
-}
-
-
-void BallTreeNearestNeighbors::forget()
-{
-    //! (Re-)initialize the PLearner in its fresh state (that state may depend on the 'seed' option)
-    //! And sets 'stage' back to 0   (this is the stage of a fresh learner!)
-
-    anchor_set.resize( 0 );
-    pivot_indices.resize( 0 );
-    ball_tree = new BinaryBallTree;
-    stage = 0;
-    build();
-}
-
-
-
-
-void BallTreeNearestNeighbors::train()
-{
-    // The role of the train method is to bring the learner up to stage==nstages,
-    // updating train_stats with training costs measured on-line in the process.
-
-    if( train_method == &quot;anchor&quot; )
-    {
-        anchorTrain();
-    }
-    else
-        PLERROR( &quot;train_method \&quot;%s\&quot; not implemented&quot;, train_method.c_str() );
-}
-
-
-void BallTreeNearestNeighbors::anchorTrain()
-{
-    /*  nstages and stage conventions, for &quot;anchor&quot; train method:
-     *
-     *  nstages == -1
-     *    We will construct ball_tree recursively,
-     *    until, for all leaf, nb_points &lt;= rmin,
-     *    no matter how many iterations it will take.
-     *
-     *  nstages == 0
-     *    We want the PLearner il its fresh, blank state.
-     *
-     *  nstages == 1
-     *    We want ball_tree to be a unique leaf node,
-     *    containing all the point indices, with no children.
-     *
-     *  nstages &gt; 1
-     *    We want to build ball_tree recursively,
-     *    but limiting the levels of recursion.
-     *    This means we will decrement this number at each recursive call,
-     *    the recursion will stop when nstages == 1 or nb_points &lt;= rmin.
-     *
-     *  stage == 0
-     *    The learner is it its fresh, blank state.
-     *
-     *  stage == 1
-     *    The learner has one anchor, that's all.
-     *
-     *  Other values of stage might be used one day or anoter...
-     */
-
-    if( stage == 0 &amp;&amp; nstages !=0 )
-    {
-        // That means we weren't provided with any anchor nor node parameter,
-        // or that they were just bullsh!t
-
-        // So, we build a single anchor
-        pivot_indices.resize( 1 );
-        pivot_indices[ 0 ] = 0;
-        Vec pivot = train_set.getSubRow( 0, inputsize() );
-
-        distance_kernel-&gt;setDataForKernelMatrix( train_set );
-        distance_kernel-&gt;build();
-        Vec distances_from_pivot( nb_train_points );
-        distance_kernel-&gt;evaluate_all_i_x( pivot, distances_from_pivot );
-
-        anchor_set.resize( 1 );
-        Mat* p_anchor = &amp;anchor_set[ 0 ];
-        p_anchor-&gt;resize( nb_points, 2 );
-        p_anchor-&gt;column( 0 ) &lt;&lt; Vec( 0, nb_points-1, 1 );
-        p_anchor-&gt;column( 1 ) &lt;&lt; distances_from_pivot;
-        sortRows( *p_anchor, TVec&lt;int&gt;( 1, 1 ), false );
-
-        // then, we build the corresponding tree
-        ball_tree = leafFromAnchor( 0 );
-
-        ++stage;
-    }
-
-    if( nstages == 0 )
-    {
-        // we want a fresh, blank learner
-        forget();
-    }
-    else if( nstages == 1 )
-    {
-        // We have an anchor, and we want a leaf node
-        ball_tree = leafFromAnchor( 0 );
-    }
-    else
-    {
-        // nstages to be used on children learners
-        int new_nstages = nstages&lt;0 ? -1 : nstages-1;
-
-        // First create sqrt( R )-1 anchors, from the initial anchor_set
-        int nb_anchors = (int) sqrt( (float) nb_points ) + 1 ;
-        nb_anchors = min( nb_anchors, nb_points );
-
-        createAnchors( nb_anchors-1 ); // because we already have one
-
-        // Convert them into leaf nodes
-        TVec&lt; BinBallTree &gt; leaf_set = TVec&lt;BinBallTree&gt;( nb_anchors );
-        for ( int i=0 ; i&lt;nb_anchors ; i++ )
-        {
-            leaf_set[ i ] = leafFromAnchor( i );
-        }
-
-        // Then, group them to form the ball_tree
-        // keep an index of the leaves
-        ball_tree = treeFromLeaves( leaf_set );
-
-        // Now, recurse...
-        for( int i=0 ; i&lt;leaf_set.size() ; i++ )
-        {
-            int rec_nb_points = anchor_set[ i ].length();
-
-            // if the leaf is too small, don't do anything
-            if( rec_nb_points &gt; rmin )
-            {
-                // child learner
-                PP&lt;BallTreeNearestNeighbors&gt; p_rec_learner = new BallTreeNearestNeighbors();
-
-                // initializes child's nstages (see explanation above)
-                stringstream out;
-                out &lt;&lt; new_nstages;
-                p_rec_learner-&gt;setOption( &quot;nstages&quot; , out.str() );
-
-                // keep the same training set: it give us all the point coordinates !
-                // but we don't want to call forget() after that
-                p_rec_learner-&gt;setTrainingSet( train_set, false );
-
-                // however, we only work on the points contained by current leaf
-                p_rec_learner-&gt;anchor_set.resize( 1 );
-                p_rec_learner-&gt;anchor_set[ 0 ].resize( rec_nb_points, 2 );
-                p_rec_learner-&gt;anchor_set[ 0 ] &lt;&lt; anchor_set[ i ];
-
-                p_rec_learner-&gt;pivot_indices.resize( 1 );
-                p_rec_learner-&gt;pivot_indices[ 0 ] = pivot_indices[ i ];
-
-                p_rec_learner-&gt;point_indices.resize( rec_nb_points );
-                p_rec_learner-&gt;point_indices &lt;&lt; 
-                    p_rec_learner-&gt;anchor_set[ 0 ].column( 0 );
-
-                p_rec_learner-&gt;stage = 1; 
-                // faudra peut-etre faire &#231;a plus subtilement
-
-                p_rec_learner-&gt;rmin = rmin;
-                p_rec_learner-&gt;train_method = train_method;
-                p_rec_learner-&gt;build();
-                p_rec_learner-&gt;train();
-
-                // once the child learner is trained, we can get the sub-tree,
-                // and link it correctly
-                BinBallTree subtree = p_rec_learner-&gt;getBallTree();
-                leaf_set[ i ]-&gt;pivot = subtree-&gt;pivot;
-                leaf_set[ i ]-&gt;radius = subtree-&gt;radius;
-                leaf_set[ i ]-&gt;point_set.resize( subtree-&gt;point_set.size() );
-                leaf_set[ i ]-&gt;point_set &lt;&lt; subtree-&gt;point_set;
-                leaf_set[ i ]-&gt;setFirstChild( subtree-&gt;getFirstChild() );
-                leaf_set[ i ]-&gt;setSecondChild( subtree-&gt;getSecondChild() );
-
-            }
-        }
-    }
-}
-
-
-void BallTreeNearestNeighbors::createAnchors( int nb_anchors )
-{
-    // This method creates nb_anchors new anchors, and adds them to anchor_set
-
-    // Make room
-    int anchor_set_size = anchor_set.size();
-    anchor_set.resize( anchor_set_size, nb_anchors );
-
-    for( int i=0 ; i&lt;nb_anchors ; i++ )
-    {
-        Mat new_anchor = Mat( 1, 2 );
-        int new_pivot_index;
-
-        // Search for the largest ball.
-        // pivot of the new anchor will be the point of this ball
-        // that is the furthest from the pivot.
-        int largest_index = 0;
-        real largest_radius = 0;
-        for( int j=0 ; j&lt;anchor_set_size ; j++ )
-        {
-            // points are sorted in decreasing order of distance, 
-            // so anchor_set[ j ]( 0, 1 ) is the furthest point from 
-            // pivot_indices[ j ]
-            real current_radius = anchor_set[ j ]( 0, 1 );
-            if( current_radius &gt; largest_radius )
-            {
-                largest_radius = current_radius;
-                largest_index = j;
-            }
-        }
-
-        Mat* p_largest_anchor = &amp;anchor_set[ largest_index ];
-        new_pivot_index = (int) (*p_largest_anchor)( 0, 0 );
-
-        // assign the point to its new anchor
-        new_anchor( 0, 0 ) = new_pivot_index;
-        new_anchor( 0, 1 ) = 0;
-        Vec new_pivot = train_set.getSubRow( new_pivot_index, inputsize() );
-
-        int largest_anchor_length = p_largest_anchor-&gt;length();
-
-        // Verify that largest_anchor owns at least 2 points
-        if( largest_anchor_length &lt;= 1 )
-        {
-            PLERROR(&quot;In BallTreeNearestNeighbors::createAnchors, more anchors asked than points&quot;);
-        }
-
-        // delete this point from its original anchor
-        *p_largest_anchor = p_largest_anchor-&gt;
-            subMatRows( 1, largest_anchor_length-1 );
-
-        // now, try to steal points from all the existing anchors
-        for( int j=0 ; j&lt;anchor_set_size ; j++ )
-        {
-            Mat* p_anchor = &amp;anchor_set[ j ];
-            int nb_points = p_anchor-&gt;length();
-            int pivot_index = pivot_indices[ j ];
-            Vec pivot = train_set.getSubRow( pivot_index, inputsize() );
-            real pivot_pow_dist = powdistance( new_pivot, pivot, 2 );
-
-            // loop on the anchor's points
-            for( int k=0 ; k&lt;nb_points ; k++ )
-            {
-                int point_index = (int) (*p_anchor)( k, 0 );
-                real point_pow_dist = (*p_anchor)( k, 1 );
-
-                // if this inequality is verified,
-                // then we're sure that all the points closer to the pivot 
-                // belong to the pivot, and we don't need to check
-                if( 4*point_pow_dist &lt; pivot_pow_dist )
-                {
-                    break;
-                }
-
-                Vec point = train_set.getSubRow( point_index, inputsize() );
-                real new_pow_dist = powdistance( new_pivot, point, 2 );
-
-                // if the point is closer to the new pivot, then steal it
-                if( new_pow_dist &lt; point_pow_dist )
-                {
-                    Vec new_row( 2 );
-                    new_row[ 0 ] = point_index;
-                    new_row[ 1 ] = new_pow_dist;
-                    new_anchor.appendRow( new_row );
-
-                    *p_anchor = removeRow( *p_anchor, k );
-                    // bleaah, this is ugly !
-                    --k;
-                    --nb_points;
-                }
-            }
-        }
-
-        // sort the points by decreasing distance
-        sortRows( new_anchor, TVec&lt;int&gt;( 1, 1 ), false );
-
-        // append the new anchor to the anchor_set (and same for pivot)
-        anchor_set.append( new_anchor );
-        pivot_indices.append( new_pivot_index );
-        ++anchor_set_size;
-    }
-}
-
-BinBallTree BallTreeNearestNeighbors::leafFromAnchor( int anchor_index )
-{
-    BinBallTree leaf = new BinaryBallTree();
-
-    int pivot_index = pivot_indices[ anchor_index ];
-    leaf-&gt;pivot = train_set.getSubRow( pivot_index, inputsize() );
-
-    leaf-&gt;radius = anchor_set[ anchor_index ]( 0, 1 );
-
-    int nb_leaf_points = anchor_set[ anchor_index ].length();
-    leaf-&gt;point_set.resize( nb_leaf_points );
-    leaf-&gt;point_set &lt;&lt; anchor_set[ anchor_index ].column( 0 );
-
-    return leaf;
-}
-
-
-BinBallTree BallTreeNearestNeighbors::treeFromLeaves( const TVec&lt;BinBallTree&gt;&amp; leaves )
-{
-    int nb_nodes = leaves.size();
-    TVec&lt;BinBallTree&gt; nodes = TVec&lt;BinBallTree&gt;( nb_nodes );
-    nodes &lt;&lt; leaves;
-
-    // if there is no leaf
-    if( nb_nodes &lt; 1 )
-    {
-        PLERROR( &quot;In BallTreeNearestNeighbors::treeFromLeaves(): no leaf existing&quot; );
-    }
-
-    while( nb_nodes &gt; 1 )
-    {
-        int min_i = 0;
-        int min_j = 0;
-        Vec min_center;
-        real min_radius = -1;
-
-        // we get the most &quot;compatible&quot; pair of nodes :
-        // the ball containing them both is the smallest
-        for( int i=0 ; i&lt;nb_nodes ; i++ )
-        {
-            Vec center_i = nodes[ i ]-&gt;pivot;
-            real radius_i = nodes[ i ]-&gt;radius;
-
-            // to scan all pairs only once, and avoid i==j
-            for( int j=0 ; j&lt;i ; j++ )
-            {
-                Vec center_j = nodes[ j ]-&gt;pivot;
-                real radius_j = nodes[ j ]-&gt;radius;
-
-                Vec t_center;
-                real t_radius;
-                smallestContainer( center_i, radius_i, center_j, radius_j, 
-                                   t_center, t_radius );
-
-                if( t_radius &lt; min_radius || min_radius &lt; 0 )
-                {
-                    min_i = i;
-                    min_j = j ;
-                    min_radius = t_radius;
-                    min_center = t_center;
-                }
-            }
-        }
-
-#ifdef DEBUG_CHECK_NAN
-        if (min_center.hasMissing())
-            PLERROR(&quot;In BallTreeNearestNeighbors::treeFromLeaves: min_center is NaN&quot;);
-#endif
-        
-        // Group these two nodes into a parent_node.
-        // TODO: something more sensible for the radius and center...
-        BinBallTree parent_node = new BinaryBallTree();
-        parent_node-&gt;pivot = min_center;
-        parent_node-&gt;radius = min_radius;
-        parent_node-&gt;setFirstChild( nodes[ min_i ] );
-        parent_node-&gt;setSecondChild( nodes[ min_j ] );
-
-        nodes[ min_j ] = parent_node;
-        nodes.remove( min_i );
-
-        --nb_nodes;
-    }
-
-    // then, we have only one anchor
-    BinBallTree root = nodes[ 0 ];
-    return root;
-}
-
-
-BinBallTree BallTreeNearestNeighbors::getBallTree()
-{
-    return ball_tree;
-}
-
-
-void BallTreeNearestNeighbors::computeOutputAndCosts(
-    const Vec&amp; input, const Vec&amp; target, Vec&amp; output, Vec&amp; costs ) const
-{
-    int nout = outputsize();
-    output.resize( nout );
-    costs.resize( num_neighbors );
-
-    // we launch a k-nearest-neighbors query on the root node (ball_tree)
-    priority_queue&lt; pair&lt;real,int&gt; &gt; q;
-    FindBallKNN( q, input, num_neighbors );
-
-    // dequeue the found nearest neighbors, beginning by the farthest away
-    int n_found = q.size();
-    TVec&lt;int&gt; neighbors( n_found );
-    for( int i=n_found-1 ; i&gt;=0 ; i-- )
-    {
-        const pair&lt;real,int&gt;&amp; cur_top = q.top();
-        costs[i] = cur_top.first;
-        neighbors[i] = cur_top.second;
-        q.pop();
-    }
-
-    // fill costs with missing values
-    for( int i= n_found ; i&lt;num_neighbors ; i++ )
-        costs[i] = MISSING_VALUE;
-
-    constructOutputVector( neighbors, output );
-}
-
-void BallTreeNearestNeighbors::computeOutput(
-    const Vec&amp; input, Vec&amp; output ) const
-{
-    // Compute the output from the input.
-    // int nout = outputsize();
-    // output.resize(nout);
-
-    int nout = outputsize();
-    output.resize( nout );
-
-    // we launch a k-nearest-neighbors query on the root node (ball_tree)
-    priority_queue&lt; pair&lt;real,int&gt; &gt; q;
-    FindBallKNN( q, input, num_neighbors );
-
-    // dequeue the found nearest neighbors, beginning by the farthest away
-    int n_found = q.size();
-    TVec&lt;int&gt; neighbors( n_found );
-    for( int i=n_found-1 ; i&gt;=0 ; i-- )
-    {
-        const pair&lt;real,int&gt;&amp; cur_top = q.top();
-        neighbors[i] = cur_top.second;
-        q.pop();
-    }
-
-    constructOutputVector( neighbors, output );
-
-}
-
-
-void BallTreeNearestNeighbors::computeCostsFromOutputs(
-    const Vec&amp; input, const Vec&amp; output, const Vec&amp; target, Vec&amp; costs ) const
-{
-    // Compute the costs from *already* computed output.
-    costs.resize( num_neighbors );
-
-    int inputsize = train_set-&gt;inputsize();
-    int targetsize = train_set-&gt;targetsize();
-    int weightsize = train_set-&gt;weightsize();
-
-    Mat out( num_neighbors, inputsize );
-
-    if( copy_input )
-    {
-        for( int i=0 ; i&lt;num_neighbors ; i++ )
-            out( i ) &lt;&lt; output.subVec( i*outputsize(), inputsize );
-    }
-    else if( copy_index )
-    {
-        int offset = 0;
-
-        if( copy_target )
-            offset += targetsize;
-
-        if( copy_weight )
-            offset += weightsize;
-
-        for( int i=0 ; i&lt;num_neighbors ; i++ )
-            out( i ) &lt;&lt; train_set( (int) output[ i*outputsize() + offset ] );
-    }
-    else
-    {
-        PLERROR( &quot;computeCostsFromOutput:\n&quot;
-                 &quot;neither indices nor coordinates of output computed\n&quot; );
-    }
-
-    for( int i=0 ; i&lt;num_neighbors ; i++ )
-        costs[ i ] = powdistance( input, out( i ) );
-}
-
-TVec&lt;string&gt; BallTreeNearestNeighbors::getTestCostNames() const
-{
-    return TVec&lt;string&gt;( num_neighbors, &quot;squared_distance&quot; );
-}
-
-TVec&lt;string&gt; BallTreeNearestNeighbors::getTrainCostNames() const
-{
-    return TVec&lt;string&gt;();
-}
-
-bool BallTreeNearestNeighbors::intersect(
-    const Vec&amp; center1, const real&amp; powrad1,
-    const Vec&amp; center2, const real&amp; powrad2 )
-{
-    real radius1 = sqrt( powrad1 );
-    real radius2 = sqrt( powrad2 );
-
-    real pow_dist = powdistance( center1, center2, 2 );
-    real rad_sum = radius1 + radius2;
-    bool result = ( pow_dist &lt;= ( rad_sum * rad_sum ) );
-    return result;
-}
-
-bool BallTreeNearestNeighbors::contain(
-    const Vec&amp; center1, const real&amp; powrad1,
-    const Vec&amp; center2, const real&amp; powrad2 )
-{
-    real radius1 = sqrt( powrad1 );
-    real radius2 = sqrt( powrad2 );
-    real rad_dif = radius1 - radius2;
-
-    if( rad_dif &gt;= 0 )
-    {
-        real pow_dist = powdistance( center1, center2, 2 );
-        bool result = ( pow_dist &lt;= ( rad_dif * rad_dif ) );
-        return result;
-    }
-    else
-    {
-        return false;
-    }
-}
-
-void BallTreeNearestNeighbors::smallestContainer(
-    const Vec&amp; center1, const real&amp; powrad1,
-    const Vec&amp; center2, const real&amp; powrad2,
-    Vec&amp; t_center, real&amp; t_powrad )
-{
-    if( center1 == center2 )
-    {
-        t_center = center1;
-        t_powrad = max( powrad1, powrad2 );
-    }
-    else if( contain( center1, powrad1, center2, powrad2 ) )
-    {
-        t_center = center1;
-        t_powrad = powrad1;
-    }
-    else if( contain( center2, powrad2, center1, powrad1 ) )
-    {
-        t_center = center2;
-        t_powrad = powrad2;
-    }
-    else
-    {
-        real radius1 = sqrt( powrad1 );
-        real radius2 = sqrt( powrad2 );
-        real center_dist = dist( center1, center2, 2 ) ;
-        real coef = ( radius1 - radius2 ) / center_dist ;
-        t_center = real(0.5) * ( ( 1 + coef ) * center1  +  ( 1 - coef ) * center2 ) ;
-        real t_radius = real(0.5) * ( center_dist + radius1 + radius2 ) ;
-        t_powrad = t_radius * t_radius;
-    }
-
-#ifdef DEBUG_CHECK_NAN
-    if (t_center.hasMissing())
-        PLERROR(&quot;In BallTreeNearestNeighbors::smallestContainer: t_center is NaN.&quot;);
-#endif
-}
-
-
-
-void BallTreeNearestNeighbors::BallKNN(
-     priority_queue&lt; pair&lt;real,int&gt; &gt;&amp; q, BinBallTree node,
-     const Vec&amp; t, real&amp; d2_sofar, real d2_pivot, const int k ) const
-{
-    real d_minp = max( sqrt(d2_pivot) - node-&gt;radius, 0.0 );
-#ifdef DEBUG_CHECK_NAN
-    if (isnan(d_minp))
-        PLERROR(&quot;BallTreeNearestNeighbors::BallKNN: d_minp is NaN&quot;);
-#endif
-
-    if (d_minp*d_minp &gt; d2_sofar)
-    {
-        // no chance of finding anything closer around this node
-        return;
-    }
-    else if (node-&gt;point_set.size()!=0) // node is leaf
-    {
-        int n_points = node-&gt;point_set.size();
-        for( int i=0 ; i&lt;n_points ; i++ )
-        {
-            int j = node-&gt;point_set[i];
-            real dist;
-            // last point is pivot, and we already now the distance
-            if( i==n_points-1 )
-            {
-                dist = d2_pivot;
-            }
-            else
-            {
-                Vec x = train_set.getSubRow(j, inputsize());
-                dist = powdistance(x, t, 2);
-            }
-            if( dist &lt; d2_sofar )
-            {
-                q.push( make_pair(dist, j) );
-                int n_found = q.size();
-                if( n_found &gt; k )
-                    q.pop();
-                if( n_found &gt;= k )
-                    d2_sofar = q.top().first;
-            }
-        }
-    }
-    else if (!node-&gt;isEmpty()) // node is not leaf
-    {
-        BinBallTree node1 = node-&gt;getFirstChild();
-        BinBallTree node2 = node-&gt;getSecondChild();
-
-        real d2_pivot1 = powdistance(t, node1-&gt;pivot, 2);
-        real d2_pivot2 = powdistance(t, node2-&gt;pivot, 2);
-
-        if( d2_pivot1 &gt; d2_pivot2 ) // node1 is closer to t
-        {
-            pl_swap(node1, node2);
-            pl_swap(d2_pivot1, d2_pivot2);
-        }
-
-        BallKNN(q, node1, t, d2_sofar, d2_pivot1, k);
-        BallKNN(q, node2, t, d2_sofar, d2_pivot2, k); 
-    }
-}
-
-
-void BallTreeNearestNeighbors::FindBallKNN(
-    priority_queue&lt; pair&lt;real,int&gt; &gt;&amp; q, const Vec&amp; point, const int k ) const
-{
-    real d2_sofar;
-    pl_isnumber(&quot;+inf&quot;, &amp;d2_sofar);
-    real d2_pivot = powdistance(point, ball_tree-&gt;pivot, 2);
-//    real d_minp = 0;
-    BallKNN(q, ball_tree, point, d2_sofar, d2_pivot, k);
-}
-
-} // end of namespace PLearn
-
-
-/*
-  Local Variables:
-  mode:c++
-  c-basic-offset:4
-  c-file-style:&quot;stroustrup&quot;
-  c-file-offsets:((innamespace . 0)(inline-open . 0))
-  indent-tabs-mode:nil
-  fill-column:79
-  End:
-*/
-// vim: filetype=cpp:expandtab:shiftwidth=4:tabstop=8:softtabstop=4:encoding=utf-8:textwidth=79 :

Deleted: branches/cgi-desjardin/plearn_learners/second_iteration/BallTreeNearestNeighbors.h
===================================================================
--- branches/cgi-desjardin/plearn_learners/second_iteration/BallTreeNearestNeighbors.h	2007-06-26 16:48:51 UTC (rev 7642)
+++ branches/cgi-desjardin/plearn_learners/second_iteration/BallTreeNearestNeighbors.h	2007-06-26 16:51:13 UTC (rev 7643)
@@ -1,227 +0,0 @@
-// -*- C++ -*-
-
-// BallTreeNearestNeighbors.h
-//
-// Copyright (C) 2004 Pascal Lamblin &amp; Marius Muja
-// 
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are met:
-// 
-//  1. Redistributions of source code must retain the above copyright
-//     notice, this list of conditions and the following disclaimer.
-// 
-//  2. Redistributions in binary form must reproduce the above copyright
-//     notice, this list of conditions and the following disclaimer in the
-//     documentation and/or other materials provided with the distribution.
-// 
-//  3. The name of the authors may not be used to endorse or promote
-//     products derived from this software without specific prior written
-//     permission.
-// 
-// THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
-// NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-// 
-// This file is part of the PLearn library. For more information on the PLearn
-// library, go to the PLearn Web site at www.plearn.org
-
-/* *******************************************************      
- * $Id: BallTreeNearestNeighbors.h 4900 2006-02-05 08:42:31Z lamblin $ 
- ******************************************************* */
-
-// Authors: Pascal Lamblin &amp; Marius Muja
-
-/*! \file BallTreeNearestNeighbors.h */
-
-
-#ifndef BallTreeNearestNeighbors_INC
-#define BallTreeNearestNeighbors_INC
-
-#include &lt;queue&gt;
-
-#include &lt;plearn_learners/generic/PLearner.h&gt;
-#include &lt;plearn_learners/nearest_neighbors/GenericNearestNeighbors.h&gt;
-#include &lt;plearn/vmat/SelectRowsVMatrix.h&gt;
-#include &lt;plearn/ker/DistanceKernel.h&gt;
-
-#include &quot;BinaryBallTree.h&quot;
-
-namespace PLearn {
-using namespace std;
-
-class BallTreeNearestNeighbors;
-typedef PP&lt; BallTreeNearestNeighbors &gt; BallTreeNN;
-
-class BallTreeNearestNeighbors: public GenericNearestNeighbors
-{
-
-private:
-
-    typedef GenericNearestNeighbors inherited;
-
-protected:
-
-    // *********************
-    // * protected options *
-    // *********************
-
-    BinBallTree ball_tree;
-    int nb_train_points;
-    int nb_points;
-
-public:
-
-    // ************************
-    // * public build options *
-    // ************************
-
-    TVec&lt;int&gt; point_indices;
-    int rmin;
-    string train_method;
-    TVec&lt;Mat&gt; anchor_set;
-    TVec&lt;int&gt; pivot_indices;
-
-    // ****************
-    // * Constructors *
-    // ****************
-
-    //! Default constructor.
-    BallTreeNearestNeighbors();
-
-    //! Constructor from a TrainSet and a BinBallTree.
-    BallTreeNearestNeighbors( const VMat&amp; tr_set, const BinBallTree&amp; b_tree );
-
-    // ********************
-    // * PLearner methods *
-    // ********************
-
-private: 
-
-    //! This does the actual building. 
-    // (Please implement in .cc)
-    void build_();
-    void anchorTrain();
-
-protected: 
-  
-    //! Declares this class' options.
-    // (Please implement in .cc)
-    static void declareOptions(OptionList&amp; ol);
-
-public:
-
-    // ************************
-    // **** Static methods ****
-    // ************************
-    // Maybe should I put this somewhere else...
-
-    // Returns true if the balls defined by (center1, radius1) and
-    // (center2, radius2) have a common part
-
-    static bool intersect( const Vec&amp; center1, const real&amp; radius1,
-                           const Vec&amp; center2, const real&amp; radius2 );
-
-    // Returns true if the first ball contains the second one
-    static bool contain( const Vec&amp; center1, const real&amp; radius1,
-                         const Vec&amp; center2, const real&amp; radius2 );
-
-    // Returns the smallest ball containing two balls
-    static void smallestContainer( const Vec&amp; center1, const real&amp; radius1,
-                                   const Vec&amp; center2, const real&amp; radius2,
-                                   Vec&amp; t_center, real&amp; t_radius);
-
-    virtual void BallKNN( priority_queue&lt; pair&lt;real,int&gt; &gt;&amp; q,
-                          BinBallTree node, const Vec&amp; t,
-                          real&amp; d_sofar, real d_minp, const int k ) const;
-
-    virtual void FindBallKNN( priority_queue&lt; pair&lt;real,int&gt; &gt;&amp; q,
-                              const Vec&amp; point, int k ) const;
-
-
-    // ************************
-    // **** Object methods ****
-    // ************************
-
-    //! Simply calls inherited::build() then build_().
-    virtual void build();
-
-    //! Transforms a shallow copy into a deep copy.
-    virtual void makeDeepCopyFromShallowCopy(map&lt;const void*, void*&gt;&amp; copies);
-
-    // Declares other standard object methods.
-    PLEARN_DECLARE_OBJECT(BallTreeNearestNeighbors);
-
-
-    // **************************
-    // **** PLearner methods ****
-    // **************************
-
-    //! (Re-)initializes the PLearner in its fresh state (that state may
-    //! depend on the 'seed' option) And sets 'stage' back to 0 (this is
-    //! the stage of a fresh learner!).
-    virtual void forget();
-
-
-    //! The role of the train method is to bring the learner up to
-    //! stage==nstages, updating the train_stats collector with training
-    //! costs measured on-line in the process.
-    virtual void train();
-
-    void createAnchors( int nb_anchors );
-
-
-    BinBallTree leafFromAnchor( int anchor_index );
-
-    BinBallTree treeFromLeaves( const TVec&lt;BinBallTree&gt;&amp; leaves );
-
-    BinBallTree getBallTree();
-
-
-    //! Computes the output and costs from the input (more effectively)
-    virtual void computeOutputAndCosts( const Vec&amp; input, const Vec&amp; target,
-                                        Vec&amp; output, Vec&amp; costs ) const;
-    //! Computes the output from the input.
-    virtual void computeOutput(const Vec&amp; input, Vec&amp; output) const;
-
-    //! Computes the costs from already computed output. 
-    virtual void computeCostsFromOutputs(const Vec&amp; input, const Vec&amp; output, 
-                                         const Vec&amp; target, Vec&amp; costs) const;
-
-
-    //! Returns the names of the costs computed by computeCostsFromOutpus
-    //! (and thus the test method).
-    virtual TVec&lt;string&gt; getTestCostNames() const;
-
-    //! Returns the names of the objective costs that the train method
-    //computes and ! for which it updates the VecStatsCollector
-    //train_stats.  (PLEASE IMPLEMENT IN .cc)
-    virtual TVec&lt;string&gt; getTrainCostNames() const;
-
-};
-
-// Declares a few other classes and functions related to this class.
-DECLARE_OBJECT_PTR(BallTreeNearestNeighbors);
-
-} // end of namespace PLearn
-
-#endif
-
-
-/*
-  Local Variables:
-  mode:c++
-  c-basic-offset:4
-  c-file-style:&quot;stroustrup&quot;
-  c-file-offsets:((innamespace . 0)(inline-open . 0))
-  indent-tabs-mode:nil
-  fill-column:79
-  End:
-*/
-// vim: filetype=cpp:expandtab:shiftwidth=4:tabstop=8:softtabstop=4:encoding=utf-8:textwidth=79 :

Deleted: branches/cgi-desjardin/plearn_learners/second_iteration/BinaryBallTree.cc
===================================================================
--- branches/cgi-desjardin/plearn_learners/second_iteration/BinaryBallTree.cc	2007-06-26 16:48:51 UTC (rev 7642)
+++ branches/cgi-desjardin/plearn_learners/second_iteration/BinaryBallTree.cc	2007-06-26 16:51:13 UTC (rev 7643)
@@ -1,153 +0,0 @@
-// -*- C++ -*-
-
-// BinaryBallTree.cc
-//
-// Copyright (C) 2004 Pascal Lamblin 
-// 
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are met:
-// 
-//  1. Redistributions of source code must retain the above copyright
-//     notice, this list of conditions and the following disclaimer.
-// 
-//  2. Redistributions in binary form must reproduce the above copyright
-//     notice, this list of conditions and the following disclaimer in the
-//     documentation and/or other materials provided with the distribution.
-// 
-//  3. The name of the authors may not be used to endorse or promote
-//     products derived from this software without specific prior written
-//     permission.
-// 
-// THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
-// NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-// 
-// This file is part of the PLearn library. For more information on the PLearn
-// library, go to the PLearn Web site at www.plearn.org
-
-/* *******************************************************      
- * $Id: BinaryBallTree.cc 3994 2005-08-25 13:35:03Z chapados $ 
- ******************************************************* */
-
-// Authors: Pascal Lamblin
-
-/*! \file BinaryBallTree.cc */
-
-
-#include &quot;BinaryBallTree.h&quot;
-
-namespace PLearn {
-using namespace std;
-
-BinaryBallTree::BinaryBallTree() 
-    : pivot( Vec() ),
-      radius( 0 )
-{}
-
-PLEARN_IMPLEMENT_OBJECT( BinaryBallTree,
-                         &quot;Binary Tree, containing a point, a radius, and a set of points&quot;, 
-                         &quot;Each node of the tree contains the parameters of a ball :\n&quot;
-                         &quot;a point and a radius.\n&quot;
-                         &quot;Each leaf node contains a list of indices of points,\n&quot;
-                         &quot;each non-leaf node has two children nodes.&quot;);
-
-void BinaryBallTree::declareOptions( OptionList&amp; ol )
-{
-    declareOption( ol, &quot;pivot&quot;, &amp;BinaryBallTree::pivot, OptionBase::buildoption,
-                   &quot;Center of the ball&quot; );
-
-    declareOption(ol, &quot;radius&quot;, &amp;BinaryBallTree::radius, OptionBase::buildoption,
-                  &quot;Radius of the ball&quot; );
-
-    declareOption(ol, &quot;point_set&quot;, &amp;BinaryBallTree::point_set, OptionBase::buildoption,
-                  &quot;List of indices of the points owned by this node (leaf only)&quot; );
-
-    declareOption(ol, &quot;child1&quot;, &amp;BinaryBallTree::child1, OptionBase::tuningoption,
-                  &quot;Pointer to first child (non-leaf only)&quot; );
-
-    declareOption(ol, &quot;child2&quot;, &amp;BinaryBallTree::child2, OptionBase::tuningoption,
-                  &quot;Pointer to second child (non-leaf only)&quot; );
-
-    // Now call the parent class' declareOptions
-    inherited::declareOptions(ol);
-}
-
-void BinaryBallTree::build_()
-{
-    if( child1 )
-    { child1-&gt;parent = this; }
-
-    if( child2 )
-    { child2-&gt;parent = this; }
-}
-
-void BinaryBallTree::build()
-{
-    inherited::build();
-    build_();
-}
-
-void BinaryBallTree::setFirstChild( const BinBallTree&amp; first_child )
-{
-    this-&gt;child1 = first_child;
-    if( first_child )
-    {
-        first_child-&gt;parent = this;
-    }
-}
-
-void BinaryBallTree::setSecondChild( const BinBallTree&amp; second_child )
-{
-    this-&gt;child2 = second_child;
-    if( second_child )
-    {
-        second_child-&gt;parent = this;
-    }
-}
-
-BinBallTree BinaryBallTree::getFirstChild()
-{
-    return this-&gt;child1;
-}
-
-BinBallTree BinaryBallTree::getSecondChild()
-{
-    return this-&gt;child2;
-}
-
-BinaryBallTree* BinaryBallTree::getParent()
-{
-    return this-&gt;parent;
-}
-
-void BinaryBallTree::makeDeepCopyFromShallowCopy(map&lt;const void*, void*&gt;&amp; copies)
-{
-    inherited::makeDeepCopyFromShallowCopy(copies);
-
-    deepCopyField( child1, copies );
-    deepCopyField( child2, copies );
-    deepCopyField( pivot, copies );
-    deepCopyField( point_set, copies );
-}
-
-} // end of namespace PLearn
-
-
-/*
-  Local Variables:
-  mode:c++
-  c-basic-offset:4
-  c-file-style:&quot;stroustrup&quot;
-  c-file-offsets:((innamespace . 0)(inline-open . 0))
-  indent-tabs-mode:nil
-  fill-column:79
-  End:
-*/
-// vim: filetype=cpp:expandtab:shiftwidth=4:tabstop=8:softtabstop=4:encoding=utf-8:textwidth=79 :

Deleted: branches/cgi-desjardin/plearn_learners/second_iteration/BinaryBallTree.h
===================================================================
--- branches/cgi-desjardin/plearn_learners/second_iteration/BinaryBallTree.h	2007-06-26 16:48:51 UTC (rev 7642)
+++ branches/cgi-desjardin/plearn_learners/second_iteration/BinaryBallTree.h	2007-06-26 16:51:13 UTC (rev 7643)
@@ -1,147 +0,0 @@
-// -*- C++ -*-
-
-// BinaryBallTree.h
-//
-// Copyright (C) 2004 Pascal Lamblin 
-// 
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are met:
-// 
-//  1. Redistributions of source code must retain the above copyright
-//     notice, this list of conditions and the following disclaimer.
-// 
-//  2. Redistributions in binary form must reproduce the above copyright
-//     notice, this list of conditions and the following disclaimer in the
-//     documentation and/or other materials provided with the distribution.
-// 
-//  3. The name of the authors may not be used to endorse or promote
-//     products derived from this software without specific prior written
-//     permission.
-// 
-// THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
-// NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-// 
-// This file is part of the PLearn library. For more information on the PLearn
-// library, go to the PLearn Web site at www.plearn.org
-
-/* *******************************************************      
- * $Id: BinaryBallTree.h 3994 2005-08-25 13:35:03Z chapados $ 
- ******************************************************* */
-
-// Authors: Pascal Lamblin
-
-/*! \file BinaryBallTree.h */
-
-
-#ifndef BinaryBallTree_INC
-#define BinaryBallTree_INC
-
-#include &lt;plearn/base/Object.h&gt;
-
-namespace PLearn {
-using namespace std;
-
-class BinaryBallTree;
-typedef PP&lt;BinaryBallTree&gt; BinBallTree;
-
-class BinaryBallTree: public Object
-{
-
-private:
-  
-    typedef Object inherited;
-
-protected:
-    // *********************
-    // * protected options *
-    // *********************
-
-    BinaryBallTree* parent;
-    BinBallTree child1;
-    BinBallTree child2;
-
-public:
-
-    // ************************
-    // * public build options *
-    // ************************
-
-    Vec pivot;
-    real radius;
-    TVec&lt;int&gt; point_set;
-
-    // ****************
-    // * Constructors *
-    // ****************
-
-    //! Default constructor.
-    BinaryBallTree();
-
-
-    // ******************
-    // * Object methods *
-    // ******************
-
-private: 
-    //! This does the actual building. 
-    void build_();
-
-protected: 
-    //! Declares this class' options.
-    static void declareOptions(OptionList&amp; ol);
-
-public:
-    // Declares other standard object methods.
-    PLEARN_DECLARE_OBJECT(BinaryBallTree);
-
-    // simply calls inherited::build() then build_() 
-    virtual void build();
-
-    //! Transforms a shallow copy into a deep copy
-    virtual void makeDeepCopyFromShallowCopy(map&lt;const void*, void*&gt;&amp; copies);
-
-    virtual void setFirstChild( const BinBallTree&amp; first_child );
-
-    virtual void setSecondChild( const BinBallTree&amp; second_child );
-
-    virtual BinBallTree getFirstChild();
-
-    virtual BinBallTree getSecondChild();
-
-    virtual BinaryBallTree* getParent();
-
-    bool isEmpty() const
-    {
-        bool result = !pivot &amp;&amp; !child1 &amp;&amp; !child2 ;
-        return result;
-    }
-
-};
-
-// Declares a few other classes and functions related to this class
-DECLARE_OBJECT_PTR(BinaryBallTree);
-  
-} // end of namespace PLearn
-
-#endif
-
-
-/*
-  Local Variables:
-  mode:c++
-  c-basic-offset:4
-  c-file-style:&quot;stroustrup&quot;
-  c-file-offsets:((innamespace . 0)(inline-open . 0))
-  indent-tabs-mode:nil
-  fill-column:79
-  End:
-*/
-// vim: filetype=cpp:expandtab:shiftwidth=4:tabstop=8:softtabstop=4:encoding=utf-8:textwidth=79 :


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001090.html">[Plearn-commits] r7642 -	branches/cgi-desjardin/plearn_learners/second_iteration
</A></li>
	<LI>Next message: <A HREF="001092.html">[Plearn-commits] r7644 -	branches/cgi-desjardin/plearn_learners/second_iteration
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1091">[ date ]</a>
              <a href="thread.html#1091">[ thread ]</a>
              <a href="subject.html#1091">[ subject ]</a>
              <a href="author.html#1091">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/plearn-commits">More information about the Plearn-commits
mailing list</a><br>
</body></html>
